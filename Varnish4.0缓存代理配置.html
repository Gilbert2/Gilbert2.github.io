<!DOCTYPE html><html lang=zh-CN><head><meta charset=UTF-8><meta name=viewport content="width=device-width, initial-scale=1, maximum-scale=2"><meta name=theme-color content=#222><meta name=generator content="Hexo 4.2.0"><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon-next.png><link rel=icon type=image/png sizes=32x32 href=/images/favicon-32x32-next.png><link rel=icon type=image/png sizes=16x16 href=/images/favicon-16x16-next.png><link rel=mask-icon href=/images/logo.svg color=#222><meta name=msvalidate.01 content=true><link rel=stylesheet href=/css/main.css><link rel=stylesheet href=/lib/font-awesome/css/all.min.css><link rel=stylesheet href=//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css><script id=hexo-configurations>
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"pdxblog.top","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"b2t":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":{"enable":true,"onlypost":false,"loadingImg":null},"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script><meta name=description content=架构><meta property=og:type content=article><meta property=og:title content=Varnish4.0缓存代理配置><meta property=og:url content=https://pdxblog.top/Varnish4.0%E7%BC%93%E5%AD%98%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE.html><meta property=og:site_name content=Maisyの博客><meta property=og:description content=架构><meta property=og:locale content=zh_CN><meta property=og:image content="https://img-blog.csdnimg.cn/20200701180737851.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTYzNjcwMg==,size_16,color_FFFFFF,t_70"><meta property=og:image content="https://img-blog.csdnimg.cn/2020070118081672.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTYzNjcwMg==,size_16,color_FFFFFF,t_70"><meta property=og:image content="https://img-blog.csdnimg.cn/20200701180906611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTYzNjcwMg==,size_16,color_FFFFFF,t_70"><meta property=og:image content="https://img-blog.csdnimg.cn/20200701180924925.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTYzNjcwMg==,size_16,color_FFFFFF,t_70"><meta property=og:image content="https://img-blog.csdnimg.cn/20200701181019348.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTYzNjcwMg==,size_16,color_FFFFFF,t_70"><meta property=article:published_time content=2020-06-30T16:00:00.000Z><meta property=article:modified_time content=2020-07-01T10:15:32.941Z><meta property=article:author content=Maisy><meta property=article:tag content=架构><meta name=twitter:card content=summary><meta name=twitter:image content="https://img-blog.csdnimg.cn/20200701180737851.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTYzNjcwMg==,size_16,color_FFFFFF,t_70"><link rel=canonical href=https://pdxblog.top/Varnish4.0%E7%BC%93%E5%AD%98%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE.html><script id=page-configurations>
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script><title>Varnish4.0缓存代理配置 | Maisyの博客</title><noscript><style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style></noscript><link rel=alternate href=/atom.xml title=Maisyの博客 type=application/atom+xml></head><body itemscope itemtype=http://schema.org/WebPage><div class="container use-motion"><div class=headband></div><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label=切换导航栏><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class=site-meta><a href="/" class=brand rel=start><span class=logo-line-before><i></i></span><h1 class=site-title>Maisyの博客</h1><span class=logo-line-after><i></i></span></a><p class=site-subtitle itemprop=description>记录生活中的点点滴滴</p></div><div class=site-nav-right><div class="toggle popup-trigger"></div></div></div><nav class=site-nav><ul id=menu class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel=section><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-top"><a href="/top/" rel=section><i class="fa fa-signal fa-fw"></i>排行榜</a></li><li class="menu-item menu-item-about"><a href="/about/" rel=section><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel=section><i class="fa fa-tags fa-fw"></i>标签<span class=badge>7</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel=section><i class="fa fa-th fa-fw"></i>分类<span class=badge>7</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel=section><i class="fa fa-archive fa-fw"></i>归档<span class=badge>69</span></a></li></ul></nav></div></header><div class=back-to-top><i class="fa fa-arrow-up"></i> <span>0%</span></div><main class=main><div class=main-inner><div class=content-wrap><div class="content post posts-expand"><article itemscope itemtype=http://schema.org/Article class=post-block lang=zh-CN><link itemprop=mainEntityOfPage href=https://pdxblog.top/Varnish4.0%E7%BC%93%E5%AD%98%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE.html><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content=/images/author.jpg><meta itemprop=name content=Maisy><meta itemprop=description content=人的一生就是一个储蓄的过程，在奋斗的时候储存了希望；在耕耘的时候储存了一粒种子；在旅行的时候储存了风景；在微笑的时候储存了快乐。聪明的人善于储蓄，在漫长而短暂的人生旅途中，学会储蓄每一个闪光的瞬间，然后用它们酿成一杯美好的回忆，在四季的变幻与交替之间，散发浓香，珍藏一生></span> <span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content=Maisyの博客></span><header class=post-header><h1 class=post-title itemprop="name headline">Varnish4.0缓存代理配置</h1><div class=post-meta><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i></span> <span class=post-meta-item-text>发表于</span><time title="创建时间：2020-07-01 00:00:00 / 修改时间：18:15:32" itemprop="dateCreated datePublished" datetime=2020-07-01T00:00:00+08:00>2020-07-01</time></span> <span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder"></i></span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing><a href="/categories/%E6%9E%B6%E6%9E%84/" itemprop=url rel=index><span itemprop=name>架构</span></a></span></span><br><span class=post-meta-item title=本文字数><span class=post-meta-item-icon><i class="far fa-file-word"></i></span> <span class=post-meta-item-text>本文字数：</span> <span>22k</span></span> <span class=post-meta-item title=阅读时长><span class=post-meta-item-icon><i class="far fa-clock"></i></span> <span class=post-meta-item-text>阅读时长 &asymp;</span> <span>20 分钟</span></span><div class=post-description>架构</div></div></header><div class=post-body itemprop=articleBody><h3 id=Varnish4-0缓存代理配置><a class=header-anchor href=#Varnish4-0缓存代理配置>¶</a>Varnish4.0缓存代理配置</h3><h4 id=一、Varnish原理><a class=header-anchor href=#一、Varnish原理>¶</a>一、Varnish原理</h4><h5 id=1、Varnish简介><a class=header-anchor href=#1、Varnish简介>¶</a>1、Varnish简介</h5><blockquote><p>varnish 缓存是 web 应用加速器，同时也作为 http 反向缓存代理。你可以安装 varnish 在任何http 的前端，同时配置它缓存内容。与传统的 squid 相比，varnish 具有性能更高、速度更快、管理更加方便等诸多优点。有一部分企业已经在生产环境中使用其作为旧版本的 squid的替代方案，以在相同的服务器成本下提供更好的缓存效果，Varnish 更是作为 CDN 缓存服务器的可选服务之一</p></blockquote><p>根据官网的介绍，Varnish 的主要特性如下：<a href="https://www.varnish-cache.org/" target=_blank rel=noopener>https://www.varnish-cache.org/</a></p><ul><li>缓存位置：</li></ul><blockquote><p>可以使用内存也可以使用磁盘。如果要使用磁盘的话推荐 SSD 做 RAID1</p></blockquote><ul><li>日志存储：</li></ul><blockquote><p>日志也存储在内存中。存储策略：固定大小，循环使用支持虚拟内存的使用</p><p>有精确的时间管理机制，即缓存的时间属性控制</p></blockquote><ul><li>状态引擎架构：</li></ul><blockquote><p>在不同的引擎上完成对不同的缓存和代理数据进行处理。可以通过特定的配置语言设计不同的控制语句，以决定数据在不同位置以不同方式缓存，在特定的地方对经过的报文进行特定规则的处理</p></blockquote><ul><li>缓存管理：</li></ul><blockquote><p>以二叉堆格式管理缓存数据，做到数据的及时清理</p></blockquote><h5 id=2、Varnish-与-与-Squid-的对比><a class=header-anchor href=#2、Varnish-与-与-Squid-的对比>¶</a>2、Varnish 与 与 Squid 的对比</h5><p>相同点：</p><blockquote><p>都是一个反向代理服务器</p><p>都是开源软件</p></blockquote><h6 id=Varnish-的优势：><a class=header-anchor href=#Varnish-的优势：>¶</a>Varnish 的优势：</h6><figure class="highlight tex"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre></td><td class=code><pre><span class=line>Varnish 的稳定性很高，两者在完成相同负荷的工作时，Squid 服务器发生故障的几率要高于 Varnish，因为使用 Squid 要经常重启</span><br><span class=line></span><br><span class=line>Varnish 访问速度更快，因为采用了“Visual Page Cache”技术，所有缓存数据都直接从内存读取，而 squid 是从硬盘读取，因而 Varnish 在访问速度方面会更快</span><br><span class=line></span><br><span class=line>Varnish 可以支持更多的并发连接，因为 Varnish 的 TCP 连接释放要比 Squid 快，因而在高并发连接情况下可以支持更多 TCP 连接</span><br><span class=line></span><br><span class=line>Varnish 可以通过管理端口，使用正则表达式批量的清除部分缓存，而 Squid 是做不到的；</span><br><span class=line>squid 属于是单进程使用单核 CPU，但 Varnish 是通过 fork 形式打开多进程来做处理，所以可以合理的使用所有核来处理相应的请求</span><br></pre></td></tr></table></figure><h6 id=Varnish-的劣势：><a class=header-anchor href=#Varnish-的劣势：>¶</a>Varnish 的劣势：</h6><figure class="highlight plain"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre></td><td class=code><pre><span class=line>varnish 进程一旦 Crash 或者重启，缓存数据都会从内存中完全释放，此时所有请求都会发送到后端服务器，在高并发情况下，会给后端服务器造成很大压力</span><br><span class=line></span><br><span class=line>在 varnish 使用中如果单个 url 的请求通过 HA&#x2F;F5 等负载均衡，则每次请求落在不同的varnish 服务器中，造成请求都会被穿透到后端；而且同样的请求在多台服务器上缓存，也会造成 varnish 的缓存的资源浪费，造成性能下降</span><br></pre></td></tr></table></figure><h6 id=Varnish-劣势的解决方案><a class=header-anchor href=#Varnish-劣势的解决方案>¶</a>Varnish 劣势的解决方案</h6><p>针对劣势一：</p><blockquote><p>在访问量很大的情况下推荐使用 varnish 的内存缓存方式启动，而且后面需要跟多台 squid/nginx 服务器。主要为了防止前面的 varnish 服 务、服务器被重启的情况下，大量请求穿透 varnish，这样 squid/nginx 可以就担当第二层 CACHE，而且也弥补了 varnish 缓存在内存中重启都会释放的问题</p></blockquote><p>针对劣势二：</p><blockquote><p>可以在负载均衡上做 url 哈希，让单个 url 请求固定请求到一台 varnish 服务器上</p></blockquote><h5 id=3、使用-varnish-作为-web-代理缓存的原理><a class=header-anchor href=#3、使用-varnish-作为-web-代理缓存的原理>¶</a>3、使用 varnish 作为 web 代理缓存的原理</h5><blockquote><p>varnish 是一个 http 反向代理的缓存。它从客户端接收请求然后尝试从缓存中获取数据来响应客户端的请求，如果 varnish 不能从缓存中获得数据来响应客户端，它将转发请求到后端（backend servers）,获取响应同时存储，最后交付给客户端</p><p>如果 varnish 已经缓存了某个响应，它比你传统的后端服务器的响应要快很多，所以你需要尽可能是更多的请求直接从 varnish 的缓存中获取响应</p><p>varnish 决定是缓存内容或者是从后端服务器获取响应。后端服务器能通过 http 响应头中的Cache-Control 来同步 varnish 缓存内容。在某些条件下 varnish 将不缓存内容，最常见的是使用 cookie。当一个被标记有 cookie 的客户端 web 请求，varnish 默认是不缓存。这些众多的varnish 功能特点都是可以通过写 vcl 来改变的</p></blockquote><h5 id=4、-简单架构><a class=header-anchor href=#4、-简单架构>¶</a>4、 简单架构</h5><p>Varnish 分为 management 进程和 child 进程</p><h6 id=Management-进程：><a class=header-anchor href=#Management-进程：>¶</a>Management 进程：</h6><blockquote><p>对子进程进行管理，同时对 VCL 配置进行编译，并应用到不同的状态引擎</p></blockquote><h6 id=Child-进程：><a class=header-anchor href=#Child-进程：>¶</a>Child 进程：</h6><blockquote><p>生成线程池，负责对用户请求进行处理，并通过 hash 查找返回用户结果</p></blockquote><h5 id=5、varnish-主要配置部分><a class=header-anchor href=#5、varnish-主要配置部分>¶</a>5、varnish 主要配置部分</h5><p>varnish 配置主要分为：</p><ul><li>后端配置</li><li>ACL 配置</li><li>probes 配置</li><li>directors 配置</li><li>核心子程序配置</li></ul><p>其中后端配置是必要的，在多台服务器中还会用到 directors 配置，核心子程序配置</p><h6 id=后端配置：><a class=header-anchor href=#后端配置：>¶</a>后端配置：</h6><blockquote><p>即给 varnish 添加反代服务器节点，最少配置一个</p></blockquote><h6 id=ACL-配置：><a class=header-anchor href=#ACL-配置：>¶</a>ACL 配置：</h6><blockquote><p>即给 varnish 添加访问控制列表，可以指定这些列表访问或禁止访问</p></blockquote><h6 id=probes-配置：><a class=header-anchor href=#probes-配置：>¶</a>probes 配置：</h6><blockquote><p>即给 varnish 添加探测后端服务器是否正常的规则，方便切换或禁止对应后端服务器</p></blockquote><h6 id=directors-配置：><a class=header-anchor href=#directors-配置：>¶</a>directors 配置：</h6><blockquote><p>即给 varnish 添加负载均衡模式管理多个后端服务器</p></blockquote><h6 id=核心子程序配置：><a class=header-anchor href=#核心子程序配置：>¶</a>核心子程序配置：</h6><blockquote><p>即给 varnish 添加后端服务器切换，请求缓存，访问控制，错误处理等规则</p></blockquote><h5 id=6、VCL-中内置-预设变量：-变量-也叫-object-）><a class=header-anchor href=#6、VCL-中内置-预设变量：-变量-也叫-object-）>¶</a>6、VCL 中内置 预设变量： 变量( 也叫 object ）</h5><p><img data-src="https://img-blog.csdnimg.cn/20200701180737851.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTYzNjcwMg==,size_16,color_FFFFFF,t_70"></p><p>req：</p><blockquote><p>The request object，请求到达时可用的变量(客户端发送的请求对象)</p></blockquote><p>bereq：</p><blockquote><p>The backend request object，向后端主机请求时可用的变量</p></blockquote><p>beresp：</p><blockquote><p>The backend response object，从后端主机获取内容时可用的变量(后端响应请求对象)</p></blockquote><p>resp：</p><blockquote><p>The HTTP response object，对客户端响应时可用的变量(返回给客户端的响应对象)</p></blockquote><p>obj：</p><blockquote><p>存储在内存中时对象属性相关的可用的变量(高速缓存对象，缓存后端响应请求内容)</p></blockquote><p>预设变量是系统固定的，请求进入对应的 vcl 子程序后便生成，这些变量可以方便子程序提取，当然也可以自定义一些全局变量</p><p>当前时间：</p><h6 id=now-作用：返回当前时间戳><a class=header-anchor href=#now-作用：返回当前时间戳>¶</a>now 作用：返回当前时间戳</h6><h6 id=客户端：（客户端基本信息）><a class=header-anchor href=#客户端：（客户端基本信息）>¶</a>客户端：（客户端基本信息）</h6><p>注：原 client.port 已经弃用，如果要取客户端请求端口号使用std.port(client.ip)， importstd;才可以使用 std</p><blockquote><p>client.ip：返回客户端 IP 地址</p><p>client.identity：用于装载客户端标识码</p></blockquote><h6 id=服务器：（服务器基本信息）><a class=header-anchor href=#服务器：（服务器基本信息）>¶</a>服务器：（服务器基本信息）</h6><p>注：原 server.port 已经弃用，如果要取服务器端口号使用std.port(server.ip)，需要 import std;才可以使用 std</p><blockquote><p>server.hostname：服务器主机名</p><p>server.identity：服务器身份标识</p><p>server.ip：返回服务器端 IP 地址</p></blockquote><h6 id=req-（客户端发送的请求对象）><a class=header-anchor href=#req-（客户端发送的请求对象）>¶</a>req :（客户端发送的请求对象）</h6><figure class="highlight plain"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br></pre></td><td class=code><pre><span class=line>req：整个 HTTP 请求数据结构</span><br><span class=line></span><br><span class=line>req.backend_hint：指定请求后端节点，设置后 bereq.backend 才能获取后端节点配置数据</span><br><span class=line></span><br><span class=line>req.can_gzip：客户端是否接受 GZIP 传输编码</span><br><span class=line></span><br><span class=line>req.hash_always_miss：是否强制不命中高速缓存，如果设置为 true，则高速缓存不会命中，一直会从后端获取新数据</span><br><span class=line></span><br><span class=line>req.hash_ignore_busy：忽略缓存中忙碌的对象，多台缓存时可以避免死锁</span><br><span class=line></span><br><span class=line>req.http：对应请求 HTTP 的 header</span><br><span class=line></span><br><span class=line>req.method：请求类型（如 GET , POST）</span><br><span class=line></span><br><span class=line>req.proto：客户端使用的 HTTP 协议版本</span><br><span class=line></span><br><span class=line>req.restarts：重新启动次数。默认最大值是 4</span><br><span class=line></span><br><span class=line>req.ttl：缓存有剩余时间</span><br><span class=line></span><br><span class=line>req.url：请求的 URL</span><br><span class=line></span><br><span class=line>req.xid：唯一 ID</span><br></pre></td></tr></table></figure><h6 id=bereq：（发送到后端的请求对象，基于-req-对象）><a class=header-anchor href=#bereq：（发送到后端的请求对象，基于-req-对象）>¶</a>bereq：（发送到后端的请求对象，基于 req 对象）</h6><figure class="highlight plain"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br></pre></td><td class=code><pre><span class=line>bereq：（发送到后端的请求对象，基于 req 对象）</span><br><span class=line></span><br><span class=line>bereq：整个后端请求后数据结构</span><br><span class=line></span><br><span class=line>bereq.backend：所请求后端节点配置</span><br><span class=line></span><br><span class=line>bereq.between_bytes_timeout：从后端每接收一个字节之间的等待时间（秒）</span><br><span class=line>bereq.connect_timeout：连接后端等待时间（秒），最大等待时间</span><br><span class=line></span><br><span class=line>bereq.first_byte_timeout：等待后端第一个字节时间（秒），最大等待时间</span><br><span class=line></span><br><span class=line>bereq.http：对应发送到后端 HTTP 的 header 信息</span><br><span class=line></span><br><span class=line>bereq.method：发送到后端的请求类型（如：GET , POST）</span><br><span class=line></span><br><span class=line>bereq.proto：发送到后端的请求的 HTTP 版本</span><br><span class=line></span><br><span class=line>bereq.retries：相同请求重试计数</span><br><span class=line></span><br><span class=line>bereq.uncacheable：无缓存这个请求</span><br><span class=line></span><br><span class=line>bereq.url：发送到后端请求的 URL</span><br><span class=line></span><br><span class=line>bereq.xid：请求唯一 ID</span><br></pre></td></tr></table></figure><h6 id=beresp：（后端响应请求对象）><a class=header-anchor href=#beresp：（后端响应请求对象）>¶</a>beresp：（后端响应请求对象）</h6><figure class="highlight plain"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br></pre></td><td class=code><pre><span class=line>beresp：整个后端响应 HTTP 数据结构</span><br><span class=line></span><br><span class=line>beresp.backend.ip：后端响应的 IP</span><br><span class=line></span><br><span class=line>beresp.backend.name：响应后端配置节点的 name</span><br><span class=line></span><br><span class=line>beresp.do_gunzip：默认为 false 。缓存前解压该对象</span><br><span class=line></span><br><span class=line>beresp.do_gzip：默认为 false 。缓存前压缩该对象</span><br><span class=line></span><br><span class=line>beresp.grace：设置当前对象缓存过期后可额外宽限时间，用于特殊请求加大缓存时间，当并发量巨大时，不易设置过大否则会堵塞缓存，一般可设置 1m 左右，当 beresp.ttl&#x3D;0s 时该值无效</span><br><span class=line></span><br><span class=line>beresp.http：对应的 HTTP 请求 header</span><br><span class=line></span><br><span class=line>beresp.keep：对象缓存后带保持时间</span><br><span class=line></span><br><span class=line>beresp.proto：响应的 HTTP 版本</span><br><span class=line></span><br><span class=line>beresp.reason：由服务器返回的 HTTP 状态信息</span><br><span class=line></span><br><span class=line>beresp.status：由服务器返回的状态码</span><br><span class=line></span><br><span class=line>beresp.storage_hint：指定保存的特定存储器</span><br><span class=line></span><br><span class=line>beresp.ttl：该对象缓存的剩余时间，指定统一缓存剩余时间。</span><br><span class=line></span><br><span class=line>beresp.uncacheable：继承 bereq.uncacheable，是否不缓存</span><br></pre></td></tr></table></figure><h6 id=OBJ-：（高速缓存对象，缓存后端响应请求内容）><a class=header-anchor href=#OBJ-：（高速缓存对象，缓存后端响应请求内容）>¶</a>OBJ ：（高速缓存对象，缓存后端响应请求内容）</h6><figure class="highlight plain"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre></td><td class=code><pre><span class=line>obj.grace：该对象额外宽限时间</span><br><span class=line></span><br><span class=line>obj.hits：缓存命中次数，计数器从 1 开始，当对象缓存该值为 1，一般可以用于判断是否有缓存，当前该值大于 0 时则为有缓存</span><br><span class=line></span><br><span class=line>obj.http：对应 HTTP 的 header</span><br><span class=line></span><br><span class=line>obj.proto：HTTP 版本</span><br><span class=line></span><br><span class=line>obj.reason：服务器返回的 HTTP 状态信息</span><br><span class=line></span><br><span class=line>obj.status：服务器返回的状态码</span><br><span class=line></span><br><span class=line>obj.ttl：该对象缓存剩余时间（秒）</span><br><span class=line></span><br><span class=line>obj.uncacheable：不缓存对象</span><br></pre></td></tr></table></figure><h6 id=resp-（返回给客户端的响应对象）><a class=header-anchor href=#resp-（返回给客户端的响应对象）>¶</a>resp :（返回给客户端的响应对象）</h6><figure class="highlight plain"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre></td><td class=code><pre><span class=line>resp：整个响应 HTTP 数据结构</span><br><span class=line></span><br><span class=line>resp.http：对应 HTTP 的 header</span><br><span class=line></span><br><span class=line>resp.proto：编辑响应的 HTTP 协议版本</span><br><span class=line></span><br><span class=line>resp.reason：将要返回的 HTTP 状态信息</span><br><span class=line></span><br><span class=line>resq.status：将要返回的 HTTP 状态码</span><br></pre></td></tr></table></figure><h6 id=存储-：><a class=header-anchor href=#存储-：>¶</a>存储 ：</h6><figure class="highlight plain"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre></td><td class=code><pre><span class=line>storage.&lt;name&gt;.free_space：存储可用空间（字节数）</span><br><span class=line></span><br><span class=line>storage.&lt;name&gt;.used_space：存储已经使用空间（字节数）</span><br><span class=line></span><br><span class=line>storage.&lt;name&gt;.happy：存储健康状态</span><br></pre></td></tr></table></figure><h5 id=7、特定功能性语句><a class=header-anchor href=#7、特定功能性语句>¶</a>7、特定功能性语句</h5><figure class="highlight tex"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br></pre></td><td class=code><pre><span class=line>ban(expression)：清除指定对象缓存</span><br><span class=line></span><br><span class=line>call(subroutine)：调用子程序，如：call(name)</span><br><span class=line></span><br><span class=line>hash_data(input)：生成 hash 键，用于制定 hash 键值生成结构，只能在 vcl_hash 子程序中使用。调用 hash_data(input) 后，即这个 hash 为当前页面的缓存 hash 键值，无需其它获取或操作，如：</span><br><span class=line>sub vcl_hash&#123;</span><br><span class=line>hash_data(client.ip);</span><br><span class=line>return(lookup);</span><br><span class=line>&#125;</span><br><span class=line>注意：return(lookup); 是默认返回值，所以可以不写</span><br><span class=line></span><br><span class=line>new()：创建一个 vcl 对象，只能在 vcl_init 子程序中使用</span><br><span class=line></span><br><span class=line>return()：结束当前子程序，并指定继续下一步动作，如：return (ok); 每个子程序可指定的动作均有不同</span><br><span class=line></span><br><span class=line>rollback()：恢复 HTTP 头到原来状态，已经弃用，使用 std.rollback() 代替</span><br><span class=line></span><br><span class=line>synthetic(STRING)：合成器，用于自定义一个响应内容，比如当请求出错时，可以返回自定义 404 内容，而不只是默认头信息，只能在 vcl_synth 与 vcl_backend_error 子程序中使用，如：</span><br><span class=line>sub vcl_synth &#123;</span><br><span class=line>	//自定义内容</span><br><span class=line>	synthetic (&#123;"</span><br><span class=line>&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;</span><br><span class=line>&lt;html lang="zh-cn"&gt;</span><br><span class=line>	&lt;head&gt;</span><br><span class=line>	&lt;meta http-equiv="ContentType"content="text/html;charset=utf-8"/&gt;</span><br><span class=line>		&lt;title&gt;error&lt;/title&gt;</span><br><span class=line>	&lt;/head&gt;</span><br><span class=line>	&lt;body&gt;</span><br><span class=line>		&lt;h1&gt;Error&lt;/h1&gt;</span><br><span class=line>		&lt;h3&gt;这只是一个测试自定义响应异常内容&lt;/h3&gt;</span><br><span class=line>	&lt;/body&gt;</span><br><span class=line>&lt;/html&gt;</span><br><span class=line>	"&#125;);</span><br><span class=line>	//只交付自定义内容</span><br><span class=line>	return(deliver);</span><br><span class=line>regsub(str, regex, sub)：使用正则替换第一次出现的字符串，第一个参数为待处理字符串，第二个参数为正则表达式，第三个为替换为字符串</span><br><span class=line></span><br><span class=line>regsuball(str, regex, sub)：使用正则替换所有匹配字符串。参数与 regsuball 相同</span><br><span class=line>具体变量详见：</span><br><span class=line>https://www.varnish-cache.org/docs/4.0/reference/vcl.html#reference-vcl</span><br></pre></td></tr></table></figure><h5 id=8、return语句><a class=header-anchor href=#8、return语句>¶</a>8、return语句</h5><p>return 语句是终止子程序并返回动作，所有动作都根据不同的 vcl 子程序限定来选用</p><p><a href=https://www.varnish-cache.org/docs/4.0/users-guide/vcl-built-in-subs.html target=_blank rel=noopener>https://www.varnish-cache.org/docs/4.0/users-guide/vcl-built-in-subs.html</a><br>语法：return(action);</p><p>常用的动作：</p><figure class="highlight plain"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br></pre></td><td class=code><pre><span class=line>abandon 放弃处理，并生成一个错误</span><br><span class=line></span><br><span class=line>deliver 交付处理</span><br><span class=line></span><br><span class=line>fetch 从后端取出响应对象</span><br><span class=line></span><br><span class=line>hash 哈希缓存处理</span><br><span class=line></span><br><span class=line>lookup 查找缓存对象</span><br><span class=line></span><br><span class=line>ok 继续执行</span><br><span class=line></span><br><span class=line>pass 进入 pass 非缓存模式</span><br><span class=line></span><br><span class=line>pipe 进入 pipe 非缓存模式</span><br><span class=line></span><br><span class=line>purge 清除缓存对象，构建响应</span><br><span class=line></span><br><span class=line>restart 重新开始</span><br><span class=line></span><br><span class=line>retry 重试后端处理</span><br><span class=line></span><br><span class=line>synth(status code,reason) 合成返回客户端状态信息</span><br></pre></td></tr></table></figure><h5 id=9、varnish-中内置子程序><a class=header-anchor href=#9、varnish-中内置子程序>¶</a>9、varnish 中内置子程序</h5><p>注：varnish 内置子程序均有自己限定的返回动作 return （动作）; 不同的动作将调用对应下一个子程序</p><h6 id=vcl-recv-子程序><a class=header-anchor href=#vcl-recv-子程序>¶</a>vcl_recv 子程序</h6><figure class="highlight plain"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line>开始处理请求，通过 return (动作); 选择 varnish 处理模式，默认进入 hash 缓存模式（即return(hash);），缓存时间为配置项 default_ttl（默认为 120 秒）过期保持时间 default_grace（默认为 10 秒）。该子程序一般用于模式选择，请求对象缓存及信息修改，后端节点修改，终止请求等操作</span><br></pre></td></tr></table></figure><p>可操作对象：（部分或全部值）</p><blockquote><p>读：client，server，req，storage</p><p>写：client，req</p></blockquote><p>返回值：</p><blockquote><p>synth(status code,reason); 定义响应内容</p><p>pass 进入 pass 模式，并进入 vcl_pass 子程序</p><p>pipe 进入 pipe 模式，并进入 vcl_pipe 子程序</p><p>hash 进入 hash 缓存模式，并进入 vcl_hash 子程序，默认返回值</p><p>purge 清除缓存等数据，子程序先从 vcl_hash 再到 vcl_purge</p></blockquote><h6 id=vcl-pipe-子程序><a class=header-anchor href=#vcl-pipe-子程序>¶</a>vcl_pipe 子程序</h6><figure class="highlight plain"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line>ipe 模式处理，该模式主要用于直接取后端响应内容返回客户端，可定义响应内容返回客户端。该子程序一般用于需要及时且不作处理的后端信息，取出后端响应内容后直接交付到客户端不进入 vcl_deliver 子程序处理</span><br></pre></td></tr></table></figure><p>可操作对象：（部分或全部值）</p><blockquote><p>读：client，server，bereq，req，storage</p><p>写：client，bereq，req</p></blockquote><p>返回值：</p><blockquote><p>synth(status code,reason); 定义响应内容</p><p>pipe 继续 pipe 模式，进入后端 vcl_backend_fetch 子程序，默认返回值</p></blockquote><h6 id=vcl-pass-子程序><a class=header-anchor href=#vcl-pass-子程序>¶</a>vcl_pass 子程序</h6><figure class="highlight plain"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line>pass 模式处理，该模式类似 hash 缓存模式，仅不做缓存处理</span><br></pre></td></tr></table></figure><blockquote><p>可操作对象：（部分或全部值）<br>读：client，server，req，storage</p><p>写：client，req</p><p>返回值：</p></blockquote><blockquote><p>synth(status code,reason); 定义响应内容</p><p>fetch 继续 pass 模式，进入后端 vcl_backend_fetch 子程序，默认返回值</p></blockquote><h6 id=vcl-hit-子程序><a class=header-anchor href=#vcl-hit-子程序>¶</a>vcl_hit 子程序</h6><figure class="highlight plain"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line>hash 缓存模式时，存在 hash 缓存时调用，用于缓存处理，可放弃或修改缓存</span><br></pre></td></tr></table></figure><p>可操作对象：（部分或全部值）</p><blockquote><p>读：client，server，obj，req，storage</p><p>写：client，req</p></blockquote><p>返回值：</p><blockquote><p>restart 重启请求</p><p>deliver 交付缓存内容，进入 vcl_deliver 子程序处理，默认返回值</p><p>synth(status code,reason); 定义响应内容</p></blockquote><h6 id=vcl-miss-子程序><a class=header-anchor href=#vcl-miss-子程序>¶</a>vcl_miss 子程序</h6><figure class="highlight tex"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line>hash 缓存模式时，不存在 hash 缓存时调用，用于判断性的选择进入后端取响应内容，可以修改为 pass 模式</span><br></pre></td></tr></table></figure><p>可操作对象：（部分或全部值）</p><blockquote><p>读：client，server，req，storage</p><p>写：client，req</p></blockquote><p>返回值：</p><blockquote><p>restart 重启请求</p><p>synth(status code,reason); 定义响应内容</p><p>pass 切换到 pass 模式，进入 vcl_pass 子程序</p><p>fetch 正常取后端内容再缓存，进入 vcl_backend_fetch 子程序，默认返回值</p></blockquote><h6 id=vcl-hash-子程序><a class=header-anchor href=#vcl-hash-子程序>¶</a>vcl_hash 子程序</h6><figure class="highlight plain"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line>hash缓存模式，生成hash值作为缓存查找键名提取缓存内容，主要用于缓存hash键值处理，可使用 hash_data(string) 指定键值组成结构，可在同一个页面通过 IP 或 cookie 生成不同的缓存键值</span><br></pre></td></tr></table></figure><p>可操作对象：（部分或全部值）</p><blockquote><p>读：client，server，req，storage</p><p>写：client，req</p></blockquote><p>返回值：</p><blockquote><p>lookup 查找缓存对象，存在缓存进入 vcl_hit 子程序，不存在缓存进入 vcl_miss 子程序，当使用了 purge 清理模式时会进入 vcl_purge 子程序，默认返回值</p></blockquote><h6 id=vcl-purge-子程序><a class=header-anchor href=#vcl-purge-子程序>¶</a>vcl_purge 子程序</h6><figure class="highlight plain"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line>清理模式，当查找到对应的缓存时清除并调用，用于请求方法清除缓存，并报告</span><br></pre></td></tr></table></figure><p>可操作对象：（部分或全部值）</p><blockquote><p>读：client，server，req，storage</p><p>写：client，req</p></blockquote><p>返回值：</p><blockquote><p>synth(status code,reason); 定义响应内容</p><p>restart 重启请求</p></blockquote><h6 id=vcl-deliver-子程序><a class=header-anchor href=#vcl-deliver-子程序>¶</a>vcl_deliver 子程序</h6><figure class="highlight plain"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line>客户端交付子程序，在 vcl_backend_response 子程序后调用（非 pipe 模式），或 vcl_hit 子程序后调用，可用于追加响应头信息，cookie 等内容</span><br></pre></td></tr></table></figure><p>可操作对象：（部分或全部值）</p><blockquote><p>读：client，server，req，resp，obj，storage</p><p>写：client，req，resp</p></blockquote><p>返回值：</p><blockquote><p>deliver 正常交付后端或缓存响应内容，默认返回值</p><p>restart 重启请求</p></blockquote><h6 id=vcl-backend-fetch-子程序><a class=header-anchor href=#vcl-backend-fetch-子程序>¶</a>vcl_backend_fetch 子程序</h6><figure class="highlight plain"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line>发送后端请求之前调用，可用于改变请求地址或其它信息，或放弃请求</span><br></pre></td></tr></table></figure><p>可操作对象：（部分或全部值）</p><blockquote><p>读：server，bereq，storage</p><p>写：bereq</p></blockquote><p>返回值：</p><blockquote><p>fetch 正常发送请求到到后端取出响应内容，进入 vcl_backend_response 子程序，默认返回值</p><p>abandon 放弃后端请求，并生成一个错误，进入 vcl_backend_error 子程序</p></blockquote><h6 id=vcl-backend-response-子程序><a class=header-anchor href=#vcl-backend-response-子程序>¶</a>vcl_backend_response 子程序</h6><figure class="highlight plain"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line>后端响应后调用，可用于修改缓存时间及缓存相关信息</span><br></pre></td></tr></table></figure><p>可操作对象：（部分或全部值）</p><blockquote><p>读：server，bereq，beresp，storage</p><p>写：bereq，beresp</p></blockquote><p>返回值：</p><blockquote><p>deliver 正常交付后端响应内容，进入 vcl_deliver 子程序，默认返回值</p><p>abandon 放弃后端请求，并生成一个错误，进入 vcl_backend_error 子程序</p><p>retry 重试后端请求，重试计数器加 1，当超过配置中 max_retries 值时会报错并进入vcl_backend_error 子程序</p></blockquote><h6 id=vcl-backend-error-子程序><a class=header-anchor href=#vcl-backend-error-子程序>¶</a>vcl_backend_error 子程序</h6><figure class="highlight plain"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line>后端处理失败调用，异常页面展示效果处理，可自定义错误响应内容，或修改 beresp.status与 beresp.http.Location 重定向等</span><br></pre></td></tr></table></figure><p>可操作对象：（部分或全部值）</p><blockquote><p>读：server，bereq，beresp，storage</p><p>写：bereq，beresp</p></blockquote><p>返回值：</p><blockquote><p>deliver 只交付 sysnthetic(string) 自定义内容，默认返回后端异常标准错误内容</p><p>retry 重试后端请求，重试计数器加 1，当超过配置中 max_retries 值时会报错并进入vcl_backend_error 子程序</p></blockquote><h6 id=vcl-synth-子程序><a class=header-anchor href=#vcl-synth-子程序>¶</a>vcl_synth 子程序</h6><figure class="highlight plain"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line>自定义响应内容。可以通过 synthetic（）和返回值 synth 调用，这里可以自定义异常显示内容，也可以修改 resp.status 与 resp.http.Location 重定向</span><br></pre></td></tr></table></figure><p>可操作对象：（部分或全部值）</p><blockquote><p>读：client，server，req，resp，storage</p><p>写：req，resp</p></blockquote><p>返回值：</p><blockquote><p>deliver 只交付 sysnthetic(string) 自定义内容，默认返回 sysnth 异常指定状态码与错误内容</p><p>restart 重启请求</p></blockquote><h6 id=vcl-init-子程序><a class=header-anchor href=#vcl-init-子程序>¶</a>vcl_init 子程序</h6><figure class="highlight plain"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line>加载 vcl 时最先调用，用于初始化 VMODs，该子程序不参与请求处理，仅在 vcl 加载时调用一次</span><br></pre></td></tr></table></figure><p>可操作对象：（部分或全部值）</p><blockquote><p>读：server</p><p>写：无</p></blockquote><p>返回值：</p><blockquote><p>ok 正常返回，进入 vcl_recv 子程序，默认返回值</p></blockquote><h6 id=vcl-fini-子程序><a class=header-anchor href=#vcl-fini-子程序>¶</a>vcl_fini 子程序</h6><figure class="highlight plain"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line>卸载当前 vcl 配置时调用，用于清理 VMODs，该子程序不参与请求处理，仅在 vcl 正常丢弃后调用</span><br></pre></td></tr></table></figure><p>可操作对象：（部分或全部值）</p><blockquote><p>读：server</p><p>写：无</p></blockquote><p>返回值：</p><blockquote><p>ok 正常返回，本次 vcl 将释放，默认返回值</p></blockquote><p>varnish 子程序调用流程图，通过大部分子程序的 return 返回值进入下一步行动：<br><img data-src="https://img-blog.csdnimg.cn/2020070118081672.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTYzNjcwMg==,size_16,color_FFFFFF,t_70"></p><h5 id=10、优雅模式（Garce-mode）><a class=header-anchor href=#10、优雅模式（Garce-mode）>¶</a>10、优雅模式（Garce mode）</h5><p>Varnish 中的请求合并</p><p>当几个客户端请求同一个页面的时候，varnish 只发送一个请求到后端服务器，然后让其他几个请求挂起并等待返回结果；获得结果后，其它请求再复制后端的结果发送给客户端；但如果同时有数以千计的请求，那么这个等待队列将变得庞大，这将导致 2 类潜在问题：</p><p>惊群问题(thundering herd problem)，即突然释放大量的线程去复制后端返回的结果，将导致负载急速上升；没有用户喜欢等待；</p><p>故为了解决这类问题，可以配置 varnish 在缓存对象因超时失效后再保留一段时间，以给那些等待的请求返回过去的文件内容(stale content)，配置案例如下：</p><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre></td><td class=code><pre><span class=line>sub vcl_recv &#123;</span><br><span class=line><span class=keyword>if</span> (! req.backend.healthy) &#123;</span><br><span class=line><span class=built_in>set</span> req.grace = 5m;</span><br><span class=line>&#125; <span class=keyword>else</span> &#123;</span><br><span class=line><span class=built_in>set</span> req.grace = 15s;</span><br><span class=line>&#125;</span><br><span class=line>&#125;</span><br><span class=line>sub vcl_fetch &#123;</span><br><span class=line><span class=built_in>set</span> beresp.grace = 30m;</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><p>以上配置表示 varnish 将会将失效的缓存对象再多保留 30 分钟，此值等于最大的 req.grace值即可</p><p>而根据后端主机的健康状况，varnish 可向前端请求分别提供 5 分钟内或 15 秒内的过期内容</p><h4 id=二、安装varnish><a class=header-anchor href=#二、安装varnish>¶</a>二、安装varnish</h4><h5 id=1、安装依赖关系的软件包><a class=header-anchor href=#1、安装依赖关系的软件包>¶</a>1、安装依赖关系的软件包</h5><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line>[root@varnish ~]<span class=comment># yum -y install autoconf automake libedit-devel libtool ncurses-devel pcre-devel pkgconfig python-docutils python-sphinx</span></span><br></pre></td></tr></table></figure><h5 id=2、安装-varnish><a class=header-anchor href=#2、安装-varnish>¶</a>2、安装 varnish</h5><p><a href=https://pan.baidu.com/s/1-wvFjYjz2W4c7H5XQgKyOQ target=_blank rel=noopener>安装包</a></p><p>提取码：h71d</p><p>varnish 的官方网址为 <a href=http://varnish-cache.org target=_blank rel=noopener>http://varnish-cache.org</a>，可以在这里下载最新版本的软件</p><p>注意：Varnish 网站有时会被墙</p><p>解压，进入解压目录编译安装：</p><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre></td><td class=code><pre><span class=line>[root@varinsh ~]<span class=comment># tar zxf varnish-4.0.3.tar.gz </span></span><br><span class=line>[root@varinsh ~]<span class=comment># cd varnish-4.0.3/</span></span><br><span class=line>[root@varinsh varnish-4.0.3]<span class=comment># export PKG_CONFIG_PATH=/usr/local/lib/pkgconfig</span></span><br><span class=line>[root@varinsh varnish-4.0.3]<span class=comment># ./configure &amp;&amp; make &amp;&amp; make install</span></span><br><span class=line><span class=comment># 不指定安装路径，默认是安装在/usr/local 目录下</span></span><br></pre></td></tr></table></figure><p>注：</p><blockquote><p>./autogen.sh<br>如果从 Git 库下载的安装包时才需要运行，用于生成 configure 编译文件</p></blockquote><p>复制 vcl 文件（在编译安装目录下），如果安装目录里没有 default.vcl 文件</p><p>复制到安装目录的/usr/local/var/varnish/目录下（当然并无必需要求在哪个目录，因为正式启动时还得指定这个文件的目录）</p><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line>[root@varinsh varnish-4.0.3]<span class=comment># cp etc/example.vcl /usr/local/var/varnish/default.vcl</span></span><br></pre></td></tr></table></figure><h4 id=三、varnish-实例解析><a class=header-anchor href=#三、varnish-实例解析>¶</a>三、varnish 实例解析</h4><figure class="highlight tex"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre></td><td class=code><pre><span class=line>varnish 配置基本上是编辑 VCL(Varnish Configuration Language) 文件,varnish 有一套自定义VCL 语法，启动时，会将配置文件编译为 C 语言，再执行</span><br><span class=line></span><br><span class=line>varnish 4.0 开始，每个 VCL 文件必须在开始行声明它的版本“vcl 4.0;”</span><br><span class=line></span><br><span class=line>块（子程序）由大括号分隔，语句用分号结束。所有的关键字及预设子程序名都是全小写。注释：支持 // 或 # 多行时还可以使用 /* .. */</span><br></pre></td></tr></table></figure><h5 id=1、后端服务器地址池配置及后端服务器健康检查><a class=header-anchor href=#1、后端服务器地址池配置及后端服务器健康检查>¶</a>1、后端服务器地址池配置及后端服务器健康检查</h5><p>varnish 有&quot;后端&quot;或者&quot;源&quot;服务器的概念。backend server 提供给 varnish 加速的内容。实际上就是给 varnish 添加可供访问的 web 服务器，如果有多台 web 服务器时，可添加多个 backend块</p><h6 id=1）后端服务器定义><a class=header-anchor href=#1）后端服务器定义>¶</a>1）后端服务器定义</h6><p>命令：backend。这个定义为最基本的反向入口定义，用于 varnish 连接对应的服务器，如果没有定义或定义错误则用户无法访问正常页面</p><p>语法格式：</p><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre></td><td class=code><pre><span class=line>backend name&#123;</span><br><span class=line>	.attribute = <span class=string>"value"</span>;</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><blockquote><p>backend 是定义后端关键字，name 是当前后端节点的别名，多个后端节点时，name 名不能重复，否则覆盖。花括号里面定义当前节点相关的属性（键=值）。除默认节点外其它节点定义后必需有调用，否则 varnish 无法启动。后端是否正常可以通过 std.healthy(backend)判断</p></blockquote><p>支持运算符：</p><blockquote><p>= （赋值运算）</p><p>== （相等比较）</p><p>~ （匹配，可以使用正则表达式，或访问控制列表）</p><p>!~ （不匹配，可以使用正则表达式，或访问控制列表）</p><p>！ （非）</p><p>&amp;&amp; （逻辑与）</p><p>|| （逻辑或）</p></blockquote><p>属性列表：</p><p>.host=“<a href=http://xxx.xxx.xxx.xxx target=_blank rel=noopener>xxx.xxx.xxx.xxx</a>”;</p><blockquote><p>要转向主机（即后端主机）的 IP 或域名，必填键/值对</p></blockquote><p>.port=“8080”;</p><blockquote><p>主机连接端口号或协议名（HTTP 等），默认 80</p></blockquote><p>.host_header=’’;</p><blockquote><p>请示主机头追加内容</p></blockquote><p>.connect_timeout=1s;</p><blockquote><p>连接后端的超时时间</p></blockquote><p>.first_byte_timeout=5s;</p><blockquote><p>等待从后端返回的第一个字节时间</p></blockquote><p>.between_bytes_timeout=2s;</p><blockquote><p>每接收一个字节之间等待时间</p></blockquote><p>.probe=probe_name;</p><blockquote><p>监控后端主机的状态,指定外部监控 name 或者内部直接添加</p></blockquote><p>.max_connections=200;</p><blockquote><p>设置最大并发连接数，超过这个数后连接就会失败</p></blockquote><p>例：（下面两个例子结果是一样的，但第二个例子中更适用于集群，可以方便批量修改）</p><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br></pre></td><td class=code><pre><span class=line>backend web&#123;</span><br><span class=line>	.host=<span class=string>"192.168.31.83"</span>;</span><br><span class=line>	.port=<span class=string>"80"</span>;</span><br><span class=line>	.probe=&#123; <span class=comment># 直接追加监控块.probe 是一个的参数</span></span><br><span class=line>		.url=<span class=string>"/"</span>;</span><br><span class=line>		.timeout=2s;</span><br><span class=line>	&#125;</span><br><span class=line>&#125;</span><br><span class=line>或</span><br><span class=line>probe web_probe&#123; <span class=comment># 监控必需定义在前面，否则后端调用找不到监控块。</span></span><br><span class=line>	.url=<span class=string>"/"</span>;</span><br><span class=line>	.timeout=2s;</span><br><span class=line>&#125;</span><br><span class=line>backend web&#123;</span><br><span class=line>	.host=<span class=string>"192.168.31.83"</span>;</span><br><span class=line>	.port=<span class=string>"80"</span>;</span><br><span class=line>	.probe=web_probe; //调用外部共用监控块</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><h6 id=2）监视器的定义><a class=header-anchor href=#2）监视器的定义>¶</a>2）监视器的定义</h6><p>命令：probe 。监控可以循环访问指定的地址，通过响应时间判定服务器是否空闲或正常。这类命令非常适用于集群中某些节点服务器崩溃或负载过重，而禁止访问这台节点服务器。</p><p>语法格式：</p><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre></td><td class=code><pre><span class=line>probe name&#123;</span><br><span class=line>	.attribute = <span class=string>"value"</span>;</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><blockquote><p>probe 是定义监控关键字，name 是当前监控点的别名，多个监控节点时，name 名不能重复，否则覆盖。花括号里面定义当前节点相关的属性（键=值）。没有必填属性，因为默认值就可以正常执行操作</p></blockquote><p>属性列表：</p><p>.url=&quot;/&quot;;</p><blockquote><p>指定监控入口 URL 地址，默认为&quot;/&quot;</p></blockquote><p>.request=&quot;&quot;;</p><blockquote><p>指定监控请求入口地址，比 .url 优先级高</p></blockquote><p>.expected_response=“200”;</p><blockquote><p>请求响应代码，默认是 200</p></blockquote><p>.timeout=2s;</p><blockquote><p>请求超时时间</p></blockquote><p>.interval=5s;</p><blockquote><p>每次轮询请求间隔时间,默认为 5s</p></blockquote><p>.initial=-1;</p><blockquote><p>初始启动时以.window 轮询次数中几次良好后续才能使用这个后端服务器节点，默认为 -1 ，则轮询完 .window 所有次数良好判定为正常</p></blockquote><p>.window=8;</p><blockquote><p>指定多少轮询次数，用于判定服务器正常，默认是 8</p></blockquote><p>.threshold=3;</p><blockquote><p>必须多少次轮询正常才算该后端节点服务器正常,默认是 3</p></blockquote><p>例：创建健康监测，定义健康检查名称为 backend_healthcheck</p><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre></td><td class=code><pre><span class=line>probe backend_healthcheck &#123;</span><br><span class=line>	.url = <span class=string>"/"</span>;</span><br><span class=line>	.timeout = 1s;</span><br><span class=line>	.interval = 5s;</span><br><span class=line>	.window = 5;</span><br><span class=line>	.threshold = 3;</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中 varnish 将每 5s 检测后端，超时设为 1s。每个检测将会发送 get /的请求。如果 5 个检测中大于 3 个是成功，varnish 就认为后端是健康的，反之，后端就有问题了</p><h6 id=3）集群负载均衡-directors：><a class=header-anchor href=#3）集群负载均衡-directors：>¶</a>3）集群负载均衡 directors：</h6><figure class="highlight tex"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre></td><td class=code><pre><span class=line>varnish 可以定义多个后端，也可以将几个后端放在一个后端集群里面已达到负载均衡的目的</span><br><span class=line></span><br><span class=line>你也可以将几个后端组成一组后端。这个组被叫做 Directors。可以提高性能和弹性</span><br></pre></td></tr></table></figure><p>directors 是 varnish 负载均衡模块，使用前必需引入 directors 模块，directors 模块主要包含：</p><p>round_robin，random，hash，fallback 负载均衡模式</p><blockquote><p>round_robin : 循环依次逐个选择后端服务器</p><p>random ： 随机选择后端服务器，可设置每个后端权重增加随机率</p><p>hash : 通过散列随机选择对应的后端服务器且保持选择对应关系，下次则直接找对应的后端服务器</p><p>Fallback：后备</p></blockquote><p>注意：</p><blockquote><p>random，hash 有权重值设置，用于提高随机率。每个后端最好都配置监控器（后端服务器正常监测）以便 directors 自动屏蔽不正常后端而不进入均衡列中。</p></blockquote><p>这些操作需要你载入 VMOD（varnish module），然后在 vcl_init 中调用这个 VMOD</p><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br></pre></td><td class=code><pre><span class=line>import directors; <span class=comment># load the directors</span></span><br><span class=line>backend web1 &#123;</span><br><span class=line>	.host = <span class=string>"192.168.0.10"</span>;</span><br><span class=line>	.port = <span class=string>"80"</span>;</span><br><span class=line>	.probe = backend_healthcheck;</span><br><span class=line>&#125;</span><br><span class=line>backend web2 &#123;</span><br><span class=line>	.host = <span class=string>"192.168.0.11"</span>;</span><br><span class=line>	.port = <span class=string>"80"</span>;</span><br><span class=line>	.probe = backend_healthcheck;</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=comment># 初始化处理</span></span><br><span class=line>sub vcl_init &#123; <span class=comment># 调用 vcl_init 初始化子程序创建后端主机组，即 directors</span></span><br><span class=line>	new web_cluster = directors.round_robin(); <span class=comment># 使用 new 关键字创建 drector 对象,使用 round_robin 算法</span></span><br><span class=line>	web_cluster.add_backend(web1); <span class=comment># 添加后端服务器节点</span></span><br><span class=line>	web_cluster.add_backend(web2);</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=comment># 开始处理请求</span></span><br><span class=line>sub vcl_recv &#123; <span class=comment># 调用 vcl_recv 子程序，用于接收和处理请求</span></span><br><span class=line>	<span class=built_in>set</span> req.backend_hint = web_cluster.backend(); <span class=comment># 选取后端</span></span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><blockquote><p>set 命令是设置变量</p><p>unset 命令是删除变量</p><p>web_cluster.add_backend( backend , real ); 添加后端服务器节点，backend 为后端配置别名，real 为权重值，随机率计算公式：100 * (当前权重 / 总权重)</p><p>req.backend_hint 是 varnish 的预定义变量，作用是指定请求后端节点</p><p>vcl 对象需要使用 new 关键字创建，所有可创建对象都是内定的，使用前必需 import，所有new 操作只能在 vcl_init 子程序中</p></blockquote><p>扩展：varnish 将不同的 url 发送到不同的后端 server</p><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br></pre></td><td class=code><pre><span class=line>import directors; <span class=comment># load the directors</span></span><br><span class=line>backend web1 &#123;</span><br><span class=line>	.host = <span class=string>"192.168.0.10"</span>;</span><br><span class=line>	.port = <span class=string>"80"</span>;</span><br><span class=line>	.probe = backend_healthcheck;</span><br><span class=line>&#125;</span><br><span class=line>backend web2 &#123;</span><br><span class=line>	.host = <span class=string>"192.168.0.11"</span>;</span><br><span class=line>	.port = <span class=string>"80"</span>;</span><br><span class=line>	.probe = backend_healthcheck;</span><br><span class=line>&#125;</span><br><span class=line>backend img1 &#123;</span><br><span class=line>	.host = <span class=string>"img1.lnmmp.com"</span>;</span><br><span class=line>	.port = <span class=string>"80"</span>;</span><br><span class=line>	.probe = backend_healthcheck;</span><br><span class=line>&#125;</span><br><span class=line>backend img2 &#123;</span><br><span class=line>	.host = <span class=string>"img2.lnmmp.com"</span>;</span><br><span class=line>	.port = <span class=string>"80"</span>;</span><br><span class=line>	.probe = backend_healthcheck;</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=comment># 初始化处理</span></span><br><span class=line>sub vcl_init &#123; <span class=comment># 调用 vcl_init 初始化子程序创建后端主机组，即 directors</span></span><br><span class=line>	new web_cluster = directors.round_robin(); <span class=comment># 使用 new 关键字创建 drector 对象,使用 round_robin 算法</span></span><br><span class=line>	web_cluster.add_backend(web1); <span class=comment># 添加后端服务器节点</span></span><br><span class=line>	web_cluster.add_backend(web2);</span><br><span class=line>	new img_cluster = directors.random();</span><br><span class=line>	img_cluster.add_backend(img1,2); <span class=comment># 添加后端服务器节点，并且设置权重值</span></span><br><span class=line>	img_cluster.add_backend(img2,5);</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=comment># 根据不同的访问域名，分发至不同的后端主机组</span></span><br><span class=line>sub vcl_recv &#123;</span><br><span class=line>	<span class=keyword>if</span> (req.http.host ~ <span class=string>"(?i)^(www.)?benet.com$"</span>) &#123;</span><br><span class=line>		<span class=built_in>set</span> req.http.host = <span class=string>"www.benet.com"</span>;</span><br><span class=line>		<span class=built_in>set</span> req.backend_hint = web_cluster.backend(); <span class=comment># 选取后端</span></span><br><span class=line>	&#125; elsif (req.http.host ~ <span class=string>"(?i)^images.benet.com$"</span>) &#123;</span><br><span class=line>		<span class=built_in>set</span> req.backend_hint = img_cluster.backend();</span><br><span class=line>	&#125;</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><p>说明：中的 i 就是忽略大小写的意思。(?i)表示开启忽略大小写，而(?-i)表示关闭忽略大小写</p><h6 id=4）访问控制列表（ACL）><a class=header-anchor href=#4）访问控制列表（ACL）>¶</a>4）访问控制列表（ACL）</h6><p>创建一个地址列表，用于后面的判断，可以是域名或 IP 集合。这个可以用于指定某些地址请求入口，防止恶意请求等</p><p>语法格式：</p><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre></td><td class=code><pre><span class=line>acl purgers &#123;</span><br><span class=line>	<span class=string>"127.0.0.1"</span>;</span><br><span class=line>	<span class=string>"localhost"</span>;</span><br><span class=line>	“192.168.134.0/24”</span><br><span class=line>	!<span class=string>"192.168.134.1"</span>;</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><p>说明：acl 是访问列表关键字（必需小写），name 是该列表的别名用于调用，花括号内部是地址集</p><p>注意：如果列表中包含了无法解析的主机地址，它会匹配任何地址</p><p>如果不想让它匹配可以在前添加一个 ! 符号，如上面 !“192.168.134.1”;</p><p>使用 ACL 只需要用 匹配运算符 ~ 或 !~ 如：</p><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre></td><td class=code><pre><span class=line>sub vcl_recv &#123;</span><br><span class=line>	<span class=keyword>if</span> (req.method == <span class=string>"PURGE"</span>) &#123; <span class=comment># PURGE 请求的处理</span></span><br><span class=line>		<span class=keyword>if</span> (client.ip ~ purgers) &#123;</span><br><span class=line>			<span class=built_in>return</span>(purge);</span><br><span class=line>		&#125; <span class=keyword>else</span> &#123;</span><br><span class=line>		  <span class=built_in>return</span>(synth(403, <span class=string>"Access denied."</span>));</span><br><span class=line>		&#125;</span><br><span class=line>	&#125;</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><h6 id=5）缓存规则配置><a class=header-anchor href=#5）缓存规则配置>¶</a>5）缓存规则配置</h6><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br></pre></td><td class=code><pre><span class=line>sub vcl_recv &#123;</span><br><span class=line>	<span class=comment># PURGE 请求的处理</span></span><br><span class=line>	<span class=keyword>if</span> (req.method == <span class=string>"PURGE"</span>) &#123;</span><br><span class=line>		<span class=keyword>if</span> (!client.ip ~ purgers) &#123;</span><br><span class=line>			<span class=built_in>return</span> (synth(405, <span class=string>"Not Allowed."</span>));</span><br><span class=line>		&#125;</span><br><span class=line>		<span class=built_in>return</span> (purge);</span><br><span class=line>	&#125;</span><br><span class=line></span><br><span class=line>	<span class=built_in>set</span> req.backend_hint = web.backend();</span><br><span class=line></span><br><span class=line>	<span class=comment># 将 php、asp 等动态内容访问请求直接发给后端服务器，不缓存。</span></span><br><span class=line>	<span class=keyword>if</span> (req.url ~ <span class=string>"\.(php|asp|aspx|jsp|do|ashx|shtml)($|\?)"</span>) &#123;</span><br><span class=line>		<span class=built_in>return</span> (pass);</span><br><span class=line>	&#125;</span><br><span class=line>	<span class=comment># 将非 GET 和 HEAD 访问请求直接发给后端服务器，不缓存。例如 POST 请求。</span></span><br><span class=line>	<span class=keyword>if</span> (req.method != <span class=string>"GET"</span> &amp;&amp; req.method != <span class=string>"HEAD"</span>) &#123;</span><br><span class=line>		<span class=built_in>return</span> (pass);</span><br><span class=line>	&#125;</span><br><span class=line>	<span class=comment># 如果 varnish 看到 header 中有'Authorization'头，它将 pass 请求。</span></span><br><span class=line>	<span class=keyword>if</span> (req.http.Authorization) &#123;</span><br><span class=line>		<span class=built_in>return</span> (pass);</span><br><span class=line>	&#125;</span><br><span class=line>	<span class=comment># 带 cookie 首部的 GET 请求也缓存</span></span><br><span class=line>	<span class=keyword>if</span> (req.url ~ <span class=string>"\.(css|js|html|htm|bmp|png|gif|jpg|jpeg|ico|gz|tgz|bz2|tbz|zip|rar|mp3|mp4|ogg|swf|flv)($|\?)"</span>) &#123;</span><br><span class=line></span><br><span class=line>		<span class=built_in>unset</span> req.http.cookie;</span><br><span class=line>		<span class=built_in>return</span> (<span class=built_in>hash</span>);</span><br><span class=line>	&#125;</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><p>说明：默认情况，varnish 不缓存从后端响应的 http 头中带有 Set-Cookie 的对象。如果客户<br>端发送的请求带有 Cookie header，varnish 将忽略缓存，直接将请求传递到后端</p><p>为发往后端主机的请求添加 X-Forward-For 首部,首次访问增加 X-Forwarded-For 头信息,方<br>便后端程序获取客户端 ip，而不是 varnish 地址</p><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>if</span> (req.restarts == 0) &#123;</span><br><span class=line>	<span class=keyword>if</span> (req.http.x-forwarded-for) &#123; <span class=comment># 如果设置过此 header 则要再次附加上用逗号隔开</span></span><br><span class=line>		<span class=built_in>set</span> req.http.X-Forwarded-For = req.http.X-Forwarded-For + <span class=string>", "</span> + client.ip;</span><br><span class=line>	&#125; <span class=keyword>else</span> &#123; <span class=comment># 如果只有一层代理的话,就无需设置了</span></span><br><span class=line>		<span class=built_in>set</span> req.http.X-Forwarded-For = client.ip;</span><br><span class=line>	&#125;</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><p>说明： X-Forwarded-For 是用来识别通过 HTTP 代理或负载均衡方式连接到 Web 服务器的客户<br>端最原始的 IP 地址的 HTTP 请求头字段</p><p>子程序：</p><p>子程序是一种类似 C 的函数，但是程序没有调用参数，子程序以 sub 关键字定义。在 VCL里子程序是用于管理程序</p><p>注意：所有 VCL 内置的程序都是以 vcl_ 开头，并已经预置好，在 VCL 文件中只要声明对应的内置子程序，都会在对应的流程中调用</p><h4 id=三、varnish-完整配置实例><a class=header-anchor href=#三、varnish-完整配置实例>¶</a>三、varnish 完整配置实例</h4><h5 id=1、拓扑环境><a class=header-anchor href=#1、拓扑环境>¶</a>1、拓扑环境</h5><table><thead><tr><th><strong>varnish</strong></th><th><strong>192.168.1.20</strong></th></tr></thead><tbody><tr><td><strong>web01</strong></td><td><strong>192.168.1.30</strong></td></tr><tr><td><strong>web02</strong></td><td><strong>192.168.1.40</strong></td></tr></tbody></table><p>配置 web01、web02 做为后端服务器（过程略）</p><p>确保 varnish 服务器能正常访问 web01、web02</p><p>Varnish 缓存代理服务器配置：</p><h5 id=2、vcl文件配置内容><a class=header-anchor href=#2、vcl文件配置内容>¶</a>2、vcl文件配置内容</h5><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br><span class=line>70</span><br><span class=line>71</span><br><span class=line>72</span><br><span class=line>73</span><br><span class=line>74</span><br><span class=line>75</span><br><span class=line>76</span><br><span class=line>77</span><br><span class=line>78</span><br><span class=line>79</span><br><span class=line>80</span><br><span class=line>81</span><br><span class=line>82</span><br><span class=line>83</span><br><span class=line>84</span><br><span class=line>85</span><br><span class=line>86</span><br><span class=line>87</span><br><span class=line>88</span><br><span class=line>89</span><br><span class=line>90</span><br><span class=line>91</span><br><span class=line>92</span><br><span class=line>93</span><br><span class=line>94</span><br><span class=line>95</span><br><span class=line>96</span><br><span class=line>97</span><br><span class=line>98</span><br><span class=line>99</span><br><span class=line>100</span><br><span class=line>101</span><br><span class=line>102</span><br><span class=line>103</span><br><span class=line>104</span><br><span class=line>105</span><br><span class=line>106</span><br><span class=line>107</span><br><span class=line>108</span><br><span class=line>109</span><br><span class=line>110</span><br><span class=line>111</span><br><span class=line>112</span><br><span class=line>113</span><br><span class=line>114</span><br><span class=line>115</span><br><span class=line>116</span><br><span class=line>117</span><br><span class=line>118</span><br><span class=line>119</span><br><span class=line>120</span><br><span class=line>121</span><br><span class=line>122</span><br><span class=line>123</span><br><span class=line>124</span><br><span class=line>125</span><br><span class=line>126</span><br><span class=line>127</span><br><span class=line>128</span><br><span class=line>129</span><br><span class=line>130</span><br><span class=line>131</span><br><span class=line>132</span><br><span class=line>133</span><br><span class=line>134</span><br><span class=line>135</span><br><span class=line>136</span><br><span class=line>137</span><br><span class=line>138</span><br><span class=line>139</span><br><span class=line>140</span><br><span class=line>141</span><br><span class=line>142</span><br><span class=line>143</span><br><span class=line>144</span><br><span class=line>145</span><br><span class=line>146</span><br><span class=line>147</span><br><span class=line>148</span><br><span class=line>149</span><br><span class=line>150</span><br><span class=line>151</span><br><span class=line>152</span><br><span class=line>153</span><br><span class=line>154</span><br><span class=line>155</span><br><span class=line>156</span><br><span class=line>157</span><br><span class=line>158</span><br><span class=line>159</span><br><span class=line>160</span><br><span class=line>161</span><br><span class=line>162</span><br><span class=line>163</span><br><span class=line>164</span><br></pre></td><td class=code><pre><span class=line>[root@varinsh ~]<span class=comment># cat /usr/local/var/varnish/default.vcl </span></span><br><span class=line>vcl 4.0;</span><br><span class=line>import directors;</span><br><span class=line>import std;</span><br><span class=line>probe  backend_healthcheck &#123;</span><br><span class=line>        .url = <span class=string>"/"</span>;</span><br><span class=line>        .timeout = 1s;</span><br><span class=line>        .interval = 5s;</span><br><span class=line>        .window = 5;</span><br><span class=line>        .threshold = 3;</span><br><span class=line>&#125;</span><br><span class=line>backend web1 &#123;</span><br><span class=line>    .host = <span class=string>"192.168.1.30"</span>;</span><br><span class=line>    .port = <span class=string>"80"</span>;</span><br><span class=line>    .probe = backend_healthcheck;</span><br><span class=line>&#125;</span><br><span class=line>backend web2 &#123;</span><br><span class=line>    .host = <span class=string>"192.168.1.40"</span>;</span><br><span class=line>    .port = <span class=string>"80"</span>;</span><br><span class=line>    .probe = backend_healthcheck;</span><br><span class=line>&#125;</span><br><span class=line>acl purgers &#123;</span><br><span class=line>        <span class=string>"127.0.0.1"</span>;</span><br><span class=line>        <span class=string>"localhost"</span>;</span><br><span class=line>        <span class=string>"192.168.1.0/24"</span>;</span><br><span class=line>        !<span class=string>"192.168.1.40"</span>;</span><br><span class=line>&#125;</span><br><span class=line>sub vcl_init &#123;  </span><br><span class=line>        new web_cluster = directors.round_robin();  </span><br><span class=line>        web_cluster.add_backend(web1);  </span><br><span class=line>        web_cluster.add_backend(web2);</span><br><span class=line>&#125;</span><br><span class=line>sub vcl_recv &#123;</span><br><span class=line>        <span class=built_in>set</span> req.backend_hint = web_cluster.backend();</span><br><span class=line>        <span class=keyword>if</span> (req.method == <span class=string>"PURGE"</span>) &#123;    </span><br><span class=line>                <span class=keyword>if</span> (!client.ip ~ purgers) &#123;   </span><br><span class=line>                        <span class=built_in>return</span> (synth(405, <span class=string>"Not Allowed."</span>));   </span><br><span class=line>                &#125;</span><br><span class=line>                <span class=built_in>return</span> (purge);</span><br><span class=line> 	&#125;</span><br><span class=line>        <span class=keyword>if</span> (req.method != <span class=string>"GET"</span> &amp;&amp; </span><br><span class=line>                req.method != <span class=string>"HEAD"</span> &amp;&amp;</span><br><span class=line>                req.method != <span class=string>"PUT"</span> &amp;&amp;</span><br><span class=line>                req.method != <span class=string>"POST"</span> &amp;&amp;</span><br><span class=line>                req.method != <span class=string>"TRACE"</span> &amp;&amp;</span><br><span class=line>                req.method != <span class=string>"OPTIONS"</span> &amp;&amp;</span><br><span class=line>                req.method != <span class=string>"PATCH"</span> &amp;&amp;</span><br><span class=line>                req.method != <span class=string>"DELETE"</span>) &#123;</span><br><span class=line>                        <span class=built_in>return</span> (pipe);</span><br><span class=line>                &#125;</span><br><span class=line>        <span class=keyword>if</span> (req.method != <span class=string>"GET"</span> &amp;&amp; req.method != <span class=string>"HEAD"</span>)&#123;</span><br><span class=line>                <span class=built_in>return</span> (pass);  </span><br><span class=line></span><br><span class=line>        &#125;</span><br><span class=line>        <span class=keyword>if</span> (req.url ~ <span class=string>"\.(php|asp|aspx|jsp|do|ashx|shtml)($|\?)"</span>)&#123;</span><br><span class=line>                <span class=built_in>return</span> (pass);   </span><br><span class=line>        &#125;</span><br><span class=line>        <span class=keyword>if</span> (req.http.Authorization) &#123;</span><br><span class=line>                <span class=built_in>return</span> (pass);    </span><br><span class=line>        &#125;</span><br><span class=line>        <span class=keyword>if</span> (req.http.Accept-Encoding) &#123;</span><br><span class=line>                <span class=keyword>if</span>  (req.url  ~ <span class=string>"\.(bmp|png|gif|jpg|jpeg|ico|gz|tgz|bz2|tbz|zip|rar|mp3|mp4|ogg|swf|flv)$"</span></span><br><span class=line>)&#123;</span><br><span class=line>                        <span class=built_in>unset</span> req.http.Accept-Encoding; </span><br><span class=line>                &#125; elseif (req.http.Accept-Encoding ~ <span class=string>"gzip"</span>) &#123;</span><br><span class=line>                        <span class=built_in>set</span> req.http.Accept-Encoding = <span class=string>"gzip"</span>; </span><br><span class=line>                &#125; elseif (req.http.Accept-Encoding ~ <span class=string>"deflate"</span>) &#123;</span><br><span class=line>                        <span class=built_in>set</span> req.http.Accept-Encoding = <span class=string>"deflate"</span>;</span><br><span class=line>                &#125; <span class=keyword>else</span> &#123;</span><br><span class=line>                        <span class=built_in>unset</span> req.http.Accept-Encoding; </span><br><span class=line>                &#125;</span><br><span class=line>        &#125;</span><br><span class=line>       		    <span class=keyword>if</span>  (req.url  ~ <span class=string>"\.(css|js|html|htm|bmp|png|gif|jpg|jpeg|ico|gz|tgz|bz2|tbz|zip|rar|mp3|mp4|ogg|sw f|flv)($|\?)"</span>) &#123;</span><br><span class=line>                <span class=built_in>unset</span> req.http.cookie; </span><br><span class=line>                <span class=built_in>return</span> (<span class=built_in>hash</span>); </span><br><span class=line>        &#125;</span><br><span class=line>        <span class=keyword>if</span> (req.restarts == 0) &#123; </span><br><span class=line>                <span class=keyword>if</span> (req.http.X-Forwarded-For) &#123; </span><br><span class=line>                        <span class=built_in>set</span> req.http.X-Forwarded-For = req.http.X-Forwarded-For + <span class=string>", "</span> + client.ip;</span><br><span class=line>                &#125; <span class=keyword>else</span> &#123;</span><br><span class=line>                        <span class=built_in>set</span> req.http.X-Forwarded-For = client.ip;</span><br><span class=line>                &#125;</span><br><span class=line>        &#125;</span><br><span class=line>        <span class=built_in>return</span> (<span class=built_in>hash</span>);</span><br><span class=line>&#125;</span><br><span class=line>sub vcl_hash &#123;</span><br><span class=line>        hash_data(req.url); </span><br><span class=line>        <span class=keyword>if</span> (req.http.host) &#123;</span><br><span class=line>        hash_data(req.http.host); </span><br><span class=line>        &#125; <span class=keyword>else</span> &#123;</span><br><span class=line>        hash_data(server.ip); </span><br><span class=line>        &#125;</span><br><span class=line>        <span class=built_in>return</span> (lookup);</span><br><span class=line>&#125;</span><br><span class=line>sub vcl_hit &#123;</span><br><span class=line>        <span class=keyword>if</span> (req.method == <span class=string>"PURGE"</span>) &#123; </span><br><span class=line>        <span class=built_in>return</span> (synth(200, <span class=string>"Purged."</span>));</span><br><span class=line>        &#125;</span><br><span class=line>        <span class=built_in>return</span> (deliver);</span><br><span class=line>&#125;</span><br><span class=line>sub vcl_miss &#123;</span><br><span class=line>        <span class=keyword>if</span> (req.method == <span class=string>"PURGE"</span>) &#123;</span><br><span class=line>        <span class=built_in>return</span> (synth(404, <span class=string>"Purged."</span>)); </span><br><span class=line>        &#125;</span><br><span class=line>        <span class=built_in>return</span> (fetch);</span><br><span class=line>&#125;</span><br><span class=line>sub vcl_deliver &#123;</span><br><span class=line>        <span class=keyword>if</span> (obj.hits &gt; 0) &#123;</span><br><span class=line>        <span class=built_in>set</span> resp.http.X-Cache = <span class=string>"HIT"</span>; </span><br><span class=line>        <span class=built_in>set</span> resp.http.X-Cache-Hits = obj.hits; </span><br><span class=line>        &#125; <span class=keyword>else</span> &#123;</span><br><span class=line>                <span class=built_in>set</span> resp.http.X-Cache = <span class=string>"MISS"</span>;</span><br><span class=line>        &#125;</span><br><span class=line>        <span class=built_in>unset</span> resp.http.X-Powered-By; </span><br><span class=line>        <span class=built_in>unset</span> resp.http.Server; </span><br><span class=line>        <span class=built_in>unset</span> resp.http.X-Drupal-Cache; </span><br><span class=line>        <span class=built_in>unset</span> resp.http.Via; </span><br><span class=line>        <span class=built_in>unset</span> resp.http.Link; </span><br><span class=line>        <span class=built_in>unset</span> resp.http.X-Varnish; </span><br><span class=line>        <span class=built_in>set</span> resp.http.xx_restarts_count = req.restarts; </span><br><span class=line>        <span class=built_in>set</span> resp.http.xx_Age = resp.http.Age; </span><br><span class=line>        <span class=built_in>set</span> resp.http.hit_count = obj.hits; </span><br><span class=line>        <span class=built_in>unset</span> resp.http.Age;</span><br><span class=line>        <span class=built_in>return</span> (deliver);</span><br><span class=line>&#125;</span><br><span class=line>sub vcl_pass &#123;</span><br><span class=line>        <span class=built_in>return</span> (fetch); </span><br><span class=line>&#125;</span><br><span class=line>sub vcl_backend_response &#123;</span><br><span class=line>        <span class=built_in>set</span> beresp.grace = 5m; </span><br><span class=line>        <span class=keyword>if</span> (beresp.status == 499 || beresp.status == 404 || beresp.status == 502) &#123;</span><br><span class=line>                <span class=built_in>set</span> beresp.uncacheable = <span class=literal>true</span>; </span><br><span class=line>        &#125;</span><br><span class=line>        <span class=keyword>if</span> (bereq.url ~ <span class=string>"\.(php|jsp)(\?|$)"</span>) &#123;</span><br><span class=line>                <span class=built_in>set</span> beresp.uncacheable = <span class=literal>true</span>; </span><br><span class=line>        &#125; <span class=keyword>else</span> &#123;</span><br><span class=line>                <span class=keyword>if</span> (bereq.url ~ <span class=string>"\.(css|js|html|htm|bmp|png|gif|jpg|jpeg|ico)($|\?)"</span>) &#123;</span><br><span class=line>                <span class=built_in>set</span> beresp.ttl = 15m; </span><br><span class=line>                <span class=built_in>unset</span> beresp.http.Set-Cookie;</span><br><span class=line>                &#125; elseif (bereq.url ~ <span class=string>"\.(gz|tgz|bz2|tbz|zip|rar|mp3|mp4|ogg|swf|flv)($|\?)"</span>) &#123;</span><br><span class=line>                        <span class=built_in>set</span> beresp.ttl = 30m; </span><br><span class=line>                        <span class=built_in>unset</span> beresp.http.Set-Cookie;</span><br><span class=line>                &#125; <span class=keyword>else</span> &#123;</span><br><span class=line>                        <span class=built_in>set</span> beresp.ttl = 10m; </span><br><span class=line>                        <span class=built_in>unset</span> beresp.http.Set-Cookie;</span><br><span class=line>                &#125;</span><br><span class=line>        &#125;</span><br><span class=line>        <span class=built_in>return</span> (deliver);</span><br><span class=line>&#125;</span><br><span class=line>sub vcl_purge &#123;</span><br><span class=line>        <span class=built_in>return</span> (synth(200,<span class=string>"success"</span>));</span><br><span class=line>&#125;</span><br><span class=line>sub vcl_backend_error &#123;</span><br><span class=line>        <span class=keyword>if</span> (beresp.status == 500 ||</span><br><span class=line>                beresp.status == 501 ||</span><br><span class=line>                beresp.status == 502 ||</span><br><span class=line>                beresp.status == 503 ||</span><br><span class=line>                beresp.status == 504) &#123;</span><br><span class=line>                <span class=built_in>return</span> (retry); </span><br><span class=line>        &#125;</span><br><span class=line>&#125;</span><br><span class=line>sub vcl_fini &#123;</span><br><span class=line>        <span class=built_in>return</span> (ok);</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><h5 id=3、启动varnish><a class=header-anchor href=#3、启动varnish>¶</a>3、启动varnish</h5><p>当启动 varnish 时有两个重要的参数你必须设置: 一个是处理 http 请求的 tcp 监听端口,另一个是处理真实请求的后端 server</p><p>注：如果你使用操作系统自带的包管理工具安装的 varnish,你将在下面的文件找到启动参数:Red Hat, Centos: /etc/sysconfig/varnish</p><h6 id=1）’-a’><a class=header-anchor href=#1）’-a’>¶</a>1）’-a’</h6><p>‘-a’ 参数定义了 varnish 监听在哪个地址,并用该地址处理 http 请求，你可能想设置这个参数在众所周知的 http 80 端口</p><p>例子:</p><blockquote><p>-a :80<br>-a localhost:80<br>-a 192.168.1.100:8080<br>-a ‘[fe80::1]:80’<br>-a ‘0.0.0.0:8080,[::]:8081’</p></blockquote><p>如果你的 webserver 和 varnish 运行在同一台机器,你必须换一个监听地址</p><h6 id=2）’-f’><a class=header-anchor href=#2）’-f’>¶</a>2）’-f’</h6><blockquote><p>-f 添加 vcl 文件,-b 定义后端 serve</p><p>varnish 需要知道从哪里找到这个需要缓存的 http server.你可以用-b 参数指定,或者帮把它放在 vcl 文件中,然后使用-f 参数指定</p><p>在启动的时候使用-b 是一个快捷的方式.</p><p>-b 192.168.1.2:80</p><p>注意:如果你指定的是 name,这个 name 必须能解析成一个 IPv4 或者 IPv6 的地址如果你使用-f 参数,你启动的时候可以在-f 指定 vcl 文件</p><p>默认的 varnish 使用 100M 的内存来缓存对象,如果你想缓存更多,可以使用-s 参数</p></blockquote><p>注：Varnish 拥有大量的有用的命令行参数，建议查看其帮助</p><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line>[root@varinsh ~]<span class=comment># /usr/local/sbin/varnishd -h</span></span><br></pre></td></tr></table></figure><p>启动 varnish</p><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre></td><td class=code><pre><span class=line>[root@varinsh ~]<span class=comment># varnishd -f /usr/local/var/varnish/default.vcl -s malloc,200M -a 0.0.0.0:80[root@varinsh ~]# netstat -anput | grep 80</span></span><br><span class=line>tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      13968/varnishd</span><br></pre></td></tr></table></figure><h6 id=3）访问><a class=header-anchor href=#3）访问>¶</a>3）访问</h6><p>现在，varnish 已经启动和运行，你可以通过 varnish 访问您的 Web 应用程序</p><p>第一次访问<br><img data-src="https://img-blog.csdnimg.cn/20200701180906611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTYzNjcwMg==,size_16,color_FFFFFF,t_70"></p><p>第二次访问<br><img data-src="https://img-blog.csdnimg.cn/20200701180924925.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTYzNjcwMg==,size_16,color_FFFFFF,t_70"></p><h6 id=4）清除缓存再次访问><a class=header-anchor href=#4）清除缓存再次访问>¶</a>4）清除缓存再次访问</h6><p><img data-src="https://img-blog.csdnimg.cn/20200701181019348.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTYzNjcwMg==,size_16,color_FFFFFF,t_70"></p></div><div><ul class=post-copyright><li class=post-copyright-author><strong>本文作者：</strong>Maisy</li><li class=post-copyright-link><strong>本文链接：</strong> <a href=https://pdxblog.top/Varnish4.0%E7%BC%93%E5%AD%98%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE.html title=Varnish4.0缓存代理配置>https://pdxblog.top/Varnish4.0缓存代理配置.html</a></li><li class=post-copyright-license><strong>版权声明：</strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel=noopener target=_blank><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class=post-footer><div class=post-tags><a href="/tags/%E6%9E%B6%E6%9E%84/" rel=tag># 架构</a></div><div class=post-nav><div class=post-nav-item><a href=/Nginx%E4%BC%98%E5%8C%96%E4%B8%8E%E9%98%B2%E7%9B%97%E9%93%BE+%E5%8D%95%E6%9C%BA%E9%83%A8%E7%BD%B2LNMP.html rel=prev title=Nginx优化与防盗链+单机部署LNMP><i class="fa fa-chevron-left"></i> Nginx优化与防盗链+单机部署LNMP</a></div><div class=post-nav-item><a href=/mysql%E8%87%AA%E5%B8%A6%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D.html rel=next title=MySQL自带工具使用介绍>MySQL自带工具使用介绍 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class=sidebar><div class=sidebar-inner><ul class="sidebar-nav motion-element"><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class=nav><li class="nav-item nav-level-3"><a class=nav-link href=#Varnish4-0缓存代理配置><span class=nav-number>1.</span> <span class=nav-text>¶Varnish4.0缓存代理配置</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#一、Varnish原理><span class=nav-number>1.1.</span> <span class=nav-text>¶一、Varnish原理</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#1、Varnish简介><span class=nav-number>1.1.1.</span> <span class=nav-text>¶1、Varnish简介</span></a></li><li class="nav-item nav-level-5"><a class=nav-link href=#2、Varnish-与-与-Squid-的对比><span class=nav-number>1.1.2.</span> <span class=nav-text>¶2、Varnish 与 与 Squid 的对比</span></a><ol class=nav-child><li class="nav-item nav-level-6"><a class=nav-link href=#Varnish-的优势：><span class=nav-number>1.1.2.1.</span> <span class=nav-text>¶Varnish 的优势：</span></a></li><li class="nav-item nav-level-6"><a class=nav-link href=#Varnish-的劣势：><span class=nav-number>1.1.2.2.</span> <span class=nav-text>¶Varnish 的劣势：</span></a></li><li class="nav-item nav-level-6"><a class=nav-link href=#Varnish-劣势的解决方案><span class=nav-number>1.1.2.3.</span> <span class=nav-text>¶Varnish 劣势的解决方案</span></a></li></ol></li><li class="nav-item nav-level-5"><a class=nav-link href=#3、使用-varnish-作为-web-代理缓存的原理><span class=nav-number>1.1.3.</span> <span class=nav-text>¶3、使用 varnish 作为 web 代理缓存的原理</span></a></li><li class="nav-item nav-level-5"><a class=nav-link href=#4、-简单架构><span class=nav-number>1.1.4.</span> <span class=nav-text>¶4、 简单架构</span></a><ol class=nav-child><li class="nav-item nav-level-6"><a class=nav-link href=#Management-进程：><span class=nav-number>1.1.4.1.</span> <span class=nav-text>¶Management 进程：</span></a></li><li class="nav-item nav-level-6"><a class=nav-link href=#Child-进程：><span class=nav-number>1.1.4.2.</span> <span class=nav-text>¶Child 进程：</span></a></li></ol></li><li class="nav-item nav-level-5"><a class=nav-link href=#5、varnish-主要配置部分><span class=nav-number>1.1.5.</span> <span class=nav-text>¶5、varnish 主要配置部分</span></a><ol class=nav-child><li class="nav-item nav-level-6"><a class=nav-link href=#后端配置：><span class=nav-number>1.1.5.1.</span> <span class=nav-text>¶后端配置：</span></a></li><li class="nav-item nav-level-6"><a class=nav-link href=#ACL-配置：><span class=nav-number>1.1.5.2.</span> <span class=nav-text>¶ACL 配置：</span></a></li><li class="nav-item nav-level-6"><a class=nav-link href=#probes-配置：><span class=nav-number>1.1.5.3.</span> <span class=nav-text>¶probes 配置：</span></a></li><li class="nav-item nav-level-6"><a class=nav-link href=#directors-配置：><span class=nav-number>1.1.5.4.</span> <span class=nav-text>¶directors 配置：</span></a></li><li class="nav-item nav-level-6"><a class=nav-link href=#核心子程序配置：><span class=nav-number>1.1.5.5.</span> <span class=nav-text>¶核心子程序配置：</span></a></li></ol></li><li class="nav-item nav-level-5"><a class=nav-link href=#6、VCL-中内置-预设变量：-变量-也叫-object-）><span class=nav-number>1.1.6.</span> <span class=nav-text>¶6、VCL 中内置 预设变量： 变量( 也叫 object ）</span></a><ol class=nav-child><li class="nav-item nav-level-6"><a class=nav-link href=#now-作用：返回当前时间戳><span class=nav-number>1.1.6.1.</span> <span class=nav-text>¶now 作用：返回当前时间戳</span></a></li><li class="nav-item nav-level-6"><a class=nav-link href=#客户端：（客户端基本信息）><span class=nav-number>1.1.6.2.</span> <span class=nav-text>¶客户端：（客户端基本信息）</span></a></li><li class="nav-item nav-level-6"><a class=nav-link href=#服务器：（服务器基本信息）><span class=nav-number>1.1.6.3.</span> <span class=nav-text>¶服务器：（服务器基本信息）</span></a></li><li class="nav-item nav-level-6"><a class=nav-link href=#req-（客户端发送的请求对象）><span class=nav-number>1.1.6.4.</span> <span class=nav-text>¶req :（客户端发送的请求对象）</span></a></li><li class="nav-item nav-level-6"><a class=nav-link href=#bereq：（发送到后端的请求对象，基于-req-对象）><span class=nav-number>1.1.6.5.</span> <span class=nav-text>¶bereq：（发送到后端的请求对象，基于 req 对象）</span></a></li><li class="nav-item nav-level-6"><a class=nav-link href=#beresp：（后端响应请求对象）><span class=nav-number>1.1.6.6.</span> <span class=nav-text>¶beresp：（后端响应请求对象）</span></a></li><li class="nav-item nav-level-6"><a class=nav-link href=#OBJ-：（高速缓存对象，缓存后端响应请求内容）><span class=nav-number>1.1.6.7.</span> <span class=nav-text>¶OBJ ：（高速缓存对象，缓存后端响应请求内容）</span></a></li><li class="nav-item nav-level-6"><a class=nav-link href=#resp-（返回给客户端的响应对象）><span class=nav-number>1.1.6.8.</span> <span class=nav-text>¶resp :（返回给客户端的响应对象）</span></a></li><li class="nav-item nav-level-6"><a class=nav-link href=#存储-：><span class=nav-number>1.1.6.9.</span> <span class=nav-text>¶存储 ：</span></a></li></ol></li><li class="nav-item nav-level-5"><a class=nav-link href=#7、特定功能性语句><span class=nav-number>1.1.7.</span> <span class=nav-text>¶7、特定功能性语句</span></a></li><li class="nav-item nav-level-5"><a class=nav-link href=#8、return语句><span class=nav-number>1.1.8.</span> <span class=nav-text>¶8、return语句</span></a></li><li class="nav-item nav-level-5"><a class=nav-link href=#9、varnish-中内置子程序><span class=nav-number>1.1.9.</span> <span class=nav-text>¶9、varnish 中内置子程序</span></a><ol class=nav-child><li class="nav-item nav-level-6"><a class=nav-link href=#vcl-recv-子程序><span class=nav-number>1.1.9.1.</span> <span class=nav-text>¶vcl_recv 子程序</span></a></li><li class="nav-item nav-level-6"><a class=nav-link href=#vcl-pipe-子程序><span class=nav-number>1.1.9.2.</span> <span class=nav-text>¶vcl_pipe 子程序</span></a></li><li class="nav-item nav-level-6"><a class=nav-link href=#vcl-pass-子程序><span class=nav-number>1.1.9.3.</span> <span class=nav-text>¶vcl_pass 子程序</span></a></li><li class="nav-item nav-level-6"><a class=nav-link href=#vcl-hit-子程序><span class=nav-number>1.1.9.4.</span> <span class=nav-text>¶vcl_hit 子程序</span></a></li><li class="nav-item nav-level-6"><a class=nav-link href=#vcl-miss-子程序><span class=nav-number>1.1.9.5.</span> <span class=nav-text>¶vcl_miss 子程序</span></a></li><li class="nav-item nav-level-6"><a class=nav-link href=#vcl-hash-子程序><span class=nav-number>1.1.9.6.</span> <span class=nav-text>¶vcl_hash 子程序</span></a></li><li class="nav-item nav-level-6"><a class=nav-link href=#vcl-purge-子程序><span class=nav-number>1.1.9.7.</span> <span class=nav-text>¶vcl_purge 子程序</span></a></li><li class="nav-item nav-level-6"><a class=nav-link href=#vcl-deliver-子程序><span class=nav-number>1.1.9.8.</span> <span class=nav-text>¶vcl_deliver 子程序</span></a></li><li class="nav-item nav-level-6"><a class=nav-link href=#vcl-backend-fetch-子程序><span class=nav-number>1.1.9.9.</span> <span class=nav-text>¶vcl_backend_fetch 子程序</span></a></li><li class="nav-item nav-level-6"><a class=nav-link href=#vcl-backend-response-子程序><span class=nav-number>1.1.9.10.</span> <span class=nav-text>¶vcl_backend_response 子程序</span></a></li><li class="nav-item nav-level-6"><a class=nav-link href=#vcl-backend-error-子程序><span class=nav-number>1.1.9.11.</span> <span class=nav-text>¶vcl_backend_error 子程序</span></a></li><li class="nav-item nav-level-6"><a class=nav-link href=#vcl-synth-子程序><span class=nav-number>1.1.9.12.</span> <span class=nav-text>¶vcl_synth 子程序</span></a></li><li class="nav-item nav-level-6"><a class=nav-link href=#vcl-init-子程序><span class=nav-number>1.1.9.13.</span> <span class=nav-text>¶vcl_init 子程序</span></a></li><li class="nav-item nav-level-6"><a class=nav-link href=#vcl-fini-子程序><span class=nav-number>1.1.9.14.</span> <span class=nav-text>¶vcl_fini 子程序</span></a></li></ol></li><li class="nav-item nav-level-5"><a class=nav-link href=#10、优雅模式（Garce-mode）><span class=nav-number>1.1.10.</span> <span class=nav-text>¶10、优雅模式（Garce mode）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class=nav-link href=#二、安装varnish><span class=nav-number>1.2.</span> <span class=nav-text>¶二、安装varnish</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#1、安装依赖关系的软件包><span class=nav-number>1.2.1.</span> <span class=nav-text>¶1、安装依赖关系的软件包</span></a></li><li class="nav-item nav-level-5"><a class=nav-link href=#2、安装-varnish><span class=nav-number>1.2.2.</span> <span class=nav-text>¶2、安装 varnish</span></a></li></ol></li><li class="nav-item nav-level-4"><a class=nav-link href=#三、varnish-实例解析><span class=nav-number>1.3.</span> <span class=nav-text>¶三、varnish 实例解析</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#1、后端服务器地址池配置及后端服务器健康检查><span class=nav-number>1.3.1.</span> <span class=nav-text>¶1、后端服务器地址池配置及后端服务器健康检查</span></a><ol class=nav-child><li class="nav-item nav-level-6"><a class=nav-link href=#1）后端服务器定义><span class=nav-number>1.3.1.1.</span> <span class=nav-text>¶1）后端服务器定义</span></a></li><li class="nav-item nav-level-6"><a class=nav-link href=#2）监视器的定义><span class=nav-number>1.3.1.2.</span> <span class=nav-text>¶2）监视器的定义</span></a></li><li class="nav-item nav-level-6"><a class=nav-link href=#3）集群负载均衡-directors：><span class=nav-number>1.3.1.3.</span> <span class=nav-text>¶3）集群负载均衡 directors：</span></a></li><li class="nav-item nav-level-6"><a class=nav-link href=#4）访问控制列表（ACL）><span class=nav-number>1.3.1.4.</span> <span class=nav-text>¶4）访问控制列表（ACL）</span></a></li><li class="nav-item nav-level-6"><a class=nav-link href=#5）缓存规则配置><span class=nav-number>1.3.1.5.</span> <span class=nav-text>¶5）缓存规则配置</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class=nav-link href=#三、varnish-完整配置实例><span class=nav-number>1.4.</span> <span class=nav-text>¶三、varnish 完整配置实例</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#1、拓扑环境><span class=nav-number>1.4.1.</span> <span class=nav-text>¶1、拓扑环境</span></a></li><li class="nav-item nav-level-5"><a class=nav-link href=#2、vcl文件配置内容><span class=nav-number>1.4.2.</span> <span class=nav-text>¶2、vcl文件配置内容</span></a></li><li class="nav-item nav-level-5"><a class=nav-link href=#3、启动varnish><span class=nav-number>1.4.3.</span> <span class=nav-text>¶3、启动varnish</span></a><ol class=nav-child><li class="nav-item nav-level-6"><a class=nav-link href=#1）’-a’><span class=nav-number>1.4.3.1.</span> <span class=nav-text>¶1）’-a’</span></a></li><li class="nav-item nav-level-6"><a class=nav-link href=#2）’-f’><span class=nav-number>1.4.3.2.</span> <span class=nav-text>¶2）’-f’</span></a></li><li class="nav-item nav-level-6"><a class=nav-link href=#3）访问><span class=nav-number>1.4.3.3.</span> <span class=nav-text>¶3）访问</span></a></li><li class="nav-item nav-level-6"><a class=nav-link href=#4）清除缓存再次访问><span class=nav-number>1.4.3.4.</span> <span class=nav-text>¶4）清除缓存再次访问</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=Maisy src=/images/author.jpg><p class=site-author-name itemprop=name>Maisy</p><div class=site-description itemprop=description>人的一生就是一个储蓄的过程，在奋斗的时候储存了希望；在耕耘的时候储存了一粒种子；在旅行的时候储存了风景；在微笑的时候储存了快乐。聪明的人善于储蓄，在漫长而短暂的人生旅途中，学会储蓄每一个闪光的瞬间，然后用它们酿成一杯美好的回忆，在四季的变幻与交替之间，散发浓香，珍藏一生</div></div><div class="site-state-wrap motion-element"><nav class=site-state><div class="site-state-item site-state-posts"><a href="/archives/"><span class=site-state-item-count>69</span> <span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class=site-state-item-count>7</span> <span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class=site-state-item-count>7</span> <span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class=links-of-author-item><a href=https://github.com/Gilbert2/Gilbert2.github.io title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Gilbert2&#x2F;Gilbert2.github.io" rel=noopener target=_blank><i class="fab fa-github fa-fw"></i>GitHub</a></span> <span class=links-of-author-item><a href=https://blog.csdn.net/weixin_45636702 title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_45636702" rel=noopener target=_blank><i class="fab fa-crosshairs fa-fw"></i>CSDN</a></span></div><div class="cc-license motion-element" itemprop=license><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class=cc-opacity rel=noopener target=_blank><img src=/images/cc-by-nc-sa.svg alt="Creative Commons"></a></div></div></div></aside><div id=sidebar-dimmer></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy; 2019 – <span itemprop=copyrightYear>2020</span> <span class=with-love><i class="fa fa-heart"></i></span> <span class=author itemprop=copyrightHolder>Maisy</span> <span class=post-meta-divider>|</span> <span class=post-meta-item-icon><i class="fa fa-chart-area"></i></span> <span class=post-meta-item-text>站点总字数：</span> <span title=站点总字数>572k</span> <span class=post-meta-divider>|</span> <span class=post-meta-item-icon><i class="fa fa-coffee"></i></span> <span class=post-meta-item-text>站点阅读时长 &asymp;</span> <span title=站点阅读时长>8:40</span></div><div class=powered-by>由 <a href="https://hexo.io/" class=theme-link rel=noopener target=_blank>Hexo</a> & <a href="https://muse.theme-next.org/" class=theme-link rel=noopener target=_blank>NexT.Muse</a> 强力驱动</div></div></footer></div><script src=/lib/anime.min.js></script><script src=//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js></script><script src=//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js></script><script src=//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js></script><script src=/lib/velocity/velocity.min.js></script><script src=/lib/velocity/velocity.ui.min.js></script><script src=/js/utils.js></script><script src=/js/motion.js></script><script src=/js/schemes/muse.js></script><script src=/js/next-boot.js></script><script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script></body></html>