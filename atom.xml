<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>派大星の博客</title>
  
  <subtitle>记录生活中的点点滴滴</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-01-25T08:49:24.306Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>派大星</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker swarm</title>
    <link href="http://yoursite.com/2020/01/25/Docker%20swarm/"/>
    <id>http://yoursite.com/2020/01/25/Docker%20swarm/</id>
    <published>2020-01-24T16:00:00.000Z</published>
    <updated>2020-01-25T08:49:24.306Z</updated>
    
    <content type="html"><![CDATA[<p>Docker swarm</p><hr><p>docker swarm集群：三剑客之一</p><table><thead><tr><th>docker01</th><th>192.168.1.70</th><th>node1</th></tr></thead><tbody><tr><td>docker02</td><td>192.168.1.50</td><td>node2</td></tr><tr><td>docker03</td><td>192.168.1.40</td><td>node3</td></tr></tbody></table><p>关闭防火墙、禁用linux、3台dockerhost区别主机名，时间同步</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# setenforce  0</span><br><span class="line">[root@localhost ~]# systemctl  stop  firewalld</span><br><span class="line">[root@localhost ~]# hostnamectl  set-hostname  node1</span><br><span class="line">[root@localhost ~]# su -</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>docker版本必须是：v1.12版本开始</p><p>Swarm：</p><blockquote><p>作用docker engin（引擎）的多个主机组成的集群</p></blockquote><p>node：</p><blockquote><p>每一个docker engin都是一个node（节点），分为manager和worker</p></blockquote><p>manager node：</p><blockquote><p>负责执行编排和集群管理的工作，保持并维护swarm处于期望的状态，swarm可以有多个manager node，他们会自动协调并选举出一个Leader执行编排任务，但相反不能没有manager node</p></blockquote><p>worker node：</p><blockquote><p>接受并执行由manager node派发的任务，并且默认manager node也是一个worker node，不过可以将它设置为manager-noly node，让他只负责编排和管理工作</p></blockquote><p>service：</p><blockquote><p>用来定义worker上执行的命令</p></blockquote><p>1）初始化集群</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]# docker swarm init  --advertise-addr  192.168.1.70</span><br><span class="line">Swarm initialized: current node (g26pbaqiozkn99qw9ngtgncke) is now a manager.</span><br><span class="line"></span><br><span class="line">To add a worker to this swarm, run the following command:</span><br><span class="line"></span><br><span class="line">    docker swarm join --token SWMTKN-1-3fp7qnihbzzy8u0esfjmmdfncdud4yh628e7bey5tu8fo3cl5p-4x021jwoh1bryxpwqd4bsj8xd 192.168.1.70:2377</span><br><span class="line"></span><br><span class="line">To add a manager to this swarm, run &#39;docker swarm join-token manager&#39; and follow the instructions.</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><blockquote><p>–advertise-addr：指定与其他Node通信的地址</p></blockquote><p>上边返回的结果告诉我们：初始化成功，并且，如果想要添加work节点运行下面的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker swarm join --token SWMTKN-1-3fp7qnihbzzy8u0esfjmmdfncdud4yh628e7bey5tu8fo3cl5p-4x021jwoh1bryxpwqd4bsj8xd 192.168.1.70:2377</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>PS：这里注意，token只有24小时的有效期</p><p>如果想要添加manager节点：运行下边的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker swarm join-token manager</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>当两个节点加入成功之后，我们可以执行docker node ls查看节点详情</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]# docker node ls</span><br><span class="line">ID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION</span><br><span class="line">g26pbaqiozkn99qw9ngtgncke *   node1               Ready               Active              Leader              18.09.0</span><br><span class="line">w11nz7pzgmhq6wn5b51g6b8ao     node2               Ready               Active                                  18.09.0</span><br><span class="line">zqi7od9q0v7zo2tkabnseuqdf     node3               Ready               Active                                  18.09.0</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>基本操作命令：</p><blockquote><p>docker swarm leave：申请离开一个集群，之后查看节点状态会变成down然后通过manager node将其删除</p><p>docker node rm xxx：删除某个节点</p><p>docker swarm join-token {manager|worker}：生成令牌，可以是manager身份或worker身份</p><p>docker node demote（降级）：将swarm节点的manager降级为work</p><p>docker node promote（升级）：将swarm节点的work升级为manager</p></blockquote><p>2）部署docker swarm集群网络</p><hr><p>overlay：覆盖型网络</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]# docker network  create  -d  overlay  --attachable  docker</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><blockquote><p>attacheable：这个参数必须要加，否则不能用于容器</p><p>在创建网络的时候，我们并没有部署一个存储 服务，比如consul，那是因为docker swarm自带存储</p></blockquote><p>3）部署一个图形化webUI界面</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]# docker run  -d  -p  8080:8080  -e  HOST&#x3D;192.168.1.70  -e  PORT&#x3D;8080  \</span><br><span class="line">&gt;  -v &#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;var&#x2F;run&#x2F;docker.sock  --name viswalizer  dockersamples&#x2F;visualizer</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>然后通过浏览器验证：192.168.1.70:8080</p><p>如果访问网页访问不到，需要开启路由转发：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]# echo  net.ipv4.ip_forward &#x3D; 1 &gt;&gt; &#x2F;etc&#x2F;sysctl.conf </span><br><span class="line">[root@node1 ~]# sysctl -p</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/20200120155851918.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTYzNjcwMg==,size_16,color_FFFFFF,t_70" alt="img">)<img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>4）创建service（服务）</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]# docker service create --replicas 1 --network docker --name web1 -p 80:80 nginx</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/20200120155950198.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTYzNjcwMg==,size_16,color_FFFFFF,t_70" alt="img">)<img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>PS：</p><blockquote><p>如果node2或node3宕机，这些服务会自动转到节点中没有宕机的host上，并继续运行</p></blockquote><blockquote><p>–replicas：副本数量</p><p>大概可以理解为以个副本等于一个容器</p></blockquote><blockquote><p>查看service：</p><p>docker service ls</p><p>查看service信息：</p><p>docker service ps xxx</p><p>删除server：</p><p>docker service rm xxx</p></blockquote><p>设置manager node不参加工作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]# docker node update node1 --availability  drain</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>5)搭建私有仓库</p><hr><p>过程：略，详情请查看看<a href="https://blog.csdn.net/weixin_45636702/article/details/104002017" target="_blank" rel="noopener">https://blog.csdn.net/weixin_45636702/article/details/104002017</a></p><p>6）自定义镜像</p><hr><p>要求：基于httpd镜像，更改访问界面内容。镜像tag版本为v1，对应主机页面内容为111，2222，3333</p><p>v1，v2，v3目录下的操作一样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@node01 ~]# mkdir  &#123;v1,v2,v3&#125;</span><br><span class="line">[root@node01 ~]# cd  v1</span><br><span class="line">[root@node01 v1]# vim  index.html</span><br><span class="line">[root@node01 v1]# cat  index.html</span><br><span class="line">111111111111111111111111111</span><br><span class="line">.................</span><br><span class="line">[root@node01 v1]# vim  Dockerfile</span><br><span class="line">[root@node01 v1]# cat  Dockerfile </span><br><span class="line">FROM  httpd</span><br><span class="line">ADD index.html  &#x2F;usr&#x2F;local&#x2F;apache2&#x2F;htdocs&#x2F;index.html</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>7）发布一个服务，基于上述镜像</p><hr><p>要求：副本数量为3个，服务的名称为：bdqn</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@node01 ~]# docker service create --replicas 3  --name bdqn -p  80:80    192.168.1.70:5000&#x2F;httpd:v1</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>默认的ingress网络，包括创建的自定义overlay网络，为后端真正为用户提供服务的container，提供了一个统一的入口</p><p>随机映射的端口范围：30000-32767</p><p>8）服务的扩容与缩容</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@node01 ~]# docker  service  scale  bdqn&#x3D;6</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>扩容与缩容可以直接通过scale进行设置副本数量</p><p>9）服务的升级与回滚</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@node01 ~]# docker service  update --image  192.168.1.70:5000&#x2F;httpd:v2  bdqn</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//平滑的更新</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@node01 ~]# docker service  update  --image 192.168.1.70:5000&#x2F;httpd:v3  --update-parallelism 2  --update-delay 1m  bdqn</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>PS：</p><blockquote><p>默认情况下，swarm一次只更新一个副本，并且两个副本之间没有等待时间，我们可以通过</p><p>–update-parallelisnm：设置并更新的副本数量</p><p>–update-delay：指定滚动更新时间间隔</p></blockquote><p>//回滚操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@node01 ~]# docker service  rollback  bdqn</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>PS：</p><blockquote><p>docker swarm的回滚操作，默认只能回滚到上一次的操作状态，并不能连续回滚操作</p></blockquote>]]></content>
    
    <summary type="html">
    
      Docker
    
    </summary>
    
    
      <category term="Docker" scheme="http://yoursite.com/categories/Docker/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker架构+Docker镜像分层+Dockerfile</title>
    <link href="http://yoursite.com/2020/01/25/Docker%E6%9E%B6%E6%9E%84+Docker%E9%95%9C%E5%83%8F%E5%88%86%E5%B1%82+Dockerfile/"/>
    <id>http://yoursite.com/2020/01/25/Docker%E6%9E%B6%E6%9E%84+Docker%E9%95%9C%E5%83%8F%E5%88%86%E5%B1%82+Dockerfile/</id>
    <published>2020-01-24T16:00:00.000Z</published>
    <updated>2020-01-25T08:50:36.242Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker架构："><a href="#Docker架构：" class="headerlink" title="Docker架构："></a>Docker架构：</h1><p><img src="https://img-blog.csdnimg.cn/20200116115726787.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTYzNjcwMg==,size_16,color_FFFFFF,t_70" alt="img">)<img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>Docker架构总结：</p><p>Docker是属于C/S架构，用户是使用 Docker Client 与 Docker Daemon 建立通信，并发送请求。请求接收后，Docker server通过http协议与路由，找到相应的 Handler 来执行请求</p><p>Docker Engine 是 Docker 架构中的运行引擎，同时也 Docker 运行的核心模块。Docker Engine 执行 Docker 内部的一系列工作，每一项工作都是以一个 Job 的形式的存在</p><p>Job 的运行过程中，当需要容器镜像时，则从 Docker Registry 中下载镜像，并通过镜像管理驱动 Graphdriver 将下载镜像以 Graph 的形式存储</p><p>当需要为 Docker 创建网络环境时，通过网络管理驱动 Networkdriver 创建并配置 Docker容器网络环境</p><p>当需要限制 Docker 容器运行资源或执行用户指令等操作时，则通过 Execdriver 来完成</p><p>Libcontainer 是一项独立的容器管理包，Networkdriver 以及 Execdriver 都是通过 Libcontainer 来实现具体对容器进行的操作</p><h2 id="Docker镜像分层："><a href="#Docker镜像分层：" class="headerlink" title="Docker镜像分层："></a>Docker镜像分层：</h2><p>Docker的最小镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker pull hello-world</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM  scratch</span><br><span class="line">CORP  hello&#x2F;</span><br><span class="line">CMD  [&quot;&#x2F;hello&quot;]</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong>Dockerfile的组成：</strong></p><p>1）FROM：scratch（抓、挠）</p><p>2）COPY：hello/</p><p>3）CMD：[“/hello”]</p><p>base镜像(基础镜像)：</p><p>Centos:7镜像的dockerfile</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FROM scratch  &#x2F;&#x2F;从零开始构建</span><br><span class="line"></span><br><span class="line">ADD centos-7-x86 64-docker.tar.xz &#x2F;</span><br><span class="line"></span><br><span class="line">LABEL org. label-schema. schema-version&#x3D;&quot;1.0&quot;\</span><br><span class="line">org. label-schema.namem&quot;centos Base Image&quot;\</span><br><span class="line">org. label-schema.vendore&quot;Centos&quot;\</span><br><span class="line">org. label-schema.Ticenses&quot;GPLv2&quot; \</span><br><span class="line">org. labe1-schema.build-date&quot;20190305</span><br><span class="line"></span><br><span class="line">CMD [&quot;&#x2F;bin&#x2F;bash&quot;]</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test]# docker build -t centos7-vim-net-tools:12-11 .</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/20200116115958270.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTYzNjcwMg==,size_16,color_FFFFFF,t_70" alt="img">)<img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>Dockerfile镜像分层总结：</p><p>镜像是容器的基石，容器是镜像运行后的实例，当镜像运行为容器之后，对镜像的所有数据仅有只读权限，如果需要对镜像源文件进行修改或删除操作时，此时是在容器层（可写层）进行的，用到了COW（copy on write）写时复制机制</p><p>Docker镜像的缓存特性</p><p>创建一个新的Dockerfile文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM centos:7</span><br><span class="line">RUN yum -y install vim</span><br><span class="line">RUN yum -y install net-tools</span><br><span class="line">RUN yum -y install wget</span><br><span class="line">CMD [&quot;&#x2F;bin&#x2F;bash&quot;]</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker build -t new-centos .</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>1）如果在相同层，有用到相同的镜像，可以不必再去下载，可以直接使用缓存</p><p>创建一个新的Dockefile文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM centos:7</span><br><span class="line">RUN yum -y install vim</span><br><span class="line">RUN yum -y install wget</span><br><span class="line">RUN yum -y install net-tools</span><br><span class="line">CMD [&quot;&#x2F;bin&#x2F;bash&quot;]</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test1]# docker build -t centos-new .</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>2）即使镜像层里的操作一样，也必须是在同一层才可以使用dockerfile的缓存特性</p><p>如果制作镜像过程中，不想使用缓存可以加–no-cache选项</p><p>3）如果前面的曾发生改变，即使后边的层操作和顺序一样，也不能使用缓存特性</p><p>Dockerfile常用指令：</p><p>1）FROM：构建镜像基于哪个镜像</p><p>例如：FROM:centos:7</p><p>2）MAINTAINER：镜像维护者姓名或邮箱</p><p>例如：MAINTAINER admin</p><p>3）RUN：构建镜像时运行的shell命令</p><p>例如：</p><p>RUN [“yum”,”install”,”httpd”]</p><p>RUN yum -y install httpd</p><p>4）CMD：运行容器时执行的shell命令</p><p>例如：</p><p>CMD [“/bin/bash”]</p><p>5）EXPOSE：声明容器的服务端口</p><p>例如：EXPOSE 80 443</p><p>6）ENV：设置容器环境变量</p><p>例如：</p><p>ENV MYSQL_ROOT_PASSWORD 123.com</p><p>7）ADD：拷贝文件或目录到镜像，如果时URL或压缩包会自动下载或解压</p><p>ADD &lt;源文件&gt;… &lt;目标目录&gt;</p><p>ADD [“源文件”…”目标目录”]</p><p>8）COPY：拷贝文件或目录到镜像容器内，跟ADD相似，但不具备自动下载或解压功能</p><p>9）ENTRYPOINT：运行容器时执行的shell命令</p><p>例如：</p><p>ENTRYPOINT [“/bin/bash”,”-c”,”command”]</p><p>ENTRYPOINT /bin/bash -c ‘command’</p><p>10）VOLUME：指定容器挂在点到宿主机自动生成的目录或其他容器</p><p>例如：</p><p>VOLUME [“/va/lib/mysql”]</p><p>11）USER：为RUN、CMD、和ENTRYPOINT执行命令指定运行用户</p><p>12）WORKDIR：为RUN、CMD、ENTRYPOINT、COPY和ADD设置工作目录，意思为切换目录</p><p>例如：</p><p>WORKDIR：/var/lib/mysql</p><p>13）HEALTHCHECK：健康检查</p><p>14）ARG：构建时指定的一些参数</p><p>例如：</p><p>FROM centos:7</p><p>ARG user</p><p>USER $user</p><p>注意：</p><p>1、RUN在building时运行，可以写多条</p><p>2、CMD和ENTRYPOINT在运行container时，只能写一条，如果写多条，最后一条生效</p><p>3、CMD在run时可以被COMMAND覆盖，ENTRYPOINT不会被不会被COMMAND覆盖，但可以指定–entrypoint覆盖</p><p>4、如果在Dockerfile里需要往镜像内导入文件，则此文件必须在dockerfile所在目录或子目录下</p><p>小实验：</p><p>写一个dockerfile，基于cenyos:7镜像，部署安装NGINX服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mkdir  web</span><br><span class="line">[root@localhost ~]# mv nginx-1.14.0.tar.gz  web&#x2F;</span><br><span class="line">[root@localhost ~]# cd web&#x2F;</span><br><span class="line">[root@localhost web]# vim  Dockerfile</span><br><span class="line">FROM centos:7</span><br><span class="line">RUN yum -y install gcc pcre pcre-devel openssl openssl-devel zlib zlib-devel</span><br><span class="line">COPY  nginx-1.14.0.tar.gz  &#x2F;</span><br><span class="line">RUN tar -zxf nginx-1.14.0.tar.gz -C &#x2F;usr&#x2F;src</span><br><span class="line">RUN useradd -M -s &#x2F;sbin&#x2F;nologin nginx</span><br><span class="line">WORKDIR &#x2F;usr&#x2F;src&#x2F;nginx-1.14.0</span><br><span class="line">RUN .&#x2F;configure  --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx  --user&#x3D;nginx  --group&#x3D;nginx</span><br><span class="line">RUN  make  &amp;&amp;  make  install</span><br><span class="line">RUN ln -s &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;*  &#x2F;usr&#x2F;local&#x2F;sbin</span><br><span class="line">RUN nginx -t</span><br><span class="line">RUN nginx</span><br><span class="line">EXPOSE 80</span><br><span class="line">[root@localhost web]# docker build  -t  test-web  . &#x2F;&#x2F;如果Dockerfile在其他路径需要加-f参数来指定Dockerfile文件路径</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//如果想要保证容器运行之后，nginx服务就直接开启，不必手动开启，我们可以在命令最后加上：nginx -g “daemon off;”选项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost web]# docker run -itd --name testweb_2 test-web:latest nginx -g &quot;daemon off;&quot;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//查看容器的IP：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost web]# docker inspect  testweb_2</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>]]></content>
    
    <summary type="html">
    
      Docker
    
    </summary>
    
    
      <category term="Docker" scheme="http://yoursite.com/categories/Docker/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker的基本操作命令</title>
    <link href="http://yoursite.com/2020/01/25/Docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2020/01/25/Docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/</id>
    <published>2020-01-24T16:00:00.000Z</published>
    <updated>2020-01-25T08:49:56.570Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker的基本操作命令："><a href="#Docker的基本操作命令：" class="headerlink" title="Docker的基本操作命令："></a><strong>Docker的基本操作命令：</strong></h1><p>//查找镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker search mysql &#x2F;&#x2F;默认在docker hub公共仓库进行查找</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//拉取镜像，下载镜像:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker pull busybox</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//导出镜像到本地：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker save -o busybox.tar busybox:latest （docker save &gt; busybox.tar busybox:latest）</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//查看本地镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker images （docker image ls）</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>PS：虽然我们查看到镜像标签位latest（最新的），但并不表示它一定是最新的，而且镜像如果没有写标签，默认是以latest为标签</p><p>//删除镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker rmi busybox:latest</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//根据本地镜像包导入镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker load -i busybox.tar （docker load &lt; busybox.tar ）</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//查看容器–正在运行的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker ps</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//查看所有的容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker ps -a</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//删除容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker rm centos [CONTAINER ID&#x2F;容器名称]</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//停止容器运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker stop centos</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//启动容器:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker start centos</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>PS:开启容器后记得去验证一下容器是否开启</p><p>//强制删除容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker rm centos -f</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//强制删除所有容器（生产环境严禁使用）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker ps -a -q | xargs docker rm -f</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>-———————————————————————————————</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker ps -a -q | xargs docker start -f &#x2F;&#x2F;开启所有容器</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# docker ps -a -q | xargs docker stop -f &#x2F;&#x2F;关闭所有容器</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//重启一个容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker restart test2</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//运行一个容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker run -it --name test1 centos:7</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>-i：交互</p><p>-t：伪终端</p><p>-d（daemon）：后台运行</p><p>–name：给容器命名</p><p>–restart=always：始终保持运行（随着docker开启而运行）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker create -it --name test3 centos:7 &#x2F;&#x2F;不常用</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//进入一个容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker exec -it test2 &#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# docker attach test2</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>区别：</p><p>exec进入的方式需要添加-i，-t选项，后面还需要给容器一个shell环境，但attach就不需要这么麻烦</p><p>exec进入的方式：如果exit退出，容器仍然保持运行</p><p>attach：如果执行exit退出，容器会被关闭，如果想要保持容器不被关闭，可以使用键盘：ctrl+p ctrl+q可以实现</p><p>本质上区别：</p><p>exec进入的方法，会产生新的进程</p><p>attach进入的方法，不会产生新的进程</p><p>Docker的基本操作逻辑：</p><p><img src="https://img-blog.csdnimg.cn/20200116115431346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTYzNjcwMg==,size_16,color_FFFFFF,t_70" alt="img">)<img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>小实验：</p><p>基于centos:7镜像运行一个容器，并且在这个容器内部署nginx服务</p><p>1）下载镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker pull centos:7</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>2）运行容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker run -itd --name webapp --restart&#x3D;always centos:7</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>3）进入容器，开始部署nginx服务：//将nginx包导入到容器内：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker cp nginx-1.14.0.tar.gz</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker exec  -it  webapp  &#x2F;bin&#x2F;bash</span><br><span class="line">[root@01b870908942 ~]# tar zxf nginx-1.14.0.tar.gz   </span><br><span class="line">[root@01b870908942 ~]# cd  nginx-1.14.0</span><br><span class="line">[root@01b870908942 nginx-1.14.0]# yum  -y  install  gcc  pcre  pcre-devel  openssl  openssl-devevl zlib zlib-devel</span><br><span class="line">[root@01b870908942 nginx-1.14.0]# useradd  -s  &#x2F;sbin&#x2F;nologin  nginx</span><br><span class="line">[root@01b870908942 nginx-1.14.0]# .&#x2F;configure  --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx  --user&#x3D;nginx  --group&#x3D;nginx</span><br><span class="line">[root@01b870908942 nginx-1.14.0]# make  &amp;&amp;  make  install</span><br><span class="line">[root@01b870908942 nginx-1.14.0]# ln  -s  &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;*   &#x2F;usr&#x2F;local&#x2F;sbin&#x2F;</span><br><span class="line">[root@01b870908942 nginx-1.14.0]# nginx</span><br><span class="line">[root@01b870908942 nginx-1.14.0]# cd  &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;html&#x2F;</span><br><span class="line">[root@01b870908942 html]# echo  This  is  a  resrweb  in  container  &gt;  index.html</span><br><span class="line">[root@01b870908942 html]# curl  127.0.0.1</span><br><span class="line">This is a resrweb in container</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//把容器制作成镜像：（可移植性）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker commit webapp myweb:12-10</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>]]></content>
    
    <summary type="html">
    
      Docker
    
    </summary>
    
    
      <category term="Docker" scheme="http://yoursite.com/categories/Docker/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker的底层原理</title>
    <link href="http://yoursite.com/2020/01/25/Docker%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2020/01/25/Docker%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</id>
    <published>2020-01-24T16:00:00.000Z</published>
    <updated>2020-01-25T08:49:45.747Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker底层原理"><a href="#Docker底层原理" class="headerlink" title="Docker底层原理"></a><strong>Docker底层原理</strong></h1><p>如果虚拟机内服务对内核版本有要求，这个服务就不太适合用docker来实现了</p><p>Busybox：欺骗层</p><p>解耦：解除耦合、解除冲突</p><p>耦合：冲突现象</p><p>run—–&gt;Centos系统（nginx、web）</p><p>对于docker host来说这个系统仅仅是一个进程</p><p>Namespace（名称空间）：</p><p>用来隔离容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ns]# pwd</span><br><span class="line">&#x2F;proc&#x2F;2971&#x2F;ns</span><br><span class="line">[root@localhost ns]# ls</span><br><span class="line">ipc  mnt  net  pid  user  uts</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>ipc：共享内存、消息列队</p><p>mnt：挂载点、文件系统</p><p>net：网络栈</p><p>pid：进程编号</p><p>user：用户、组</p><p>uts：主机名、域名</p><p>//namespace六项隔离，实现了容器与宿主机、容器与容器之间的隔离</p><p>Cgroup（控制组）：</p><p>资源的限制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@d9d679199f74 cgroup]# pwd</span><br><span class="line">&#x2F;sys&#x2F;fs&#x2F;cgroup</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost cpu]# cat  tasks</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>PS：task这个文件内的数字，记录的是进程编号。PID</p><p>四大功能：</p><p>1）资源限制：cgroup可以对进程组使用的资源总额进行限制</p><p>2）优先级分配：通过分配的cpu时间片数量以及硬盘IO带宽大小，实际上相当于控制了进程运行的优先级别</p><p>3）资源统计：cgroup可以统计西系统资源使用量，比如cpu使用时间，内存使用量等，用于按量计费。同时还支持挂起功能，也就是说用过cgroup把所有的资源限制起来，对资源都不能使用，注意并不算是说我们的程序不能使用了，只是不能使用资源，处于挂起等待状态</p><p>4）进程控制：可以对进程组执行挂起、恢复等操作</p><p>内存限额：</p><p>容器内存包括两个部分：物理内存和swap</p><p>可以通过参数控制容器内存的使用量：</p><p>-m或者–memory：设置内存的使用限额</p><p>–memory-swap：设置内存+swap的使用限额</p><p>举个例子：</p><p>如果运行一个容器，并且限制该容器最多使用200M内存和100M的swap</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker run  -it  -m 200M --memory-swap 300M centos:7</span><br><span class="line">[root@5bc0e71faba3 memory]# pwd</span><br><span class="line">&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;memory</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//内存使用限制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@5bc0e71faba3 memory]# cat memory.limit_in_bytes </span><br><span class="line">209715200（字节）</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//内存+swap限制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@5bc0e71faba3 memory]# cat memory.memsw.limit_in_bytes</span><br><span class="line">314572800（字节）</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>对比一个没有限制的容器，我们会发现，如果运行容器之后不限制内存的话，意味着没有限制</p><p>CPU使用：</p><p>通过-c或者–cpu-shares设置容器使用cpu的权重，如果 不设置默认为1024</p><p>举个例子：</p><p>//没有限制：1024</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker run  -it --name  containerA  centos:7</span><br><span class="line">[root@e2d88b8f8b87 &#x2F;]# cd  &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu</span><br><span class="line">[root@e2d88b8f8b87 cpu]# cat cpu.shares </span><br><span class="line">1024</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//限制CPU使用权重为512：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker run  -it  --name  containerB  -c  512  centos:7</span><br><span class="line">[root@f8165e07c8d7 &#x2F;]# cd  &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu</span><br><span class="line">[root@f8165e07c8d7 cpu]# cat  cpu.shares </span><br><span class="line">512</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>容器的Block IO（磁盘的读写）：</p><p>docker中可以通过设置权重，限制bps和iops的方式控制容器读写磁盘的IO</p><p>bps：每秒的读写的数据量（byte per second）</p><p>iops：每秒IO的次数 （io per second）</p><p>默认情况下，所有容器都能够平等的读写磁盘，也可以通过–blkio-weight参数改变容器的blockIO的优先级</p><p>–device-read-bps：显示读取某个设备的bps</p><p>–device-write-bps：显示写入某个设备的bps</p><p>–device-read-iops：显示读取某个设备的iops</p><p>–device-write-iops：显示写入某个设备的iops</p><p>//限制testA这个容器，写入/dev/sda这块磁盘的bps为30MB</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker run  -it --name  testA  --device-write-bps  &#x2F;dev&#x2F;sda:30MB centos:7</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//从/dev/zero输入，然后输出到test.out文件中，每次大小为1M，总共为800次，oflg=direct用来指定directIO方式写文件，这样才会使–device-write-bps生效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@0e659ca3e85d &#x2F;]# time dd  if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;test.out bs&#x3D;1M count&#x3D;800 oflag&#x3D;direct</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>]]></content>
    
    <summary type="html">
    
      Docker
    
    </summary>
    
    
      <category term="Docker" scheme="http://yoursite.com/categories/Docker/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker的监控</title>
    <link href="http://yoursite.com/2020/01/25/Docker%E7%9A%84%E7%9B%91%E6%8E%A7/"/>
    <id>http://yoursite.com/2020/01/25/Docker%E7%9A%84%E7%9B%91%E6%8E%A7/</id>
    <published>2020-01-24T16:00:00.000Z</published>
    <updated>2020-01-25T08:50:08.780Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker的监控"><a href="#Docker的监控" class="headerlink" title="Docker的监控"></a><strong>Docker的监控</strong></h1><p>docker自带的监控命令</p><p>docker top / stats / logs</p><p>sysdig</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker  load  &lt;  sysdig.tar</span><br><span class="line">[root@localhost ~]# docker  load  &lt;  scope.1.12.tar</span><br><span class="line">[root@localhost ~]# docker run  -it  --rm  --name  sysdig  \</span><br><span class="line">&gt;   --privileged&#x3D;true  \</span><br><span class="line">&gt;   --volume&#x3D;&#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;host&#x2F;var&#x2F;run&#x2F;docker.sock  \</span><br><span class="line">&gt;   --volume&#x3D;&#x2F;dev:&#x2F;host&#x2F;dev   \</span><br><span class="line">&gt;   --volume&#x3D;&#x2F;proc:&#x2F;host&#x2F;proc:ro  \</span><br><span class="line">&gt;   --volume&#x3D;&#x2F;boot:&#x2F;host&#x2F;boot:ro  \</span><br><span class="line">&gt;   --volume&#x3D;&#x2F;lib&#x2F;modules:&#x2F;host&#x2F;lib&#x2F;modules:ro  \</span><br><span class="line">&gt;   --volume&#x3D;&#x2F;usr:&#x2F;host&#x2F;usr:ro  sysdig&#x2F;sysdig</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//下载失败后可以运行下边的命令，重新下载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@2fefbfde3db5:&#x2F;# sysdig-probe-loader</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//下载成功之后，可以运行sysdig命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@2fefbfde3db5:&#x2F;# csysdig</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="scope"><a href="#scope" class="headerlink" title="scope"></a><strong>scope</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# curl -L git.io&#x2F;scope -o &#x2F;usr&#x2F;local&#x2F;bin&#x2F;scope</span><br><span class="line">[root@localhost ~]# chmod  a+x  &#x2F;usr&#x2F;local&#x2F;bin&#x2F;scope</span><br><span class="line">[root@localhost ~]# scope launch</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//访问本机的4040端口</p><p><img src="https://img-blog.csdnimg.cn/20200117112551162.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTYzNjcwMg==,size_16,color_FFFFFF,t_70" alt="img">)<img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//监控两台dockerhost</p><table><thead><tr><th>docker01</th><th>192.168.1.70</th></tr></thead><tbody><tr><td>docker02</td><td>192.168.1.50</td></tr></tbody></table><p>//docker02上也需要同样的操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@docker02 ~]# curl -L git.io&#x2F;scope -o &#x2F;usr&#x2F;local&#x2F;bin&#x2F;scope</span><br><span class="line">[root@docker02 ~]# chmod  a+x  &#x2F;usr&#x2F;local&#x2F;bin&#x2F;scope</span><br><span class="line">[root@docker02 ~]# docker  load  &lt;  scope.1.12.tar</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# scope launch  192.168.1.70 192.168.1.50</span><br><span class="line">[root@docker02 ~]# scope launch  192.168.1.50  192.168.1.70</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/20200117112630969.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTYzNjcwMg==,size_16,color_FFFFFF,t_70" alt="img">)<img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>]]></content>
    
    <summary type="html">
    
      Docker
    
    </summary>
    
    
      <category term="Docker" scheme="http://yoursite.com/categories/Docker/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker的私有仓库</title>
    <link href="http://yoursite.com/2020/01/25/Docker%E7%9A%84%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/"/>
    <id>http://yoursite.com/2020/01/25/Docker%E7%9A%84%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/</id>
    <published>2020-01-24T16:00:00.000Z</published>
    <updated>2020-01-25T08:50:23.106Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Registry"><a href="#Registry" class="headerlink" title="Registry"></a><strong>Registry</strong></h1><p>用docker容器运行registry私有仓库</p><p>下载registry镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker  pull  registry:2  &#x2F;&#x2F;2版本是使用go语言编写的，而registry是使用python写的</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//运行私有仓库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker run -itd --name registry --restart&#x3D;always -p 5000:5000 -v &#x2F;registry:&#x2F;var&#x2F;lib&#x2F;registry registry:2</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>-p：端口映射（宿主机端口：容器暴露的端口）</p><p>-v：挂载目录（宿主机的目录：容器内的目录）</p><p>镜像重命名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker tag test-web:latest  192.168.1.70:5000&#x2F;test</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>上传镜像到私有仓库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim  &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;docker.service</span><br><span class="line">修改：指定私有仓库地址</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;bin&#x2F;dockerd --insecure-registry 192.168.1.70:5000</span><br><span class="line">[root@localhost ~]# systemctl  daemon-reload </span><br><span class="line">[root@localhost ~]# systemctl  restart  docker</span><br><span class="line">[root@localhost ~]# docker push  192.168.1.70:5000&#x2F;test:latest</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>这里注意，既然是私有仓库，肯定是要考虑多台DockerHost共用的情况，如果有其他的DockerHost想要使用私有仓库，仅需要修改docker的配置文件，指定私有仓库的IP和端口即可。当然别忘了，更改过配置文件之后，daemon-reload ,restart docker服务</p><h1 id="企业级私有仓库镜像Harbor"><a href="#企业级私有仓库镜像Harbor" class="headerlink" title="企业级私有仓库镜像Harbor"></a><strong>企业级私有仓库镜像Harbor</strong></h1><p>下载一个docker-compse工具</p><p>//从GitHub上下载方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# curl -L https:&#x2F;&#x2F;github.com&#x2F;docker&#x2F;compose&#x2F;releases&#x2F;download&#x2F;1.25.0&#x2F;docker-compose-&#96;uname -s&#96;-&#96;uname -m&#96; -o &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose</span><br><span class="line">[root@docker01 ~]# chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# tar zxf docker-compose.tar.gz  -C  &#x2F;usr&#x2F;local&#x2F;bin</span><br><span class="line">[root@docker01 ~]# chmod  +x  &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//下载依赖包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# yum  -y  install  yum-utils  device-mapper-persistent-data  lvm2</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//导入harbo离线安装包，并解压到/usr/local/下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# tar zxf harbor-offline-installer-v1.7.4.tgz -C &#x2F;usr&#x2F;local&#x2F;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//安装harbor</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# cd  &#x2F;usr&#x2F;local&#x2F;harbor&#x2F;</span><br><span class="line">[root@docker01 harbor]# vim  harbor.cfg</span><br><span class="line">hostname &#x3D; 192.168.1.70</span><br><span class="line">[root@docker01 harbor]# .&#x2F;install.sh</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//浏览器访问：192.168.1.70</p><p>用户名：admin</p><p>密码：Harbor12345</p><p><img src="https://img-blog.csdnimg.cn/2020011611433816.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTYzNjcwMg==,size_16,color_FFFFFF,t_70" alt="img">)<img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//修改docker配置文件，连接Harbor私有仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# vim  &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;docker.service</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;bin&#x2F;dockerd  --insecure-registry  192.168.1.70</span><br><span class="line">[root@docker01 ~]# systemctl  daemon-reload </span><br><span class="line">[root@docker01 ~]# systemctl  restart  docker</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//创建私有仓库</p><p><img src="https://img-blog.csdnimg.cn/20200116114438273.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTYzNjcwMg==,size_16,color_FFFFFF,t_70" alt="img">)<img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//登录仓库上传镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 harbor]# docker login  -u  admin -p  Harbor12345  192.168.1.70</span><br><span class="line">[root@docker01 harbor]# docker tag  centos:7  192.168.1.70&#x2F;bdqn&#x2F;centos:7</span><br><span class="line">[root@docker01 harbor]# docker push  192.168.1.70&#x2F;bdqn&#x2F;centos:7</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//从私有仓库下载镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@docker03 ~]# docker pull  192.168.1.70&#x2F;bdqn&#x2F;centos:7</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>]]></content>
    
    <summary type="html">
    
      Docker
    
    </summary>
    
    
      <category term="Docker" scheme="http://yoursite.com/categories/Docker/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker部署LNMP环境</title>
    <link href="http://yoursite.com/2020/01/25/Docker%E9%83%A8%E7%BD%B2LNMP%E7%8E%AF%E5%A2%83/"/>
    <id>http://yoursite.com/2020/01/25/Docker%E9%83%A8%E7%BD%B2LNMP%E7%8E%AF%E5%A2%83/</id>
    <published>2020-01-24T16:00:00.000Z</published>
    <updated>2020-01-25T08:49:35.148Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker部署LNMP环境"><a href="#Docker部署LNMP环境" class="headerlink" title="Docker部署LNMP环境"></a><strong>Docker部署LNMP环境</strong></h1><p>172.16.10.0/24</p><p>Nginx：172.16.10.10</p><p>Mysql：172.16.10.20</p><p>PHP：172.16.10.30</p><p>网站的访问主目录：/wwwroot</p><p>Nginx的配置文件：/docker</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker  run  -itd  --name  test  nginx:latest</span><br><span class="line">[root@localhost ~]# mkdir  &#x2F;wwwroot</span><br><span class="line">[root@localhost ~]# mkdir  &#x2F;docker</span><br><span class="line">[root@localhost ~]# docker cp test:&#x2F;etc&#x2F;nginx  &#x2F;docker&#x2F;</span><br><span class="line">[root@localhost ~]# ls &#x2F;docker&#x2F;</span><br><span class="line">nginx</span><br><span class="line">[root@localhost ~]# docker cp test:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html &#x2F;wwwroot&#x2F;</span><br><span class="line">[root@localhost ~]# ls  &#x2F;wwwroot&#x2F;</span><br><span class="line">html</span><br><span class="line">[root@localhost ~]# vim   &#x2F;wwwroot&#x2F;html&#x2F;index.html</span><br><span class="line">[root@localhost ~]# cat  &#x2F;wwwroot&#x2F;html&#x2F;index.html </span><br><span class="line">hello  LNMP!</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>1）创建一个自定义网络</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker network create -d bridge --subnet 172.16.10.0&#x2F;24 --gateway 172.16.10.1 lnmp</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>2）运行nginx容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker run  -itd  --name  nginx  -v  &#x2F;docker&#x2F;nginx&#x2F;:&#x2F;etc&#x2F;nginx  -v  &#x2F;wwwroot&#x2F;html&#x2F;:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html  -p  80:80  --network  lnmp  --ip  172.16.10.10  nginx:latest</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>3）运行mysql容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker run  --name  mysql  -e  MYSQL_ROOT_PASSWORD&#x3D;123.com  -d  -p  3306:3306  --network  lnmp  --ip  172.16.10.20  mysql:5.7</span><br><span class="line">[root@localhost ~]# yum  -y  install  mysql</span><br><span class="line">[root@localhost ~]# mysql -u root  -p123.com  -h  127.0.0.1  -P  3306</span><br><span class="line">MySQL [(none)]&gt; create  database  name;</span><br><span class="line">MySQL [(none)]&gt; show  databases;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| name               |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sys                |</span><br><span class="line">+--------------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>4）运行php容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker run -itd --name phpfpm -p 9000:9000 -v &#x2F;wwwroot&#x2F;html&#x2F;:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html --network lnmp --ip 172.16.10.30 php:7.2-fpm</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//添加php测试页面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost html]# pwd</span><br><span class="line">&#x2F;wwwroot&#x2F;html</span><br><span class="line">[root@localhost html]# cat  test.php </span><br><span class="line">&lt;?php</span><br><span class="line">phpinfo();</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>5）修改nginx配置文件，nginx和php连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cd  &#x2F;docker&#x2F;nginx&#x2F;conf.d&#x2F;</span><br><span class="line">[root@localhost conf.d]# vim  default.conf</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        root   &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;</span><br><span class="line">        index  index.html index.htm index.php;  &#x2F;&#x2F;添加php解析</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;打开此模块，并更改相应信息</span><br><span class="line">    location ~ \.php$ &#123;</span><br><span class="line">        root           &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;</span><br><span class="line">        fastcgi_pass   172.16.10.30:9000;</span><br><span class="line">        fastcgi_index  index.php;</span><br><span class="line">        fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;</span><br><span class="line">        include        fastcgi_params;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//重启nginx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost conf.d]# docker  restart  nginx</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//到此，去浏览器验证，nginx服务和php服务界面</p><p><img src="https://img-blog.csdnimg.cn/20200117104031897.png" alt="img">)<img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/20200117104044974.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTYzNjcwMg==,size_16,color_FFFFFF,t_70" alt="img">)<img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>说明nginx和php的来连接，没有问题，接下来是php和mysql的连接，在这我们使用一个phpMyAdmin的数据库管理工具</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost html]# pwd</span><br><span class="line">&#x2F;wwwroot&#x2F;html</span><br><span class="line">[root@localhost html]# unzip phpMyAdmin-4.9.1-all-languages.zip</span><br><span class="line">[root@localhost html]# mv  phpMyAdmin-4.9.1-all-languages  phpmyadmin</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//更改nginx的配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cd  &#x2F;docker&#x2F;nginx&#x2F;conf.d&#x2F;</span><br><span class="line">[root@localhost conf.d]# pwd</span><br><span class="line">&#x2F;docker&#x2F;nginx&#x2F;conf.d</span><br><span class="line">[root@localhost conf.d]# vim  default.conf</span><br><span class="line">&#x2F;&#x2F;在27行添加</span><br><span class="line">    location  &#x2F;phpmyadmin &#123;</span><br><span class="line">        root  &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;</span><br><span class="line">        index   index.html  index.htm  index.php;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在43行添加</span><br><span class="line">    location ~ &#x2F;phpmyadmin&#x2F;(?&lt;after_ali&gt;(.*)\.(php|php5)?$) &#123;</span><br><span class="line">        root           &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;</span><br><span class="line">        fastcgi_pass   172.16.10.30:9000;</span><br><span class="line">        fastcgi_index  index.php;</span><br><span class="line">        fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;</span><br><span class="line">        include        fastcgi_params;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//重启nginx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost conf.d]# docker  restart  nginx</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//验证php主界面</p><p><img src="https://img-blog.csdnimg.cn/20200117104224331.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTYzNjcwMg==,size_16,color_FFFFFF,t_70" alt="img">)<img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//需要我们对php镜像做出更改，添加php和mysql连接的模块</p><p>写一个Docker</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FROM php:7.2-fpm</span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y \</span><br><span class="line">        libfreetype6-dev \</span><br><span class="line">        libjpeg62-turbo-dev \</span><br><span class="line">        libpng-dev \</span><br><span class="line">    &amp;&amp; docker-php-ext-install -j$(nproc) iconv \</span><br><span class="line">    &amp;&amp; docker-php-ext-configure gd --with-freetype-dir&#x3D;&#x2F;usr&#x2F;include&#x2F; --with-jpeg-dir&#x3D;&#x2F;usr&#x2F;include&#x2F; \</span><br><span class="line">    &amp;&amp; docker-php-ext-install -j$(nproc) gd \</span><br><span class="line">        &amp;&amp; docker-php-ext-install mysqli pdo pdo_mysql</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker build  -t  phpmysql  .</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//删除之前的php容器，并用我们新制作的php镜像重新运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker stop  phpfpm </span><br><span class="line">[root@localhost ~]# docker rm  phpfpm </span><br><span class="line">[root@localhost ~]# docker run  -itd  --name  phpfpm  -p 9000:9000  -v  &#x2F;wwwroot&#x2F;html&#x2F;:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html  --network lnmp  --ip 172.16.10.30  phpmysql:latest</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//修改phpmyadmin的配置文件，指定连接的数据库的IP，然后重启php容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cd  &#x2F;wwwroot&#x2F;html&#x2F;phpmyadmin&#x2F;</span><br><span class="line">[root@localhost phpmyadmin]# pwd</span><br><span class="line">&#x2F;wwwroot&#x2F;html&#x2F;phpmyadmin</span><br><span class="line">[root@localhost phpmyadmin]# cp  config.sample.inc.php  config.inc.php</span><br><span class="line">[root@localhost phpmyadmin]# vim  config.inc.php</span><br><span class="line">$cfg[&#39;Servers&#39;][$i][&#39;host&#39;] &#x3D; &#39;172.16.10.20&#39;;    &#x2F;&#x2F;修改，指定数据库的IP地址</span><br><span class="line">[root@localhost ~]# docker restart  phpfpm</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>用户名：root</p><p>密码：123.com</p><p><img src="https://img-blog.csdnimg.cn/20200117104322390.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTYzNjcwMg==,size_16,color_FFFFFF,t_70" alt="img">)<img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//登录成功之后会看到我们之前创建的数据库</p><p><img src="https://img-blog.csdnimg.cn/20200117104346584.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTYzNjcwMg==,size_16,color_FFFFFF,t_70" alt="img">)<img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>]]></content>
    
    <summary type="html">
    
      Docker
    
    </summary>
    
    
      <category term="Docker" scheme="http://yoursite.com/categories/Docker/"/>
    
    
  </entry>
  
  <entry>
    <title>KVM磁盘格式</title>
    <link href="http://yoursite.com/2020/01/25/KVM%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/01/25/KVM%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/</id>
    <published>2020-01-24T16:00:00.000Z</published>
    <updated>2020-01-25T12:44:12.654Z</updated>
    
    <content type="html"><![CDATA[<p>磁盘格式：<br>RAW：（裸格式）   //占用空间较大，性能较好，但不支持虚拟机快照功能<br>QCOW2：（copy on write）  //占用空间较小，支持快照，性能比RAW稍差一些</p><p>创建磁盘：（默认是裸格式）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@kvm disk]# qemu-img  create 1234.raw 5G</span><br></pre></td></tr></table></figure><p>查看磁盘信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@kvm disk]# qemu-img  info  1234.raw</span><br></pre></td></tr></table></figure><p>创建指定格式磁盘：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@kvm disk]# qemu-img  create  -f  qcow2  bdqn.qcow2 5G</span><br></pre></td></tr></table></figure><p>转换磁盘格式：<br>qemu-img  convert [-f fmt] [-O output_fmt] filename output_filename</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@kvm kvm-vm]# qemu-img  convert  -f  raw  -O  qcow2 centos.raw  centos.qcow2</span><br></pre></td></tr></table></figure><p>//转换之后原来的磁盘还在</p><p>拍摄快照：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@kvm ~]# virsh  snapshot-create  test01</span><br></pre></td></tr></table></figure><p>查看快照信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@kvm ~]# virsh  snapshot-list  test01</span><br><span class="line"> 名称               生成时间              状态</span><br><span class="line">------------------------------------------------------------</span><br><span class="line"> 1575254957           2019-12-02 10:49:17 +0800 running</span><br></pre></td></tr></table></figure><p>时间戳：1970年1月1号（计算机C语言诞生了，Linux系统诞生了）<br>32位系统：68年之后你的系统就不能使用了<br>64位系统：使用时间没有限制</p><p>根据快照恢复系统：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@kvm ~]# virsh  snapshot-revert  test01  1575254957</span><br></pre></td></tr></table></figure><p>//拍摄的快照是占用磁盘空间的</p>]]></content>
    
    <summary type="html">
    
      KVM
    
    </summary>
    
    
      <category term="KVM" scheme="http://yoursite.com/categories/KVM/"/>
    
    
  </entry>
  
  <entry>
    <title>KVM简介</title>
    <link href="http://yoursite.com/2020/01/25/KVM%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2020/01/25/KVM%E7%AE%80%E4%BB%8B/</id>
    <published>2020-01-24T16:00:00.000Z</published>
    <updated>2020-01-25T12:44:12.654Z</updated>
    
    <content type="html"><![CDATA[<p>KVM简介：<br>什么是云计算：<br>云计算:配置各种资源的方式</p><p>云计算的分类：<br>基础即服务Lass<br>平台即服务Pass<br>软件即服务Sass<br>如果按照不同的部署方式：公有云、私有云、混合云</p><p>KVM介绍：虚拟化的不同的方式</p><p>实现虚拟化的技术：<br>基于二进制翻译的全虚拟化：（会报错）<br>解决思路：<br>捕捉报错—-翻译—模拟（会增加服务器的开销）</p><p>半虚拟化（Xen）：更改内核，只能用到Linux系统上<br>全虚拟化：KVM、VMware<br>//所依赖的硬件全部准备好就行</p><p>KVM的概念：<br>基于内核的虚拟机（Kernel-Based VIrtul mathine）</p><p>打开KVM的方式：<br>virt-manager<br>应用程序–系统工具–虚拟系统管理器</p><p>命令创建虚拟主机域：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost iso]# virt-install  --os-type&#x3D;linux  --os-variant centos7.0</span><br><span class="line">--name test01  --ram 1024  --vcpus 1 --disk&#x3D;&#x2F;kvm-vm&#x2F;centos.raw,format&#x3D;raw,size&#x3D;10</span><br><span class="line">--location  &#x2F;iso&#x2F;CentOS-7-x86_64-DVD-1611.iso  </span><br><span class="line">--network  network&#x3D;default  --graphics  vnc,listen&#x3D;0.0.0.0  --noautoconsole（不会占用终端）</span><br></pre></td></tr></table></figure><p>vnc连接KVM虚拟机默认的端口为：5900</p>]]></content>
    
    <summary type="html">
    
      KVM
    
    </summary>
    
    
      <category term="KVM" scheme="http://yoursite.com/categories/KVM/"/>
    
    
  </entry>
  
  <entry>
    <title>KVM网络</title>
    <link href="http://yoursite.com/2020/01/25/KVM%E7%BD%91%E7%BB%9C/"/>
    <id>http://yoursite.com/2020/01/25/KVM%E7%BD%91%E7%BB%9C/</id>
    <published>2020-01-24T16:00:00.000Z</published>
    <updated>2020-01-25T12:44:12.654Z</updated>
    
    <content type="html"><![CDATA[<p>NAT模式：<br>KVM默认的网络方式，如果想要应用这种模式，防火墙需要打开，因为需要用到iptables规则</p><p>//打开防火墙添加规则，打开5900端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# firewall-cmd  --add-port&#x3D;5900&#x2F;tcp  --permanent </span><br><span class="line">success</span><br><span class="line">[root@localhost ~]# firewall-cmd  --reload</span><br><span class="line">success</span><br><span class="line">[root@localhost ~]# firewall-cmd   --list-all</span><br></pre></td></tr></table></figure><p>//添加路由转发：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# echo  net.ipv4.ip_forward &#x3D; 1  &gt;&gt;  &#x2F;etc&#x2F;sysctl.conf </span><br><span class="line">[root@localhost ~]# sysctl  -p</span><br><span class="line">net.ipv4.ip_forward &#x3D; 1</span><br></pre></td></tr></table></figure><p>总结：<br>nat模式支持主机与虚拟机的互访，也支持虚拟机访问互联网，但不支持外网访问虚拟机域</p><p>桥接网络：<br>1）创建虚拟桥接网卡br0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# systemctl  stop  NetworkManager</span><br><span class="line">[root@localhost ~]# virsh  iface-bridge  ens33  br0  &#x2F;&#x2F;提示失败不用理会</span><br><span class="line">使用附加设备 br0 生成桥接 ens33 失败</span><br><span class="line">已启动桥接接口 br0</span><br></pre></td></tr></table></figure><p>//查看配置文件会看到，ens33桥接到了br0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost network-scripts]# cat ifcfg-ens33</span><br><span class="line">DEVICE&#x3D;ens33</span><br><span class="line">ONBOOT&#x3D;yes</span><br><span class="line">BRIDGE&#x3D;&quot;br0&quot;</span><br><span class="line">[root@localhost network-scripts]# brctl  show</span><br><span class="line">bridge namebridge idSTP enabledinterfaces</span><br><span class="line">br08000.000c2901f11fyesens33</span><br><span class="line">virbr08000.525400dc381byesvirbr0-nic</span><br></pre></td></tr></table></figure><p>2）修改kvm虚拟机域的xml配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;interface type&#x3D;&#39;bridge&#39;&gt;</span><br><span class="line">&lt;mac address&#x3D;&#39;52:54:00:f8:a1:c9&#39;&#x2F;&gt;</span><br><span class="line">&lt;source bridge&#x3D;&#39;br0&#39;&#x2F;&gt;</span><br></pre></td></tr></table></figure><p>3）开启虚拟机，配置IP，验证是否能够联通外网:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vi  &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-eth</span><br></pre></td></tr></table></figure><p>//IP和br0的IP要在同一网段</p>]]></content>
    
    <summary type="html">
    
      KVM
    
    </summary>
    
    
      <category term="KVM" scheme="http://yoursite.com/categories/KVM/"/>
    
    
  </entry>
  
  <entry>
    <title>虚拟机的克隆</title>
    <link href="http://yoursite.com/2020/01/25/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%85%8B%E9%9A%86/"/>
    <id>http://yoursite.com/2020/01/25/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%85%8B%E9%9A%86/</id>
    <published>2020-01-24T16:00:00.000Z</published>
    <updated>2020-01-25T12:44:12.669Z</updated>
    
    <content type="html"><![CDATA[<p>克隆：<br>克隆的两种方式：<br>1、手动克隆（完整克隆）：<br>test01———-&gt;test02：（将test01克隆为test02）<br>1）复制xml配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cd  &#x2F;etc&#x2F;libvirt&#x2F;qemu&#x2F;</span><br><span class="line">[root@localhost qemu]# cp  test01.xml  test02.xml</span><br><span class="line">或者</span><br><span class="line">[root@kvm ~]# virsh   dumpxml  test01  &gt;  test02.xml</span><br></pre></td></tr></table></figure><p>2）复制磁盘文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost qemu]# cd  &#x2F;kvm-vm&#x2F;</span><br><span class="line">[root@localhost kvm-vm]# cp  centos.raw   test02.raw</span><br></pre></td></tr></table></figure><p>3）修改配置文件并重新生成一个虚拟机：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost kvm-vm]# cd  &#x2F;etc&#x2F;libvirt&#x2F;qemu&#x2F;</span><br><span class="line">[root@localhost qemu]# vim  test02.xml</span><br></pre></td></tr></table></figure><p>a:name字段<br>b:删除UUID<br>c:删除mac address<br>d:修改磁盘路径以及名称</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost qemu]# virsh   define  test02.xml</span><br></pre></td></tr></table></figure><p>链接克隆：<br>//做一个链接的磁盘，然后第二个新的虚拟机更改xml配置文件，磁盘信息指定新的链接磁盘</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost kvm-vm]# qemu-img  create  -f  qcow2  -b  centos.raw  test02.qcow2</span><br></pre></td></tr></table></figure><p>自动克隆（完整克隆）:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# virt-clone  --auto-clone -o  test02  -n test03</span><br></pre></td></tr></table></figure><p>//-o:表示克隆谁，-n：指定名称</p>]]></content>
    
    <summary type="html">
    
      KVM
    
    </summary>
    
    
      <category term="KVM" scheme="http://yoursite.com/categories/KVM/"/>
    
    
  </entry>
  
  <entry>
    <title>虚拟机的迁移</title>
    <link href="http://yoursite.com/2020/01/25/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E8%BF%81%E7%A7%BB/"/>
    <id>http://yoursite.com/2020/01/25/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E8%BF%81%E7%A7%BB/</id>
    <published>2020-01-24T16:00:00.000Z</published>
    <updated>2020-01-25T12:44:12.669Z</updated>
    
    <content type="html"><![CDATA[<p>虚拟机的迁移：</p><p>冷迁移（静态迁移）：  //服务器需要关闭<br>kvm01：192.168.1.100<br>kvm02：192.168.1.200</p><p>两台机器防火墙全部关闭，禁用selinux</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# lsmod |  grep  kvm  &#x2F;&#x2F;查看是否支持kvm</span><br><span class="line">[root@localhost ~]# systemctl  status  libvirtd  &#x2F;&#x2F;查看libvirtd服务是否正常</span><br></pre></td></tr></table></figure><p>//迁移和克隆差不多，都是需要对磁盘文件和xml配置文件进行操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@kvm01 ~]# scp  &#x2F;etc&#x2F;libvirt&#x2F;qemu&#x2F;test01.xml root@192.168.1.200:&#x2F;etc&#x2F;libvirt&#x2F;qemu </span><br><span class="line">[root@kvm01 ~]# scp  &#x2F;kvm-vm&#x2F;centos.raw   root@192.168.1.200:&#x2F;kvm-vm&#x2F;</span><br><span class="line">[root@kvm02 ~]# virsh  define   &#x2F;etc&#x2F;libvirt&#x2F;qemu&#x2F;test01.xml</span><br></pre></td></tr></table></figure><p>热迁移（动态迁移）：<br>删除所有的KVM虚拟机<br>kvm01：192.168.1.100<br>kvm02：192.168.1.200<br>NFS：192.168.1.129</p><p>1）在NFS服务器上面操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@NFS ~]# yum  -y  install  nfs-utils</span><br><span class="line">[root@NFS ~]# mkdir &#x2F;kvmshare  &#x2F;&#x2F;创建共享文件夹</span><br><span class="line">[root@NFS ~]# vim  &#x2F;etc&#x2F;exports  &#x2F;&#x2F;编辑共享文件夹权限</span><br><span class="line">[root@NFS ~]# cat &#x2F;etc&#x2F;exports</span><br><span class="line">&#x2F;kvmshare  *(rw,sync,no_root_squash)</span><br><span class="line">[root@NFS ~]# systemctl  start  rpcbind  &#x2F;&#x2F;远程传输控制协议</span><br><span class="line">[root@NFS ~]# systemctl  enable  rpcbind</span><br><span class="line">[root@NFS ~]# systemctl  start  nfs-server</span><br><span class="line">[root@NFS ~]# systemctl  enable  nfs-server</span><br></pre></td></tr></table></figure><p>//确保两台KVM服务器能看到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@kvm01 ~]# showmount  -e  192.168.1.129</span><br><span class="line">[root@kvm02 ~]# showmount  -e  192.168.1.129</span><br></pre></td></tr></table></figure><p>2）KVM01上基于NFS服务创建虚拟机<br>添加新的存储池：<br>名称：nfsshare<br>类型：netfs<br>目标路径：/opt/nfsshare（本机挂在的目录，目录默认没有，但会自己创建）<br>主机名:192.168.1.129（nfs-server IP address）<br>源路径：/kvmshare（nfs-server上的共享目录）</p><p>验证nfs服务是否正常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@kvm01 ~]# touch    &#x2F;opt&#x2F;nfsshare&#x2F;test</span><br><span class="line">[root@NFS ~]# ls  &#x2F;kvmshare&#x2F;</span><br><span class="line">test</span><br></pre></td></tr></table></figure><p>创建存储卷：<br>名称：centos7<br>最大容量：10G</p><p>//存储池和存储卷完成之后，直接创建虚拟机，并最小化安装<br>选择之前的创建的iso镜像以及刚才创建的存储池和存储卷</p><p>配置虚拟机使用bridge桥接网络，使其能够ping通外网，并且在这里我们执行一个ping百度的命令，并让他保持一直是ping着的状态，用来模拟迁移到kvm02上服务不中断：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@kvm01 ~]# virsh  destroy  centos7.0</span><br><span class="line">[root@kvm01 ~]# systemctl  stop  NetworkManager</span><br><span class="line">[root@kvm01 ~]# virsh  iface-bridge ens33  br0</span><br><span class="line">[root@kvm01 ~]# virsh  edit  centos7.0</span><br><span class="line">&lt;interface type&#x3D;&#39;bridge&#39;&gt;</span><br><span class="line">&lt;mac address&#x3D;&#39;52:54:00:12:80:97&#39;&#x2F;&gt;</span><br><span class="line">&lt;source bridge&#x3D;&#39;br0&#39;&#x2F;&gt;</span><br><span class="line">[root@kvm01 ~]# virsh  start  centos7.0</span><br></pre></td></tr></table></figure><p>配置IP为DHCP自动获取</p><p>在KVM02上操作，创建存储池：<br>名称：nfsshare<br>类型：netfs<br>目标路径：/opt/nfsshare（本机挂在的目录，目录默认没有，但会自己创建）<br>主机名:192.168.1.129（nfs-server IP address）<br>源路径：/kvmshare（nfs-server上的共享目录）<br>创建完之后会看到之前在KVM01上创建的test文件和centos.qcow2的存储卷</p><p>在KVM01上连接KVM02：<br>右上角—文件—添加连接—连接到远程主机—方法：ssh—用户名：root—-主机名：192.168.1.200（KVM02的IP）<br>会提示安装openssh-askpass，直接在KVM01和KVm02上安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@kvm01 ~]# yum  -y  install  openssh-askpass</span><br><span class="line">[root@kvm02 ~]# yum  -y  install  openssh-askpass</span><br></pre></td></tr></table></figure><p>//因为KVM01使用的是bridge br0网卡，所以我们需要在KVM02上创建同样的网卡br0，用来支持虚拟机</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@kvm02 ~]# systemctl  stop  NetworkManager</span><br><span class="line">[root@kvm02 ~]# virsh  iface-bridge  ens33  br0</span><br></pre></td></tr></table></figure><p>接下来直接在virt-manager管理器中迁移就可以了，迁移完成之后，保证我么的ping命令是不中断的，就表示实验完成了<br>右键centos7.0—迁移—地址：192.168.1.200（KVM02的IP）—高级选项—-勾选允许不可靠—-迁移<br>如果出现错误解决办法：<br>把KVM01和KVM02上挂载的目录给一个777的权限，保证双方root用户有权限调用目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@kvm01 ~]# chmod  777  &#x2F;opt&#x2F;</span><br><span class="line">[root@kvm02 ~]# chmod  777  &#x2F;opt&#x2F;</span><br></pre></td></tr></table></figure><p>迁移完成后在KVM02上面查看ping命令是否中断</p>]]></content>
    
    <summary type="html">
    
      KVM
    
    </summary>
    
    
      <category term="KVM" scheme="http://yoursite.com/categories/KVM/"/>
    
    
  </entry>
  
  <entry>
    <title>KVM基本操作命令</title>
    <link href="http://yoursite.com/2020/01/25/KVM%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2020/01/25/KVM%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/</id>
    <published>2020-01-24T16:00:00.000Z</published>
    <updated>2020-01-25T12:44:12.669Z</updated>
    
    <content type="html"><![CDATA[<p>基于操作命令<br>1）查看虚拟机列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@kvm ~]# virsh  list   &#x2F;&#x2F;查看正在运行的虚拟机</span><br><span class="line">[root@kvm ~]# virsh   list  --all   &#x2F;&#x2F;查看所有虚拟机</span><br></pre></td></tr></table></figure><p>//开机的虚拟机才有ID号，而且会随时变化<br> Id    名称                         状态</p><hr><ul><li>test01                         关闭</li></ul><p>2）查看虚拟机的详细信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@kvm ~]# virsh   dominfo  test01     &#x2F;&#x2F;dom全称domain，域的意思</span><br><span class="line">Id:             -</span><br><span class="line">名称：       test01</span><br><span class="line">UUID:           8ba94166-08dd-4805-962b-c99ed56869bc</span><br><span class="line">OS 类型：    hvm</span><br><span class="line">状态：       关闭</span><br><span class="line">CPU：          1</span><br><span class="line">最大内存： 1048576 KiB</span><br><span class="line">使用的内存： 1048576 KiB</span><br><span class="line">持久（peisistent）：       是    &#x2F;&#x2F;数据的持久化</span><br><span class="line">自动启动（autostart）： 禁用   &#x2F;&#x2F;是否开机自启</span><br><span class="line">管理的保存： 否</span><br><span class="line">安全性模式： none</span><br><span class="line">安全性 DOI： 0</span><br></pre></td></tr></table></figure><p>3）虚拟机域的开关机：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@kvm ~]# virsh  start  test01   &#x2F;&#x2F;开机</span><br><span class="line">[root@kvm ~]# virsh  shutdown  test01  &#x2F;&#x2F;关机（shutdown：温柔的关机）</span><br><span class="line">[root@kvm ~]# virsh  shutdown  2    &#x2F;&#x2F;2为ID号</span><br></pre></td></tr></table></figure><p>//关机后再开机ID号也会变化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@kvm ~]# virsh   destroy  test01  &#x2F;&#x2F;强制关机，类似于拔电源</span><br></pre></td></tr></table></figure><p>4）导出配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@kvm ~]# virsh   dumpxml  test01  &gt;  test01.xml    &#x2F;&#x2F;dump备份的意思</span><br></pre></td></tr></table></figure><p>vmnet0：桥接   //好处：外网能够访问你的虚拟机<br>vmnet1：主机<br>vmnet8：NAT   //缺点：外网访问不了你的虚拟机，好处：可以自己随意指定IP</p><p>一个完成的KVM域，生成之后会有两个文件：<br>    1）磁盘文件：在部署之处已经指定   //用来记录它的信息<br>    2）xml配置文件，默认在/etc/libvirt/qemu   //qemu模拟硬件，类型为raw</p><p>5）删除虚拟机：<br>//删除之前保证虚拟机是关闭状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@kvm ~]# virsh  undefine  test01    &#x2F;&#x2F;undefine取消定义</span><br></pre></td></tr></table></figure><p>//xml配置文件也会被删除，但是磁盘文件不会被影响</p><p>6）根据配置文件恢复虚拟机：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@kvm ~]# virsh  define  test01.xml    &#x2F;&#x2F;define：定义</span><br></pre></td></tr></table></figure><p>7）修改配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@kvm qemu]# virsh   edit  test01</span><br></pre></td></tr></table></figure><p>edit：自带语法检查功能（y：是、n：不、i：忽略、f：强制）<br>vim：不会提示你语法错误</p><p>8）虚拟机重命名（7.2版本之前的不支持这条命令）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@kvm ~]# virsh  domrename  test01   test1   &#x2F;&#x2F;重命名前关闭虚拟机</span><br></pre></td></tr></table></figure><p>9）查看虚拟机对应的vnc端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# virsh  vncdisplay  test01</span><br><span class="line">:0</span><br></pre></td></tr></table></figure><p>:0等于5900<br>:1=5901<br>:2=5902</p><p>10)挂起虚拟机</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# virsh suspend  test01</span><br><span class="line">[root@localhost ~]# virsh  resume  test01   &#x2F;&#x2F;恢复挂起的虚拟机</span><br></pre></td></tr></table></figure><p>11）开机自启</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# virsh  autostart  test01</span><br><span class="line">[root@localhost autostart]# virsh  autostart  --disable  test01  &#x2F;&#x2F;取消开机自启</span><br></pre></td></tr></table></figure><p>12）console登录KVM域<br>//在KVM域里添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grubby  --update-kernel&#x3D;ALL  --args&#x3D;&quot;console&#x3D;ttyS0&quot;</span><br><span class="line">reboot</span><br><span class="line">virsh console  test01    &#x2F;&#x2F;使用xshell连接kvm</span><br><span class="line">退出 ctrl+]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      KVM
    
    </summary>
    
    
      <category term="KVM" scheme="http://yoursite.com/categories/KVM/"/>
    
    
  </entry>
  
  <entry>
    <title>Deployment</title>
    <link href="http://yoursite.com/2020/01/24/Deployment/"/>
    <id>http://yoursite.com/2020/01/24/Deployment/</id>
    <published>2020-01-23T16:00:00.000Z</published>
    <updated>2020-01-25T13:00:22.041Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a><strong>Deployment</strong></h3><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: extensions&#x2F;v1beta1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: test-web</span><br><span class="line">spec:</span><br><span class="line">  replicas: 4</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app:  web</span><br><span class="line">   spec:</span><br><span class="line">     containers:</span><br><span class="line">     - name: test-web</span><br><span class="line">       image:  192.168.1.70:5000&#x2F;httpd:v1</span><br><span class="line">       ports:</span><br><span class="line">       - containerPort:  80</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>PS：注意，在Deployment资源对象中，可以添加Port字段，但此字段仅供用户查看，并不实际生效</p><h3 id="service"><a href="#service" class="headerlink" title="service"></a><strong>service</strong></h3><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">kind: Service</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  name: web-svc</span><br><span class="line">spec:</span><br><span class="line">  type: NodePort</span><br><span class="line">  selector:</span><br><span class="line">    app:  web</span><br><span class="line">  ports:</span><br><span class="line">  - protocol: TCP</span><br><span class="line">    port: 80  &#x2F;&#x2F;clusterIP的端口</span><br><span class="line">    targetPort: 80  &#x2F;&#x2F;Pod的端口</span><br><span class="line">    nodePort: 30123</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>SNAT：Source NAT（源地址转换）</p><p>DNAT：Destination NAT（目标地址转换）</p><p>MASQ：动态的源地址转换</p><p>service实现的负载均衡：默认使用的是iptables规则</p><p>第二种方案：IPVS</p><h3 id="回滚到指定版本"><a href="#回滚到指定版本" class="headerlink" title="回滚到指定版本"></a><strong>回滚到指定版本</strong></h3><hr><p>准备三个版本所使用的私有镜像，来模拟每次升级到不同的镜像</p><p>Deployment1.yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# vim  deployment1.yaml</span><br><span class="line">apiVersion: extensions&#x2F;v1beta1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: test-web</span><br><span class="line">spec:</span><br><span class="line">  revisionHistoryLimit: 10</span><br><span class="line">  replicas: 3</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app:  web</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: test-web</span><br><span class="line">        image:  192.168.1.70:5000&#x2F;httpd:v1</span><br><span class="line">        ports:</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>Deployment2.yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# vim  deployment2.yaml</span><br><span class="line">apiVersion: extensions&#x2F;v1beta1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: test-web</span><br><span class="line">spec:</span><br><span class="line">  revisionHistoryLimit: 10</span><br><span class="line">  replicas: 3</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app:  web</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: test-web</span><br><span class="line">        image:  192.168.1.70:5000&#x2F;httpd:v2</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort:  80</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>Deployment3.yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# vim  deployment3.yaml</span><br><span class="line">apiVersion: extensions&#x2F;v1beta1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: test-web</span><br><span class="line">spec:</span><br><span class="line">  revisionHistoryLimit: 10</span><br><span class="line">  replicas: 3</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app:  web</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: test-web</span><br><span class="line">        image:  192.168.1.70:5000&#x2F;httpd:v3</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort:  80</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>此处3个yaml文件，指定不同版本的镜像</p><p>//运行一个服务，并记录一个版本信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# kubectl apply  -f  deployment1.yaml  --record</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//查看有哪些版本信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# kubectl  rollout history deployment test-web</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//运行并升级Deployment资源，并记录版本信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# kubectl  apply  -f  deployment2.yaml --record</span><br><span class="line">[root@master ~]# kubectl  apply  -f  deployment3.yaml --record</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//此时可以运行一个关联的Service资源去验证升级是否成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# kubectl  apply -f  web-svc.yaml</span><br><span class="line">[root@master ~]# curl  10.96.179.50</span><br><span class="line">&lt;h1&gt;zhb | test-web | httpd | v3&lt;h1&gt;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//回滚到指定版本</p><h3 id="用label控制Pod的位置"><a href="#用label控制Pod的位置" class="headerlink" title="用label控制Pod的位置"></a><strong>用label控制Pod的位置</strong></h3><hr><p>//添加节点你标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# kubectl label nodes node02 disk&#x3D;ssd</span><br><span class="line">[root@master ~]# kubectl get nodes --show-labels | grep node02</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: extensions&#x2F;v1beta1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: test-web</span><br><span class="line">spec:</span><br><span class="line">  revisionHistoryLimit: 10  &#x2F;&#x2F;版本历史限制</span><br><span class="line">  replicas: 3</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app:  web</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: test-web</span><br><span class="line">        image:  192.168.1.70:5000&#x2F;httpd:v1</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort:  80</span><br><span class="line">      nodeSelector:  &#x2F;&#x2F;添加节点选择器</span><br><span class="line">        disk: ssd   &#x2F;&#x2F;和标签内容一致</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# kubectl  get  pod  -o  wide</span><br><span class="line">NAME                       READY   STATUS    RESTARTS   AGE   IP            NODE     NOMINATED NODE   READINESS GATES</span><br><span class="line">test-web-d58c9f847-bhswj   1&#x2F;1     Running   0          28s   10.244.2.14   node02   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">test-web-d58c9f847-k58nj   1&#x2F;1     Running   0          28s   10.244.2.13   node02   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">test-web-d58c9f847-vt7r5   1&#x2F;1     Running   0          28s   10.244.2.15   node02   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//删除节点标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# kubectl  label nodes node02  disk-</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>]]></content>
    
    <summary type="html">
    
      K8s
    
    </summary>
    
    
      <category term="k8s" scheme="http://yoursite.com/categories/k8s/"/>
    
    
      <category term="k8s" scheme="http://yoursite.com/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>Docker三剑客之docker-compose+wordpress的博客搭建</title>
    <link href="http://yoursite.com/2020/01/24/Docker%E4%B8%89%E5%89%91%E5%AE%A2%E4%B9%8Bdocker-compose+wordpress%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2020/01/24/Docker%E4%B8%89%E5%89%91%E5%AE%A2%E4%B9%8Bdocker-compose+wordpress%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</id>
    <published>2020-01-23T16:00:00.000Z</published>
    <updated>2020-01-25T08:55:18.322Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker三剑客之docker-compose"><a href="#Docker三剑客之docker-compose" class="headerlink" title="Docker三剑客之docker-compose"></a><strong>Docker三剑客之docker-compose</strong></h1><p>docker容器的编排工具：</p><p>解决相互有依赖关系的多个容器的管理</p><p>//验证已有docker-compose命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker-compose  -v</span><br><span class="line">docker-compose version 1.25.0, build 0a186604</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>docker-compose的配置文件实例</p><p>通过识别一个docker-compose.yml的配置文件，去管理容器</p><p>//设置tab键的空格数量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim .vimrc</span><br><span class="line">set  tabstop&#x3D;2</span><br><span class="line">[root@localhost ~]# source  .vimrc</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mkdir  compose_test</span><br><span class="line">[root@localhost ~]# cd  compose_test&#x2F;</span><br><span class="line">[root@localhost compose_test]# vim docker-compose.yml</span><br><span class="line">version:  &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line">  nginx:</span><br><span class="line">    container_name: web-nginx</span><br><span class="line">    image:  nginx</span><br><span class="line">    restart:  always</span><br><span class="line">    ports:</span><br><span class="line">      - 90:80</span><br><span class="line">    volumes:</span><br><span class="line">      - .&#x2F;webserver:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>第一个部分：version：指定格式的版本</p><p>第二部分：services：定义服务，（想要运行什么样的容器）</p><p>//运行docker-compose规定的容器：</p><p>PS：在执行这条命令的当前目录下，也需要有一个docker-compose.yml的配置文件，并且通常只有一个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost compose_test]# docker-compose  up  -d</span><br><span class="line">[root@localhost compose_test]# cd  webserver&#x2F;</span><br><span class="line">[root@localhost webserver]# echo  123456  &gt;  index.html</span><br><span class="line">[root@localhost webserver]# curl  127.0.0.1:90</span><br><span class="line">123456</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//停止运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost compose_test]# docker-compose  stop</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//重启</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost compose_test]# docker-compose  restart</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//如果在当前目录没有docker-compose.yml这个文件，可以通过-f来指定docker-compose.yml文件位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker-compose  -f compose_test&#x2F;docker-compose.yml  start</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>并且，在运行container的过程中，还可以支持Dockerfile</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost compose_test]# vim  Dockerfile</span><br><span class="line">[root@localhost compose_test]# cat Dockerfile </span><br><span class="line">FROM nginx</span><br><span class="line">ADD webserver &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;htm</span><br><span class="line">[root@localhost compose_test]# vim  docker-compose.yml</span><br><span class="line">version:  &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line">  nginx:</span><br><span class="line">    build:  .</span><br><span class="line">    container_name: web-nginx</span><br><span class="line">    image:  new-nginx:v1.0</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">      - 90:80</span><br><span class="line">[root@localhost compose_test]# docker-compose  stop</span><br><span class="line">[root@localhost compose_test]# docker-compose  rm</span><br><span class="line">[root@localhost compose_test]# docker-compose  up  -d</span><br><span class="line">[root@localhost compose_test]# curl  127.0.0.1:90</span><br><span class="line">123456</span><br><span class="line">[root@localhost compose_test]# cd  webserver&#x2F;</span><br><span class="line">[root@localhost webserver]# echo  654321  &gt;  index.html </span><br><span class="line">[root@localhost webserver]# curl  127.0.0.1:90</span><br><span class="line">123456</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="搭建wordpress的博客"><a href="#搭建wordpress的博客" class="headerlink" title="搭建wordpress的博客"></a><strong>搭建wordpress的博客</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mkdir  wordpress</span><br><span class="line">[root@localhost ~]# docker  load  &lt;  wordpress.tar</span><br><span class="line">[root@localhost ~]# cd  wordpress&#x2F;</span><br><span class="line">[root@localhost wordpress]# vim  docker-compose.yml</span><br><span class="line">version:  &quot;3.1&quot;</span><br><span class="line">services:</span><br><span class="line">  wordpress:</span><br><span class="line">    image: wordpress</span><br><span class="line">    restart:  always</span><br><span class="line">    ports:</span><br><span class="line">      - 8080:80</span><br><span class="line">    environment:</span><br><span class="line">      WORDPRESS_DB_HOST:  db</span><br><span class="line">      WORDPRESS_DB_USER:  wordpress</span><br><span class="line">      WORDPRESS_DB_PASSWORD:  123.com</span><br><span class="line">      WORDPRESS_DB_NAME:  wordpress</span><br><span class="line">  db:</span><br><span class="line">    image:  mysql:5.7</span><br><span class="line">    restart:  always</span><br><span class="line">    environment:</span><br><span class="line">      MYSQL_DATABASE:  wordpress</span><br><span class="line">      MYSQL_USER: wordpress</span><br><span class="line">      MYSQL_PASSWORD:  123.com</span><br><span class="line">      MYSQL_ROOT_PASSWORD:  123.com</span><br><span class="line">[root@localhost wordpress]# docker-compose  up  -d</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//浏览器访问本机的8080端口：（192.168.1.70:8080）</p><p><img src="https://img-blog.csdnimg.cn/20200117104852120.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTYzNjcwMg==,size_16,color_FFFFFF,t_70" alt="img">)<img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/2020011710490388.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTYzNjcwMg==,size_16,color_FFFFFF,t_70" alt="img">)<img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/20200117104915442.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTYzNjcwMg==,size_16,color_FFFFFF,t_70" alt="img">)<img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/20200117104925510.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTYzNjcwMg==,size_16,color_FFFFFF,t_70" alt="img">)<img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>]]></content>
    
    <summary type="html">
    
      Docker
    
    </summary>
    
    
      <category term="Docker" scheme="http://yoursite.com/categories/Docker/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker实现服务发现</title>
    <link href="http://yoursite.com/2020/01/24/Docker%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/"/>
    <id>http://yoursite.com/2020/01/24/Docker%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/</id>
    <published>2020-01-23T16:00:00.000Z</published>
    <updated>2020-01-25T08:55:01.586Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker实现服务发现"><a href="#Docker实现服务发现" class="headerlink" title="Docker实现服务发现"></a>Docker实现服务发现</h1><h2 id="Docker-Consul-registrator实现服务发现"><a href="#Docker-Consul-registrator实现服务发现" class="headerlink" title="Docker + Consul + registrator实现服务发现"></a>Docker + Consul + registrator实现服务发现</h2><blockquote><p>Consul：分布式、高可用的，服务发现和配置的工具，数据中心</p><p>Registrator：负责收集dockerhost上，容器服务的信息，并且发送给consul</p><p>Consul-template：根据编辑好的模板生成新的nginx配置文件，并且负责加载nginx配置文件</p></blockquote><p>实验环境</p><table><thead><tr><th>docker01</th><th>192.168.1.70</th></tr></thead><tbody><tr><td>docker02</td><td>192.168.1.60</td></tr><tr><td>docker03</td><td>192.168.1.50</td></tr></tbody></table><p>关闭防火墙和selinux，并修改主机名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# systemctl  stop  firewalld</span><br><span class="line">[root@localhost ~]# setenforce  0</span><br><span class="line">[root@localhost ~]# hostnamectl  set-hostname   docker01</span><br><span class="line">[root@localhost ~]# su -</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>1）docker01上，启动consul服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# unzip  consul_1.5.1_linux_amd64.zip</span><br><span class="line">[root@docker01 ~]# mv  consul  &#x2F;usr&#x2F;local&#x2F;bin&#x2F;</span><br><span class="line">[root@docker01 ~]# chmod  +x  &#x2F;usr&#x2F;local&#x2F;bin&#x2F;consul</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//以二进制的方式部署consul，并启动，身份为leader</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# consul  agent  -server  -bootstrap  \</span><br><span class="line">&gt;  -ui  -data-dir&#x3D;&#x2F;var&#x2F;lib&#x2F;consul-data  \</span><br><span class="line">&gt;  -bind&#x3D;192.168.1.70  \</span><br><span class="line">&gt;  -client&#x3D;0.0.0.0  \</span><br><span class="line">&gt;  -node&#x3D;master</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//这时这个命令会占用终端，可以使用nohup命令让它保持后台运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# nohup consul  agent  -server  -bootstrap   -ui  -data-dir&#x3D;&#x2F;var&#x2F;lib&#x2F;consul-data   -bind&#x3D;192.168.1.70   -client&#x3D;0.0.0.0   -node&#x3D;master  &amp;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>PS:</p><blockquote><p>-bootstrap：加入这个选项时，一般都在server单节点的时候用，自选举为leader</p><p>-ui：开启内部web界面</p><p>-data-dir：key/volume数据存储位置</p><p>-bind：指定开启服务的IP</p><p>-client：指定访问的客户端</p><p>-node：只当集群内通信使用的名称，默认是用主机名命名的</p></blockquote><p>PS：开启的端口</p><blockquote><p>8300：集群节点</p><p>8301：集群内部的访问</p><p>8302：跨数据中心的通信</p><p>8500：web ui界面</p><p>8600：使用dns协议查看节点信息的端口</p></blockquote><p>//查看conusl的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# consul info</span><br><span class="line">leader_addr &#x3D; 192.168.1.70:8300  &#x2F;&#x2F;这个对我们比较有用，其他的都是一些它的算法</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//查看集群内成员的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# consul  members</span><br><span class="line">Node    Address            Status  Type    Build  Protocol  DC   Segment</span><br><span class="line">master  192.168.1.70:8301  alive   server  1.5.1  2         dc1  &lt;all&gt;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>2）docker02、docker03，加入consul集群</p><blockquote><p>这里我们采用容器的方式去运行consul服务</p></blockquote><p>//docker02</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@docker02 ~]# docker  load  &lt;  myprogrium-consul.tar</span><br><span class="line">[root@docker02 ~]# docker run  -d  --name  consul  -p  8301:8301  -p   8301:8301&#x2F;udp  -p  8500:8500  -p  8600:8600  -p  8600:8600&#x2F;udp  --restart  always  progrium&#x2F;consul:latest  -join   192.168.1.70  -advertise  192.168.1.60  -client  0.0.0.0  -node&#x3D;node01</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//docker03</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@docker03 ~]# docker load  &lt;  myprogrium-consul.tar</span><br><span class="line">[root@docker03 ~]# docker run  -d  --name  consul  -p  8301:8301  -p   8301:8301&#x2F;udp  -p  8500:8500  -p  8600:8600  -p  8600:8600&#x2F;udp  --restart  always  progrium&#x2F;consul:latest  -join   192.168.1.70  -advertise  192.168.1.50  -client  0.0.0.0  -node&#x3D;node02</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//在docker01上就能看到加入的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2019&#x2F;12&#x2F;26 09:50:25 [INFO] serf: EventMemberJoin: node01 192.168.1.60</span><br><span class="line">2019&#x2F;12&#x2F;26 09:50:25 [INFO] consul: member &#39;node01&#39; joined, marking health alive</span><br><span class="line">2019&#x2F;12&#x2F;26 09:53:06 [INFO] serf: EventMemberJoin: node02 192.168.1.50</span><br><span class="line">2019&#x2F;12&#x2F;26 09:53:06 [INFO] consul: member &#39;node02&#39; joined, marking health alive</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# consul  members</span><br><span class="line">Node    Address            Status  Type    Build  Protocol  DC   Segment</span><br><span class="line">master  192.168.1.70:8301  alive   server  1.5.1  2         dc1  &lt;all&gt;</span><br><span class="line">node01  192.168.1.60:8301  alive   client  0.5.2  2         dc1  &lt;default&gt;</span><br><span class="line">node02  192.168.1.50:8301  alive   client  0.5.2  2         dc1  &lt;default&gt;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//浏览器访问consul服务，验证集群信息</p><p>192.168.1.70:8500</p><p><img src="https://img-blog.csdnimg.cn/20200120154827274.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTYzNjcwMg==,size_16,color_FFFFFF,t_70" alt="img">)<img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>3)下载部署consul-template</p><p>//在docker01上导入consul-template_0.19.5_linux_amd64.zip</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# unzip  consul-template_0.19.5_linux_amd64.zip</span><br><span class="line">[root@docker01 ~]# mv  consul-template  &#x2F;usr&#x2F;local&#x2F;bin&#x2F;</span><br><span class="line">[root@docker01 ~]# chmod  +x  &#x2F;usr&#x2F;local&#x2F;bin&#x2F;consul-template</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>4）docker02、docker03上部署registrator服务</p><blockquote><p>registrator是一个能自动发现docker container提供的服务，并在后端服务注册中心注册服务或取消服务的工具，后端注册中心支持consul、etcd、skydns2、zookeeper等</p></blockquote><p>//docker02</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@docker02 ~]# docker  load  &lt;  myregistrator.tar</span><br><span class="line">[root@docker02 ~]# docker  run  -d  \</span><br><span class="line">&gt;  --name  registrator  \</span><br><span class="line">&gt;  -v  &#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;tmp&#x2F;docker.sock  \</span><br><span class="line">&gt;  --restart  always  \</span><br><span class="line">&gt;  gliderlabs&#x2F;registrator  \</span><br><span class="line">&gt;  consul:&#x2F;&#x2F;192.168.1.60:8500</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//运行一个nginx容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@docker02 ~]# docker  run  -d  -P  --name  test  nginx:latest</span><br><span class="line">b0665dcbd6c5        nginx:latest             &quot;nginx -g &#39;daemon of…&quot;   10 seconds ago      Up 9 seconds        0.0.0.0:32768-&gt;80&#x2F;tcp </span><br><span class="line">&#x2F;&#x2F;映射的端口为32768</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//回到浏览器</p><p><img src="https://img-blog.csdnimg.cn/20200120154937829.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTYzNjcwMg==,size_16,color_FFFFFF,t_70" alt="img">)<img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/2020012015495010.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTYzNjcwMg==,size_16,color_FFFFFF,t_70" alt="img">)<img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//docker03</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@docker03 ~]# docker load  &lt;  myregistrator.tar</span><br><span class="line">[root@docker02 ~]# docker  run  -d  \</span><br><span class="line">&gt;  --name  registrator  \</span><br><span class="line">&gt;  -v  &#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;tmp&#x2F;docker.sock  \</span><br><span class="line">&gt;  --restart  always  \</span><br><span class="line">&gt;  gliderlabs&#x2F;registrator  \</span><br><span class="line">&gt;  consul:&#x2F;&#x2F;192.168.1.50:8500</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/20200120155011206.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTYzNjcwMg==,size_16,color_FFFFFF,t_70" alt="img">)<img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>5）docker01部署一个nginx服务</p><p>//依赖环境</p><p>[root@docker01 ~]# yum -y install zlib-devel openssl-devel pcre-devel</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# useradd  -M  -s  &#x2F;sbin&#x2F;nologin  nginx</span><br><span class="line">[root@docker01 ~]# tar  zxf  nginx-1.14.0.tar.gz </span><br><span class="line">[root@docker01 ~]# cd  nginx-1.14.0&#x2F;</span><br><span class="line">[root@docker01 nginx-1.14.0]# .&#x2F;configure  --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx  \</span><br><span class="line">&gt;  --user&#x3D;nginx  --group&#x3D;nginx  \</span><br><span class="line">&gt;  --with-http_stub_status_module  \</span><br><span class="line">&gt;  --with-http_realip_module  \</span><br><span class="line">&gt;  --with-pcre  --with-http_ssl_module</span><br><span class="line">[root@docker01 nginx-1.14.0]# make  &amp;&amp;  make  install</span><br><span class="line">[root@docker01 nginx-1.14.0]# ln  -s  &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;*   &#x2F;usr&#x2F;local&#x2F;sbin&#x2F;</span><br><span class="line">[root@docker01 nginx-1.14.0]# nginx  -t</span><br><span class="line">nginx: the configuration file &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf test is successful</span><br><span class="line">[root@docker01 nginx-1.14.0]# nginx</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>PS：</p><blockquote><p>这里nginx作为反向代理，代理后端docker02、docker03上nignx的容器服务，所以我们先去docker02、docker03上部署一些服务，为了方便等会看到负载的效果，所以我们运行完成容器之后，做一个主界面内容的区分</p></blockquote><blockquote><p>docker02：web01 web02</p><p>docker03：web03 web04</p></blockquote><p>//docker02</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@docker02 ~]# docker  run  -itd  --name  web01  -P  nginx:latest </span><br><span class="line">[root@docker02 ~]# docker exec  -it  web01   &#x2F;bin&#x2F;bash</span><br><span class="line">root@dac0cc15f3fe:&#x2F;# cd  &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;</span><br><span class="line">root@dac0cc15f3fe:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html# echo  &quot;This web caontainer in dockek02-web01&quot;  &gt;  index.html </span><br><span class="line">root@dac0cc15f3fe:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html# cat  index.html </span><br><span class="line">This web caontainer in dockek02-web01</span><br><span class="line">[root@docker02 ~]# docker  run  -itd   --name  web02  -P  nginx:latest </span><br><span class="line">[root@docker02 ~]# docker exec  -it  web02  &#x2F;bin&#x2F;bash</span><br><span class="line">root@26d622553e5e:&#x2F;# cd  &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;</span><br><span class="line">root@26d622553e5e:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html# echo  &quot;This web caontainer in dockek02-web02&quot;  &gt;  index.html </span><br><span class="line">root@26d622553e5e:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html# cat  index.html </span><br><span class="line">This web caontainer in dockek02-web02</span><br><span class="line">[root@docker02 ~]# curl  127.0.0.1:32769</span><br><span class="line">This web caontainer in dockek02-web01</span><br><span class="line">[root@docker02 ~]# curl  127.0.0.1:32770</span><br><span class="line">This web caontainer in dockek02-web02</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//docker03</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@docker03 ~]# docker run  -itd  --name  web03  -P  nginx:latest </span><br><span class="line">[root@docker03 ~]# docker exec -it  web03  &#x2F;bin&#x2F;bash</span><br><span class="line">root@a10f25a91edf:&#x2F;# cd  &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;</span><br><span class="line">root@a10f25a91edf:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html# echo  &quot;This web caontainer in dockek03-web03&quot;  &gt;  index.html </span><br><span class="line">root@a10f25a91edf:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html# cat  index.html </span><br><span class="line">This web caontainer in dockek03-web03</span><br><span class="line">[root@docker03 ~]# docker run  -itd  --name  web04  -P  nginx:latest </span><br><span class="line">[root@docker03 ~]# docker exec -it  web04  &#x2F;bin&#x2F;bash</span><br><span class="line">root@6d30a445c9b8:&#x2F;# cd  &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;</span><br><span class="line">root@6d30a445c9b8:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html# echo  &quot;his web caontainer in dockek03-web04&quot;  &gt;  index.html </span><br><span class="line">root@6d30a445c9b8:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html# cat  index.html   </span><br><span class="line">This web caontainer in dockek03-web04</span><br><span class="line">[root@docker03 ~]# curl  127.0.0.1:32768</span><br><span class="line">This web caontainer in dockek03-web03</span><br><span class="line">[root@docker03 ~]# curl  127.0.0.1:32769</span><br><span class="line">This web caontainer in dockek03-web04</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>更改nginx的配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# cd  &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;</span><br><span class="line">[root@docker01 nginx]# mkdir  consul</span><br><span class="line">[root@docker01 nginx]# cd  consul&#x2F;</span><br><span class="line">[root@docker01 consul]# pwd</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;consul</span><br><span class="line">[root@docker01 consul]# vim  nginx.ctmpl</span><br><span class="line">[root@docker01 consul]# cat  nginx.ctmpl </span><br><span class="line">upstream  httpd_backend &#123;</span><br><span class="line">&#123;&#123;range service &quot;nginx&quot;&#125;&#125;</span><br><span class="line">server &#123;&#123; .Address &#125;&#125;:&#123;&#123; .Port &#125;&#125;;</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">listen  8000;</span><br><span class="line">server_name  localhost;</span><br><span class="line">location  &#x2F; &#123;</span><br><span class="line">proxy_pass  http:&#x2F;&#x2F;http_backend;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">[root@docker01 ~]# vim  &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf</span><br><span class="line">&#x2F;&#x2F;在文件最后，也就是倒数第二行添加：</span><br><span class="line">include  &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;consul&#x2F;*.conf;</span><br><span class="line">&#x2F;&#x2F;使nginx的主配置文件能够识别到新产生的配置文件</span><br><span class="line">[root@docker01 ~]# nginx  -s  reload</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//使用consul-template命令，根据模板生产的配置文件，并重新加载nginx的配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 consul]# consul-template -consul-addr 192.168.1.70:8500 -template &quot;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;consul&#x2F;nginx.ctmpl:&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;consul&#x2F;vhost.conf:&#x2F;usr&#x2F;local&#x2F;sbin&#x2F;nginx  -s  reload&quot;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//这时这个命令会占用终端，可以使用nohup命令让它保持后台运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 consul]# nohup  consul-template -consul-addr 192.168.1.70:8500 -template &quot;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;consul&#x2F;nginx.ctmpl:&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;consul&#x2F;vhost.conf:&#x2F;usr&#x2F;local&#x2F;sbin&#x2F;nginx  -s  reload&quot;  &amp;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//此时，应该能够看到，新生产的vhost.conf配置文件已经生效，访问本机的8000端口可以得到不同容器提供的服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# cd  &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;consul&#x2F;</span><br><span class="line">[root@docker01 consul]# ls</span><br><span class="line">nginx.ctmpl  vhost.conf</span><br><span class="line">[root@docker01 consul]# cat  vhost.conf</span><br><span class="line">upstream  httpd_backend &#123;</span><br><span class="line"></span><br><span class="line">server 192.168.1.60:32768;</span><br><span class="line"></span><br><span class="line">server 192.168.1.60:32769;</span><br><span class="line"></span><br><span class="line">server 192.168.1.60:32770;</span><br><span class="line"></span><br><span class="line">server 192.168.1.50:32768;</span><br><span class="line"></span><br><span class="line">server 192.168.1.50:32769;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen  8000;</span><br><span class="line">    server_name  localhost;</span><br><span class="line">    location  &#x2F; &#123;</span><br><span class="line">    proxy_pass  http:&#x2F;&#x2F;httpd_backend;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 consul]# curl  localhost:8000</span><br><span class="line">This web caontainer in dockek02-web01</span><br><span class="line">[root@docker01 consul]# curl  localhost:8000</span><br><span class="line">This web caontainer in dockek02-web02</span><br><span class="line">[root@docker01 consul]# curl  localhost:8000</span><br><span class="line">This web caontainer in dockek03-web03</span><br><span class="line">[root@docker01 consul]# curl  localhost:8000</span><br><span class="line">This web caontainer in dockek03-web04</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><blockquote><p>当然，这时不管是添加新的nginx的web容器，或是删除，生产的配置文件都会时时更新，这是我们在运行consul-template这条命令最后添加：/usr/local/sbin/nginx -s reload它的作用</p></blockquote><p>//删除之前的test容器，查看vhost文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@docker02 ~]# docker rm  -f  test</span><br><span class="line">[root@docker01 consul]# cat  vhost.conf </span><br><span class="line">upstream  httpd_backend &#123;</span><br><span class="line"></span><br><span class="line">server 192.168.1.60:32769;</span><br><span class="line"></span><br><span class="line">server 192.168.1.60:32770;</span><br><span class="line"></span><br><span class="line">server 192.168.1.50:32768;</span><br><span class="line"></span><br><span class="line">server 192.168.1.50:32769;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//在运行一个web05，查看vhost文件的变化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@docker02 ~]# docker  run  -itd  --name  web05 -P nginx:latest </span><br><span class="line">upstream  httpd_backend &#123;</span><br><span class="line"></span><br><span class="line">server 192.168.1.60:32769;</span><br><span class="line"></span><br><span class="line">server 192.168.1.60:32770;</span><br><span class="line"></span><br><span class="line">server 192.168.1.60:32771;</span><br><span class="line"></span><br><span class="line">server 192.168.1.50:32768;</span><br><span class="line"></span><br><span class="line">server 192.168.1.50:32769;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/20200120155350538.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTYzNjcwMg==,size_16,color_FFFFFF,t_70" alt="img">)<img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>1、docker01主机上以二进制包的方式部署consul服务并后台运行，其身份为leader</p><p>2、docker02、docker03以容器的方式运行consul服务，并加入到docker01的consul群集中</p><p>3、在主机docker02、docker03上后台运行registrator容器，使其自动发现docker容器提供的服务，并发送给consul</p><p>4、在docker01上部署Nginx，提供反向代理服务，docker02、docker03主机上基于Nginx镜像，各运行两个web容器，提供不同的网页文件，以便测试效果</p><p>5、在docker01上安装consul-template命令，将收集到的信息（registrator收集到容器的信息）写入template模板中，并且最终写入Nginx的配置文件中</p><p>6、至此，实现客户端通过访问Nginx反向代理服务器（docker01），获得docker02、docker03服务器上运行的Nginx容器提供的网页文件</p><p>Consul：分布式、高可用的，服务发现和配置的工具，数据中心</p><p>Registrator：负责收集dockerhost上，容器服务的信息，并且发送给consul</p><p>registrator是一个能自动发现docker container提供的服务，并在后端服务注册中心注册服务或取消服务的工具，后端注册中心支持consul、etcd、skydns2、zookeeper等</p><p>Consul-template：根据编辑好的模板生成新的nginx配置文件，并且负责加载nginx配置文件</p>]]></content>
    
    <summary type="html">
    
      Docker
    
    </summary>
    
    
      <category term="Docker" scheme="http://yoursite.com/categories/Docker/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker数据持久化</title>
    <link href="http://yoursite.com/2020/01/24/Docker%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>http://yoursite.com/2020/01/24/Docker%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/</id>
    <published>2020-01-23T16:00:00.000Z</published>
    <updated>2020-01-25T08:54:46.689Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker数据持久化"><a href="#Docker数据持久化" class="headerlink" title="Docker数据持久化"></a><strong>Docker数据持久化</strong></h1><p>为什么要做数据持久化：</p><p>因为Docker容器本身就是一个进程，可能会因为某些原因，或某些错误导致进程被杀死，这样数据就会丢失。</p><p>Docker容器是有生命周期的，生命周期结束，进程也会被杀死，数据就会丢失，因此需要做数据持久化，保证数据不会丢失</p><h2 id="Storage-Driver"><a href="#Storage-Driver" class="headerlink" title="Storage Driver"></a>Storage Driver</h2><p>数据存储</p><p>Centos7版本的Docker，Storage Driver为：Overlay2； backing filesystem：xfs</p><h2 id="Data-Volume"><a href="#Data-Volume" class="headerlink" title="Data Volume"></a>Data Volume</h2><h3 id="Bind-mount"><a href="#Bind-mount" class="headerlink" title="Bind mount"></a>Bind mount</h3><p>持久化存储：本质上是DockerHost文件系统中的目录或文件，能够直接被Mount到容器的文件系统中，在运行容器时，可以通过-v实现</p><p>特点：</p><ul><li>Data Volume是目录或文件，不能是没有格式化的磁盘（块设备）</li><li>容器可以读写volume中的数据</li><li>volume数据可以永久保存，即使用它的容器已经被销毁</li></ul><p>小实验：</p><p>运行一个nginx服务，做数据持久化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# mkdir  html</span><br><span class="line">[root@docker01 ~]# cd  html&#x2F;</span><br><span class="line">[root@docker01 html]# echo &quot;This is a testfile in dockerHost.&quot;  &gt;  index.html</span><br><span class="line">[root@docker01 html]# cat index.html </span><br><span class="line">This is a testfile in dockerHost.</span><br><span class="line">[root@docker01 ~]# docker run  -itd  --name  testweb  -v  &#x2F;root&#x2F;html&#x2F;:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html  nginx:latest</span><br><span class="line">[root@docker01 ~]# docker inspect testweb</span><br><span class="line">&quot;Gateway&quot;: &quot;172.17.0.1&quot;,</span><br><span class="line">[root@docker01 ~]# curl 172.17.0.2</span><br><span class="line">This is a testfile in dockerHost.</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>PS:DockerHost上需要挂在的源文件或目录，必须是已经存在的，否则，当做一个目录挂在到容器中</p><p>默认挂载到容器内的文件，容器是有读写权限，可以在运行容器时-v后边加”:ro”限制容器的写入权限</p><p>并且还可以挂在单独文件到容器内部，一般它的使用场景是：如果不想对整个目录进行覆盖，而只希望添加某个文件，就可以使用挂载单个文件</p><h3 id="Docker-Manager-Volume"><a href="#Docker-Manager-Volume" class="headerlink" title="Docker Manager Volume"></a>Docker Manager Volume</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# docker run -itd --name t2 -P -v &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html nginx:latest</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>删除容器的操作，默认不会对dockerHost上的文件操作，如果想要在删除容器时把源文件也删除，可以在删除容器时添加-v选型（一般不推荐使用这种方式，因为文件有可能被其他容器使用）</p><h3 id="容器与容器的数据共享："><a href="#容器与容器的数据共享：" class="headerlink" title="容器与容器的数据共享："></a>容器与容器的数据共享：</h3><p>volume container：给其他容器提供volume存储卷的容器，并且可以提供bind mount，也可以提供docker manager volume</p><p>//创建一个vc_data容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# docker create --name vc_data \</span><br><span class="line">&gt;  -v  ~&#x2F;html:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html \</span><br><span class="line">&gt;  -v  &#x2F;other&#x2F;useful&#x2F;tools  busybox</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h3 id="容器的跨主机数据共享"><a href="#容器的跨主机数据共享" class="headerlink" title="容器的跨主机数据共享"></a>容器的跨主机数据共享</h3><table><thead><tr><th>docker01</th><th>dcoker02</th><th>docker03</th></tr></thead><tbody><tr><td>httpd</td><td>httpd</td><td>nfs</td></tr></tbody></table><p>要求：</p><p>docker01和docker02的主目录是一样的</p><p>//docker03的操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@docker03 ~]#yum  -y  install  nfs-utils</span><br><span class="line">[root@docker03 ~]# mkdir  &#x2F;datashare</span><br><span class="line">[root@docker03 ~]# vim  &#x2F;etc&#x2F;exports</span><br><span class="line">[root@docker03 ~]# cat &#x2F;etc&#x2F;exports</span><br><span class="line">&#x2F;datashare  *(rw,sync,no_root_squash)</span><br><span class="line">[root@docker03 ~]# systemctl  start  rpcbind</span><br><span class="line">[root@docker03 ~]# systemctl  enable  rpcbind</span><br><span class="line">[root@docker03 ~]# systemctl  start  nfs-server</span><br><span class="line">[root@docker03 ~]# systemctl  enable  nfs-server</span><br><span class="line">[root@docker03 ~]# vim  &#x2F;datashare&#x2F;index.html</span><br><span class="line">[root@docker03 ~]# cat &#x2F;datashare&#x2F;index.html </span><br><span class="line">&lt;div id&#x3D;&quot;datetime&quot;&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        setInterval(&quot;document.getElementById(&#39;datetime&#39;).innerHTML&#x3D;new Date().toLocaleString();&quot;, 1000);</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">bdqn-webshare</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//验证</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# showmount  -e  192.168.1.60</span><br><span class="line">Export list for 192.168.1.60:</span><br><span class="line">&#x2F;datashare *</span><br><span class="line">[root@docker02 ~]# showmount  -e  192.168.1.60</span><br><span class="line">Export list for 192.168.1.60:</span><br><span class="line">&#x2F;datashare *</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//docker01的操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# mkdir  &#x2F;htdocs</span><br><span class="line">[root@docker01 ~]# mount  -t  nfs  192.168.1.60:&#x2F;datashare  &#x2F;htdocs&#x2F;</span><br><span class="line">&#x2F;&#x2F;-t：指定类型（type）</span><br><span class="line">[root@docker01 ~]# cat &#x2F;htdocs&#x2F;index.html </span><br><span class="line">&lt;div id&#x3D;&quot;datetime&quot;&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        setInterval(&quot;document.getElementById(&#39;datetime&#39;).innerHTML&#x3D;new Date().toLocaleString();&quot;, 1000);</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">bdqn-webshare</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//docker02的操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@docker02 ~]# mkdir   &#x2F;htdocs</span><br><span class="line">[root@docker02 ~]# mount  -t  nfs  192.168.1.60:&#x2F;datashare  &#x2F;htdocs&#x2F;</span><br><span class="line">[root@docker02 ~]# cat  &#x2F;htdocs&#x2F;index.html </span><br><span class="line">&lt;div id&#x3D;&quot;datetime&quot;&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        setInterval(&quot;document.getElementById(&#39;datetime&#39;).innerHTML&#x3D;new Date().toLocaleString();&quot;, 1000);</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">bdqn-webshare</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>这里先不考虑将代码写入镜像，先以这种方式，分别在docker01和docker02部署httpd服务</p><p>//docker01</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# docker run  -itd  --name  bdqn-web1 -P  -v  &#x2F;htdocs&#x2F;:&#x2F;usr&#x2F;local&#x2F;apache2&#x2F;htdocs  httpd:latest</span><br><span class="line">PS：查看端口映射0.0.0.0:32778-&gt;80&#x2F;tcp   bdqn-web1</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//docker02</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@docker02 ~]# docker run  -itd  --name  bdqn-web2 -P  -v  &#x2F;htdocs&#x2F;:&#x2F;usr&#x2F;local&#x2F;apache2&#x2F;htdocs  httpd:latest</span><br><span class="line">PS：查看端口映射0.0.0.0:32768-&gt;80&#x2F;tcp   bdqn-web2</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>此时用浏览器访问，两个web服务的主界面是一样的，但如果NFS服务器上源文件丢失，则两个web服务都会异常</p><p>想办法将源数据写入镜像内，在基于镜像做一个vc_data容器，这里因为没有接触到docker-compose和docker swarm等docker编排工具，所以我们在docker01和docker02上手动创建镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# cd  &#x2F;htdocs&#x2F;</span><br><span class="line">[root@docker01 htdocs]# vim  Dockerfile</span><br><span class="line">[root@docker01 htdocs]# cat Dockerfile </span><br><span class="line">FROM busybox</span><br><span class="line">ADD  index.html  &#x2F;usr&#x2F;local&#x2F;apache2&#x2F;htdocs&#x2F;index.html</span><br><span class="line">VOLUME  &#x2F;usr&#x2F;local&#x2F;apache2&#x2F;htdocs</span><br><span class="line">[root@docker01 htdocs]# docker build  -t  back_data  .</span><br><span class="line">[root@docker01 htdocs]# docker create --name back_container1 back_data:latest </span><br><span class="line">[root@docker01 htdocs]# docker run -itd --name web3 -P --volumes-from back_container1 httpd:latest </span><br><span class="line">[root@docker01 htdocs]# pwd</span><br><span class="line">&#x2F;htdocs</span><br><span class="line">[root@docker01 htdocs]# docker save  &gt; back_data.tar back_data:latest</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//docker02上操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@docker02 ~]# cd &#x2F;htdocs&#x2F;</span><br><span class="line">[root@docker02 htdocs]# ls</span><br><span class="line">back_data.tar  Dockerfile  index.html</span><br><span class="line">[root@docker02 htdocs]# docker load &lt; back_data.tar </span><br><span class="line">[root@docker02 htdocs]# docker create --name back_container2 back_data:latest</span><br><span class="line">[root@docker02 htdocs]# docker run -itd --name web4 -P --volumes-from back_container2 httpd:latest</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 htdocs]# rm -rf index.html</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>通过浏览器访问，一开始运行的web1和web2容器，无法访问了。web3和web4还是可以访问的。</p><p>但是数据无法同步了</p>]]></content>
    
    <summary type="html">
    
      Docker
    
    </summary>
    
    
      <category term="Docker" scheme="http://yoursite.com/categories/Docker/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker网络</title>
    <link href="http://yoursite.com/2020/01/24/Docker%E7%BD%91%E7%BB%9C/"/>
    <id>http://yoursite.com/2020/01/24/Docker%E7%BD%91%E7%BB%9C/</id>
    <published>2020-01-23T16:00:00.000Z</published>
    <updated>2020-01-25T08:54:31.777Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Docker网络："><a href="#Docker网络：" class="headerlink" title="Docker网络："></a>Docker网络：</h2><h3 id="原生网络"><a href="#原生网络" class="headerlink" title="原生网络"></a>原生网络</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker  network  ls</span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">fcc280741b01        bridge              bridge              local</span><br><span class="line"><span class="number">9</span>c09e5a698dc        host                host                local</span><br><span class="line"><span class="number">03411</span>a6d716c        none                <span class="literal">null</span>                local</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong>None：什么都没有的网络</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker run  -itd  --name  none  --network none  busybox:latest</span><br><span class="line">[root@localhost ~]# docker exec  -it  none  /bin/sh</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>PS：用到None网络的容器，会发现它只有一个LoopBack回环的网络，没有Mac地址、IP等信息，意味着它不能跟外界通信，是被隔离起来的网络</p><p><strong>使用场景：</strong></p><p>   隔离意味着安全，所以，此网络可以运行一些关于安全方面的验证码、校验码等服务</p><p><strong>Bridge：桥接网络</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# brctl  show</span><br><span class="line">bridge namebridge idSTP enabledinterfaces</span><br><span class="line">docker0<span class="number">8000.02428e69</span>e324no</span><br><span class="line">virbr0<span class="number">8000.525400547</span>d41yesvirbr0-nic</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>docker0：在我们安装docker这个服务的时候，默认就会生产一张docker0的网卡，一般默认IP为172.17.0.1/16</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker run  -itd  --name  test1 busybox:latest </span><br><span class="line">[root@localhost ~]# docker  exec  -it  test1   /bin/sh</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>容器默认使用的网络是docker0网络，docker0此时相当于一个路由器，基于此网络的容器，网段都是和docker0一致的</p><h2 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a><strong>自定义网络</strong></h2><p><strong>自带了一个ContainerDNSserver功能（域名解析）</strong></p><p>bridge</p><p>//创建一个bridge网络：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker network create -d  bridge my_net</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//创建两个容器，应用自定义网络（my_net）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker  run  -itd  --name  test3  --network  my_net  busybox:latest</span><br><span class="line">[root@localhost ~]# docker  run  -itd  --name  test4  --network  my_net  busybox:latest</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>PS：自定义网络优点，它可以通过容器的名称通信</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker exec  -it  test3  &#x2F;bin&#x2F;sh</span><br><span class="line">&#x2F; # ping test4</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//创建一个自定义网络，并且指定网关和网段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker  network  create -d  bridge  --subnet  172.20.16.0&#x2F;24 --gateway 172.20.16.1 my_net2</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//创建两个容器，应用自定义网络(my_net2)，并指定IP</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker  run  -itd  --name  test5  --network  my_net2  --ip  172.20.16.6  busybox:latest</span><br><span class="line">[root@localhost ~]# docker  run  -itd  --name  test6  --network  my_net2  --ip  172.20.16.8  busybox:latest</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>PS：如果想要给容器指定IP地址，那么自定义网络的时候，必须指定网关gateway和subnet网段选项</p><p>//实现不同网段之间的通信，在容器里再添加一块网卡：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker network connect my_net2  test4</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/20191224220304293.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTYzNjcwMg==,size_16,color_FFFFFF,t_70" alt="img">)<img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h3 id="让外网能够访问容器的端口映射方法："><a href="#让外网能够访问容器的端口映射方法：" class="headerlink" title="让外网能够访问容器的端口映射方法："></a>让外网能够访问容器的端口映射方法：</h3><p><strong>1）手动指定端口映射关系：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker run  -itd  --name  web1  -p  90:80 nginx:latest</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong>2）从宿主机随机映射端口到容器：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker run  -itd  --name   web2  -p  80  nginx:latest</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong>3)从宿主机随机映射端口到容器，容器内所有暴露的端口，都会一一映射</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker run  -itd  --name  web4  -P  nginx:latest</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h3 id="join容器：container（共享网络协议栈）"><a href="#join容器：container（共享网络协议栈）" class="headerlink" title="join容器：container（共享网络协议栈）"></a><strong>join容器：container（共享网络协议栈）</strong></h3><p><strong>容器和容器之间</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker run  -itd  --name  web5  busybox:latest</span><br><span class="line">[root@localhost ~]# docker run  -itd  --name  web6  --network  container:web5  busybox:latest</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker exec  -it   web6  &#x2F;bin&#x2F;sh</span><br><span class="line">&#x2F; # echo  123456  &gt;  &#x2F;tmp&#x2F;index.html</span><br><span class="line">&#x2F; # httpd  -h  &#x2F;tmp&#x2F;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker exec  -it  web5  &#x2F;bin&#x2F;sh</span><br><span class="line">&#x2F; # wget  -O  -  -q  127.0.0.1</span><br><span class="line">123456</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//这时会发现，两个容器的IP地址一样</p><p>PS：这种方法的使用场景：</p><p>由于这种网络的特殊特性，一般在运行同一个服务，并且合格服务需要做监控，已经日志收集、或者网络监控的时候，可以选择这种网络</p><p><strong>docker的跨主机网络解决方案</strong></p><p>overlay（覆盖）的解决方案：</p><p>实验环境：</p><p>docker01：192.168.1.70</p><p>docker02：192.168.1.60</p><p>docker03：192.168.1.50</p><p>暂时不考录防火墙和selinux安全问题</p><p>将3台dockerhost防火墙和selinux全部关闭，并分别更改主机名称</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# hostnamectl   set-hostname  docker01</span><br><span class="line">[root@localhost ~]# su -</span><br><span class="line">[root@docker01 ~]# systemctl  stop  firewalld</span><br><span class="line">[root@docker01 ~]# setenforce  0</span><br><span class="line">[root@docker01 ~]# systemctl  disable  firewalld</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>在docker01上操作：</p><p>//运行consul服务：（数据中心–分布式的）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# docker load  &lt;  myprogrium-consul.tar</span><br><span class="line">[root@docker01 ~]# docker run  -d  -p  8500:8500  -h  consul  --name  consul  \  </span><br><span class="line">&gt; --restart  always  progrium&#x2F;consul  -server  -bootstrap</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>PS:容器产生之后我们可以通过浏览器访问consul服务，验证consul服务是否正常，访问dockerHost加映射端口</p><p><img src="https://img-blog.csdnimg.cn/20191224220952285.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTYzNjcwMg==,size_16,color_FFFFFF,t_70" alt="img">)<img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>修改docker02和docker03的docker配置文件：</p><p>//将IP和端口的映射关系，写入consul</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@docker02 ~]# vim  &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;docker.service</span><br><span class="line">修改：</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;bin&#x2F;dockerd -H unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock -H tcp:&#x2F;&#x2F;0.0.0.0:2376 --cluster-store&#x3D;consul:&#x2F;&#x2F;192.168.1.70:8500 --cluster-advertise&#x3D;ens33:2376</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>PS:返回浏览器consul服务界面，找到KEY/VALUE—-&gt;Docker—-&gt;NODES，会看到刚刚加入的docker02和docker03的信息</p><p><img src="https://img-blog.csdnimg.cn/2019122422102830.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTYzNjcwMg==,size_16,color_FFFFFF,t_70" alt="img">)<img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/20191224221044415.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTYzNjcwMg==,size_16,color_FFFFFF,t_70" alt="img">)<img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/20191224221055747.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTYzNjcwMg==,size_16,color_FFFFFF,t_70" alt="img">)<img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong>在docker02上创建一个自定义网络：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@docker02 ~]# docker network  create  -d  overlay  ov_net1</span><br><span class="line">[root@docker02 ~]# docker network  ls</span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">fe92a0eff6a4        ov_net1             overlay             global</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>在docker02上创建网络，我们可以看到它的SCOPE定义的时global（全局），意味着加入到consul这个服务的docker服务，都可以看到我们自定义的网络</p><p>同理如果是用此网络创建的容器，会有两张网卡，默认这张网卡是10.0.0.0网段，如果想要docker01也可以看到这个网络，那么也只需在docker01的docker配置文件添加相应内容即可</p><p>同理，因为是自定义网络，符合自定义网络的特性，可以直接通过docker容器的名称互相通信，当然也可以在自定义网络的时候，指定它的网段，那么使用此网络的容器也可以指定IP地址</p><p><img src="https://img-blog.csdnimg.cn/20191224221134509.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTYzNjcwMg==,size_16,color_FFFFFF,t_70" alt="img">)<img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>]]></content>
    
    <summary type="html">
    
      Docker
    
    </summary>
    
    
      <category term="Docker" scheme="http://yoursite.com/categories/Docker/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker跨主机网络方案之MacVlan</title>
    <link href="http://yoursite.com/2020/01/24/Docker%E8%B7%A8%E4%B8%BB%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%96%B9%E6%A1%88%E4%B9%8BMacVlan/"/>
    <id>http://yoursite.com/2020/01/24/Docker%E8%B7%A8%E4%B8%BB%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%96%B9%E6%A1%88%E4%B9%8BMacVlan/</id>
    <published>2020-01-23T16:00:00.000Z</published>
    <updated>2020-01-25T08:55:38.481Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Docker跨主机网络方案之MacVlan"><a href="#Docker跨主机网络方案之MacVlan" class="headerlink" title="Docker跨主机网络方案之MacVlan"></a>Docker跨主机网络方案之MacVlan</h2><p><strong>实验环境：</strong></p><table><thead><tr><th><strong>docker01</strong></th><th><strong>192.168.1.70</strong></th></tr></thead><tbody><tr><td><strong>docker02</strong></td><td><strong>192.168.1.50</strong></td></tr></tbody></table><p><strong>关闭防火墙和禁用selinux，更该主机名：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# systemctl  stop  firewalld</span><br><span class="line">[root@localhost ~]# systemctl  disable  firewalld</span><br><span class="line">[root@localhost ~]# setenforce  0</span><br><span class="line">[root@localhost ~]# systemctl  daemon-reload </span><br><span class="line">[root@localhost ~]# systemctl  restart  docker</span><br><span class="line">[root@localhost ~]# hostnamectl  set-hostname  docker01</span><br><span class="line">[root@localhost ~]# su -</span><br></pre></td></tr></table></figure><p><strong>macvlan的单网络通信</strong><br><img src="https://img-blog.csdnimg.cn/20191224221649657.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTYzNjcwMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>1）打开网卡的混杂模式<br>//需要在docker01和docker02上都进行操作</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# ip link  set ens33  promisc on</span><br><span class="line">[root@docker01 ~]# ip link  show ens33</span><br></pre></td></tr></table></figure><p><strong>2）在docker01上创建macvlan网络</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在这里插入代码片[root@docker01 ~]# docker network  create  -d  macvlan  --subnet 172.22.16.0&#x2F;24 --gateway  172.22.16.1 -o  parent&#x3D;ens33  mac_net1</span><br><span class="line">[root@docker01 ~]# docker network  ls</span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">e6860af70e90        mac_net1            macvlan             local</span><br></pre></td></tr></table></figure><p>PS:-o parent=绑定在哪张网卡之上<br><strong>3）基于创建的macvlan网络运行一个容器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# docker run -itd --name bbox1 --ip 172.22.16.10 --network mac_net1 busybox</span><br></pre></td></tr></table></figure><p><strong>4）在docker02上创建macvlan网络，注意与docker01上的macvlan网络一摸一样</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@docker02 ~]# docker network create -d macvlan --subnet 172.22.16.0&#x2F;24 --gateway  172.22.16.1 -o  parent&#x3D;ens33  mac_net1</span><br></pre></td></tr></table></figure><p><strong>5）在docker02上，基于创建的macvlan网络运行一个容器，验证与docker01上容器的通信</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@docker02 ~]# docker run  -itd --name  bbox2  --network mac_net1 --ip 172.22.16.20 busybox</span><br></pre></td></tr></table></figure><p><strong>macvlan的多网络通信</strong><br><img src="https://img-blog.csdnimg.cn/20191224221901966.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTYzNjcwMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>1）docker01和docker02验证内核模块8021q封装<br>macvlan需要解决的问题：基于真实的ens33网卡，生产新的虚拟网卡</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# modinfo  8021q</span><br><span class="line">&#x2F;&#x2F;如果内核模块没有开启，运行下边命令导入一下</span><br><span class="line">[root@docker01 ~]# modprobe  8021q</span><br></pre></td></tr></table></figure><p><strong>2）基于ens33创建虚拟网卡<br>//修改ens33网卡配置文件：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# cd  &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;</span><br><span class="line">[root@docker01 network-scripts]# vim  ifcfg-ens33</span><br><span class="line">&#x2F;&#x2F;修改：</span><br><span class="line">BOOTPROTO&#x3D;manual   &#x2F;&#x2F;手动模式</span><br></pre></td></tr></table></figure><p><strong>//手动添加虚拟网卡配置文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 network-scripts]# cp  -p  ifcfg-ens33 ifcfg-ens33.10</span><br><span class="line">&#x2F;&#x2F;PS：-p  保留源文件或目录的属性</span><br><span class="line">[root@docker01 network-scripts]# vim  ifcfg-ens33.10</span><br><span class="line">BOOTPROTO&#x3D;none</span><br><span class="line">IPADDR&#x3D;192.168.10.10</span><br><span class="line">PREFIX&#x3D;24</span><br><span class="line">GATEWAY&#x3D;192.168.10.1</span><br><span class="line">NAME&#x3D;ens33.10</span><br><span class="line">DEVICE&#x3D;ens33.10</span><br><span class="line">ONBOOT&#x3D;yes</span><br><span class="line">VLAN&#x3D;yes</span><br><span class="line">&#x2F;&#x2F;PS：这里注意，IP要和ens33网段做一个区分，保证网关和网段IP的一致性，设备名称和配置文件的一致性，并且打开VLAN支持模式</span><br></pre></td></tr></table></figure><p><strong>//创建第二个虚拟网卡配置文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 network-scripts]# cp  -p  ifcfg-ens33.10  ifcfg-ens33.20</span><br><span class="line">[root@docker01 network-scripts]# vim  ifcfg-ens33.20</span><br><span class="line">BOOTPROTO&#x3D;none</span><br><span class="line">IPADDR&#x3D;192.168.20.20</span><br><span class="line">PREFIX&#x3D;24</span><br><span class="line">GATEWAY&#x3D;192.168.20.1</span><br><span class="line">NAME&#x3D;ens33.20</span><br><span class="line">DEVICE&#x3D;ens33.20</span><br><span class="line">ONBOOT&#x3D;yes</span><br><span class="line">VLAN&#x3D;yes</span><br></pre></td></tr></table></figure><p><strong>3）docker01上的操作，启用创建的虚拟网卡</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 network-scripts]# ifup ifcfg-ens33.10</span><br><span class="line">[root@docker01 network-scripts]# ifup ifcfg-ens33.20</span><br></pre></td></tr></table></figure><p><strong>4)基于虚拟网卡，创建macvlan网络</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# docker network create -d macvlan --subnet 172.16.10.0&#x2F;24 --gateway 172.16.10.1 -o parent&#x3D;ens33.10 mac_net10</span><br><span class="line">[root@docker01 ~]# docker network create -d macvlan --subnet 172.16.20.0&#x2F;24 --gateway 172.16.20.1 -o parent&#x3D;ens33.20 mac_net20</span><br></pre></td></tr></table></figure><p><strong>5)基于创建的虚拟网卡，创建macvlan网络</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@docker02 ~]# docker network create -d macvlan --subnet 172.16.10.0&#x2F;24 --gateway 172.16.10.1 -o parent&#x3D;ens33.10 mac_net10</span><br><span class="line">[root@docker02 ~]# docker network create -d macvlan --subnet 172.16.20.0&#x2F;24 --gateway 172.16.20.1 -o parent&#x3D;ens33.20 mac_net20</span><br></pre></td></tr></table></figure><p><strong>6)docker02上也创建虚拟网卡，并启用</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# scp  &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ens33.10 &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ens33.20  root@192.168.1.50:&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;</span><br><span class="line">[root@docker02 network-scripts]# vim  ifcfg-ens33</span><br><span class="line">BOOTPROTO&#x3D;manual</span><br><span class="line">[root@docker02 network-scripts]# vim  ifcfg-ens33.10</span><br><span class="line">BOOTPROTO&#x3D;none</span><br><span class="line">IPADDR&#x3D;192.168.10.11</span><br><span class="line">PREFIX&#x3D;24</span><br><span class="line">GATEWAY&#x3D;192.168.10.1</span><br><span class="line">NAME&#x3D;ens33.10</span><br><span class="line">DEVICE&#x3D;ens33.10</span><br><span class="line">ONBOOT&#x3D;yes</span><br><span class="line">VLAN&#x3D;yes</span><br><span class="line">[root@docker02 network-scripts]# vim  ifcfg-ens33.20</span><br><span class="line">BOOTPROTO&#x3D;none</span><br><span class="line">IPADDR&#x3D;192.168.20.21</span><br><span class="line">PREFIX&#x3D;24</span><br><span class="line">GATEWAY&#x3D;192.168.20.1</span><br><span class="line">NAME&#x3D;ens33.20</span><br><span class="line">DEVICE&#x3D;ens33.20</span><br><span class="line">ONBOOT&#x3D;yes</span><br><span class="line">VLAN&#x3D;yes</span><br><span class="line">[root@docker02 network-scripts]# ifup ifcfg-ens33.10 </span><br><span class="line">[root@docker02 network-scripts]# ifup ifcfg-ens33.20</span><br></pre></td></tr></table></figure><p><strong>7)基于macvlan网络创建容器，并指定IP地址，不过这里要注意，运行的同期与网络对应的网段相符合，还需要注意IP地址的唯一性</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;docker01</span><br><span class="line">[root@docker01 ~]# docker run -itd  --name  bbox10  --network mac_net10  --ip  172.16.10.10 192.168.1.70:5000&#x2F;busybox:v1 </span><br><span class="line">[root@docker01 ~]# docker run -itd  --name  bbox20  --network mac_net20  --ip  172.16.20.20 192.168.1.70:5000&#x2F;busybox:v1</span><br><span class="line">&#x2F;&#x2F;docker02</span><br><span class="line">[root@docker02 ~]# docker run -itd --name bbox11  --network mac_net10  --ip  172.16.10.11 192.168.1.70:5000&#x2F;busybox:v1</span><br><span class="line">[root@docker02 ~]# docker run -itd --name bbox21  --network mac_net20  --ip  172.16.20.21 192.168.1.70:5000&#x2F;busybox:v1</span><br></pre></td></tr></table></figure><p><strong>8)将VMware虚拟机的网络改为桥接</strong><br><img src="https://img-blog.csdnimg.cn/20191224222113475.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTYzNjcwMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>9)进入容器测试通信</strong><br>在docker01上进入容器bbox10和docker02上的bbox11进行通信<br>在docker01上进入容器bbox20和docker02上的bbox21进行通信</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]# docker exec  -it  bbox10  &#x2F;bin&#x2F;sh</span><br><span class="line">&#x2F; # ping   172.16.10.11</span><br><span class="line">PING 172.16.10.11 (172.16.10.11): 56 data bytes</span><br><span class="line">64 bytes from 172.16.10.11: seq&#x3D;0 ttl&#x3D;64 time&#x3D;0.668 ms</span><br><span class="line">64 bytes from 172.16.10.11: seq&#x3D;1 ttl&#x3D;64 time&#x3D;0.335 ms</span><br><span class="line">[root@docker01 ~]# docker exec  -it  bbox20  &#x2F;bin&#x2F;sh</span><br><span class="line">&#x2F; # ping  172.16.20.21</span><br><span class="line">PING 172.16.20.21 (172.16.20.21): 56 data bytes</span><br><span class="line">64 bytes from 172.16.20.21: seq&#x3D;0 ttl&#x3D;64 time&#x3D;0.584 ms</span><br><span class="line">64 bytes from 172.16.20.21: seq&#x3D;1 ttl&#x3D;64 time&#x3D;0.365 ms</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Docker
    
    </summary>
    
    
      <category term="Docker" scheme="http://yoursite.com/categories/Docker/"/>
    
    
  </entry>
  
  <entry>
    <title>Kubernetes集群部署</title>
    <link href="http://yoursite.com/2020/01/24/Kubernetes%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/"/>
    <id>http://yoursite.com/2020/01/24/Kubernetes%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/</id>
    <published>2020-01-23T16:00:00.000Z</published>
    <updated>2020-01-25T09:04:55.106Z</updated>
    
    <content type="html"><![CDATA[<p>生产级别的容器编排系统</p><p><a href="https://kubernetes.io/zh/docs/concepts/overview/what-is-kubernetes/" target="_blank" rel="noopener">Kubernetes</a> 是用于自动部署，扩展和管理容器化应用程序的开源系统</p><p>k8s</p><p>最基本的硬件要求</p><p>CPU:双核</p><p>Mem：2G</p><p>3台dockerhost时间必须同步</p><p>Kubeadm工具自动部署k8s集群</p><hr><p>//给3台docker命名，禁用swap交换分区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# hostnamectl  set-hostname  master</span><br><span class="line">[root@localhost ~]# su -</span><br><span class="line">[root@localhost ~]# hostnamectl  set-hostname  node01</span><br><span class="line">[root@localhost ~]# su -</span><br><span class="line">[root@localhost ~]# hostnamectl  set-hostname  node02</span><br><span class="line">[root@localhost ~]# su -</span><br><span class="line">[root@master ~]# swapoff  -a   &#x2F;&#x2F;临时禁用</span><br><span class="line">[root@master ~]# free</span><br><span class="line">              total        used        free      shared  buff&#x2F;cache   available</span><br><span class="line">Mem:        1867292      335448      908540        9256      623304     1290100</span><br><span class="line">Swap:             0           0           0</span><br><span class="line">&#x2F;&#x2F;永久禁用</span><br><span class="line">[root@master ~]# vim  &#x2F;etc&#x2F;fstab  &#x2F;&#x2F;注释掉swap那一行</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//禁用selinux，防火墙，并关闭开机自启（三台都需要）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# vim  &#x2F;etc&#x2F;selinux&#x2F;config</span><br><span class="line">SELINUX&#x3D;disabled</span><br><span class="line">[root@master ~]# setenforce  0</span><br><span class="line">[root@master ~]# systemctl  stop  firewalld</span><br><span class="line">[root@master ~]# systemctl  disable  firewalld</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//编写hosts文件，设置域名解析</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# vim  &#x2F;etc&#x2F;hosts</span><br><span class="line">127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4</span><br><span class="line">::1         localhost localhost.localdomain localhost6 localhost6.localdomain6</span><br><span class="line">192.168.1.70    master</span><br><span class="line">192.168.1.50    node01</span><br><span class="line">192.168.1.40    node02</span><br><span class="line">[root@master ~]# scp   &#x2F;etc&#x2F;hosts   root@192.168.1.50:&#x2F;etc</span><br><span class="line">[root@master ~]# scp   &#x2F;etc&#x2F;hosts   root@192.168.1.40:&#x2F;etc</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//设置免密登录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# ssh-keygen  -t  rsa</span><br><span class="line">[root@master ~]# ssh-copy-id  node01</span><br><span class="line">[root@master ~]# ssh-copy-id  node02</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//打开iptables的桥接功能，开启路由转发</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# vim  &#x2F;etc&#x2F;sysctl.d&#x2F;k8s.conf</span><br><span class="line">net.bridge.bridge-nf-call-iptables &#x3D; 1</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables &#x3D; 1</span><br><span class="line">[root@master ~]# echo  net.ipv4.ip_forward &#x3D; 1  &gt;&gt;  &#x2F;etc&#x2F;sysctl.conf </span><br><span class="line">[root@master ~]# sysctl  -p</span><br><span class="line">net.ipv4.ip_forward &#x3D; 1</span><br><span class="line">[root@master ~]# sysctl  -p  &#x2F;etc&#x2F;sysctl.d&#x2F;k8s.conf   &#x2F;&#x2F;如果这条命令不成功则需要添加一个模块[root@master ~]# modprobe  br_netfilter</span><br><span class="line">net.bridge.bridge-nf-call-iptables &#x3D; 1</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables &#x3D; 1</span><br><span class="line">[root@master ~]# scp  &#x2F;etc&#x2F;sysctl.d&#x2F;k8s.conf  node01:&#x2F;etc&#x2F;sysctl.d   </span><br><span class="line">[root@master ~]# scp  &#x2F;etc&#x2F;sysctl.d&#x2F;k8s.conf  node02:&#x2F;etc&#x2F;sysctl.d    </span><br><span class="line">[root@master ~]# scp  &#x2F;etc&#x2F;sysctl.conf  node02:&#x2F;etc&#x2F; </span><br><span class="line">[root@master ~]# scp  &#x2F;etc&#x2F;sysctl.conf  node01:&#x2F;etc&#x2F;</span><br><span class="line">[root@node01 ~]# sysctl  -p</span><br><span class="line">net.ipv4.ip_forward &#x3D; 1</span><br><span class="line">[root@node01 ~]# sysctl -p  &#x2F;etc&#x2F;sysctl.d&#x2F;k8s.conf </span><br><span class="line">net.bridge.bridge-nf-call-iptables &#x3D; 1</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables &#x3D; 1</span><br><span class="line">[root@node02 ~]# sysctl  -p</span><br><span class="line">net.ipv4.ip_forward &#x3D; 1</span><br><span class="line">[root@node02 ~]# sysctl  -p   &#x2F;etc&#x2F;sysctl.d&#x2F;k8s.conf </span><br><span class="line">net.bridge.bridge-nf-call-iptables &#x3D; 1</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables &#x3D; 1</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//获取yum源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# cat &lt;&lt;EOF &gt; &#x2F;etc&#x2F;yum.repos.d&#x2F;kubernetes.repo</span><br><span class="line">&gt; [kubernetes]</span><br><span class="line">&gt; name&#x3D;Kubernetes</span><br><span class="line">&gt; baseurl&#x3D;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kubernetes&#x2F;yum&#x2F;repos&#x2F;kubernetes-el7-x86_64&#x2F;</span><br><span class="line">&gt; enabled&#x3D;1</span><br><span class="line">&gt; gpgcheck&#x3D;1</span><br><span class="line">&gt; repo_gpgcheck&#x3D;1</span><br><span class="line">&gt; gpgkey&#x3D;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kubernetes&#x2F;yum&#x2F;doc&#x2F;yum-key.gpg https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kubernetes&#x2F;yum&#x2F;doc&#x2F;rpm-package-key.gpg</span><br><span class="line">&gt; EOF</span><br><span class="line">[root@master ~]# yum  repolist</span><br><span class="line">[root@master ~]# yum  makecache</span><br><span class="line">&#x2F;&#x2F;三台都需要这个yum源（node01，node02步骤省略）</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//安装以下三个组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# yum  -y  install  kubeadm-1.15.0-0  kubelet-1.15.0-0  kubectl-1.15.0-0</span><br><span class="line">&#x2F;&#x2F;node01、node02不需要安装kubectl</span><br><span class="line">[root@node01 ~]# yum -y install kubeadm-1.15.0-0 kubelet-1.15.0-0</span><br><span class="line">[root@node02 ~]# yum -y install kubeadm-1.15.0-0 kubelet-1.15.0-0</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//加入开机自启（三台全部加入开机自启）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# systemctl  enable  kubelet</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//导入镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# mkdir  images</span><br><span class="line">[root@master ~]# cd images&#x2F;</span><br><span class="line">[root@master images]# ls</span><br><span class="line">coredns-1-3-1.tar  kube-apiserver-1-15.tar   kube-proxy-1-15.tar      myflannel-11-0.tar</span><br><span class="line">etcd-3-3-10.tar    kube-controller-1-15.tar  kube-scheduler-1-15.tar  pause-3-1.tar</span><br><span class="line">[root@master ~]# cat  &gt;  images.sh  &lt;&lt;EOF</span><br><span class="line">&gt; #!&#x2F;bin&#x2F;bash</span><br><span class="line">&gt; for  i  in  &#x2F;root&#x2F;images&#x2F;*</span><br><span class="line">&gt; do</span><br><span class="line">&gt; docker  load  &lt;  $i</span><br><span class="line">&gt; done</span><br><span class="line">&gt; EOF</span><br><span class="line">[root@master ~]# chmod  +x  images.sh</span><br><span class="line">[root@master ~]# sh  images.sh</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//初始化k8s集群</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# kubeadm  init  --kubernetes-version&#x3D;v1.15.0 \</span><br><span class="line">&gt; --pod-network-cidr&#x3D;10.244.0.0&#x2F;16 \</span><br><span class="line">&gt; --service-cidr&#x3D;10.96.0.0&#x2F;12 \</span><br><span class="line">&gt; --ignore-preflight-errors&#x3D;Swap</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//如果初始化失败，需要重置k8s集群</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# kubeadm  reset</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//初始化完成后的操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# mkdir -p $HOME&#x2F;.kube</span><br><span class="line">[root@master ~]# cp -i &#x2F;etc&#x2F;kubernetes&#x2F;admin.conf $HOME&#x2F;.kube&#x2F;config</span><br><span class="line">[root@master ~]# chown $(id -u):$(id -g) $HOME&#x2F;.kube&#x2F;config</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//查看节点信息情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# kubectl  get  node</span><br><span class="line">NAME     STATUS     ROLES    AGE   VERSION</span><br><span class="line">master   NotReady   master   10m   v1.15.0</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//部署flannel网络，（k8s版本必须是1.7版本以上）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# kubectl apply -f https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;coreos&#x2F;flannel&#x2F;master&#x2F;Documentation&#x2F;kube-flannel.yml</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>PS：这里执行不成功的话可能是网络的问题</p><p>//在node01、node02上提前导入镜像（不然在加入集群的时候，它会自动下载镜像）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@node02 ~]# mkdir   images</span><br><span class="line">[root@node02 ~]# cd  images&#x2F;</span><br><span class="line">[root@node02 images]# ls</span><br><span class="line">kube-proxy-1-15.tar  myflannel-11-0.tar  pause-3-1.tar</span><br><span class="line">docker  load  &lt;  kube-proxy-1-15.tar  &amp;&amp;  docker  load  &lt;  myflannel-11-0.tar  &amp;&amp;   docker  load  &lt;  pause-3-1.tar</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//node01、node02加入集群</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kubeadm join 192.168.1.70:6443 --token x85ks8.4x5qrhw87zct1vti \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:227c69c29f16521a7dccb52104710b8cdd449aa0f7cb787affb62514fc8cc9eb</span><br><span class="line">[root@master ~]# kubectl  get  node</span><br><span class="line">NAME     STATUS   ROLES    AGE   VERSION</span><br><span class="line">master   Ready    master   25m   v1.15.0</span><br><span class="line">node01   Ready    &lt;none&gt;   82s   v1.15.0</span><br><span class="line">node02   Ready    &lt;none&gt;   76s   v1.15.0</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//确保是running的状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# kubectl  get  pod  --all-namespaces</span><br><span class="line">NAMESPACE     NAME                             READY   STATUS    RESTARTS   AGE</span><br><span class="line">kube-system   coredns-5c98db65d4-fr894         1&#x2F;1     Running   0          28m</span><br><span class="line">kube-system   coredns-5c98db65d4-qkqh5         1&#x2F;1     Running   0          28m</span><br><span class="line">kube-system   etcd-master                      1&#x2F;1     Running   0          27m</span><br><span class="line">kube-system   kube-apiserver-master            1&#x2F;1     Running   0          27m</span><br><span class="line">kube-system   kube-controller-manager-master   1&#x2F;1     Running   0          27m</span><br><span class="line">kube-system   kube-flannel-ds-amd64-rjnns      1&#x2F;1     Running   0          4m44s</span><br><span class="line">kube-system   kube-flannel-ds-amd64-tpkh5      1&#x2F;1     Running   0          4m50s</span><br><span class="line">kube-system   kube-flannel-ds-amd64-x425t      1&#x2F;1     Running   0          13m</span><br><span class="line">kube-system   kube-proxy-4qsj2                 1&#x2F;1     Running   0          4m44s</span><br><span class="line">kube-system   kube-proxy-gngnx                 1&#x2F;1     Running   0          28m</span><br><span class="line">kube-system   kube-proxy-shkw9                 1&#x2F;1     Running   0          4m50s</span><br><span class="line">kube-system   kube-scheduler-master            1&#x2F;1     Running   0          27m</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//设置tab键的距离</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# vim  .vimrc</span><br><span class="line">set tabstop&#x3D;2</span><br><span class="line">[root@master ~]# source .vimrc</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>//将kubectl命令加入tab自动补全</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# source  &#x2F;usr&#x2F;share&#x2F;bash-completion&#x2F;bash_completion </span><br><span class="line">[root@master ~]# source  &lt;(kubectl  completion bash)</span><br><span class="line">[root@master ~]# echo   &quot; source  &lt;(kubectl  completion bash)&quot;  &gt;&gt;  ~&#x2F;.bashrc</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>]]></content>
    
    <summary type="html">
    
      K8s
    
    </summary>
    
    
      <category term="k8s" scheme="http://yoursite.com/categories/k8s/"/>
    
    
  </entry>
  
</feed>
