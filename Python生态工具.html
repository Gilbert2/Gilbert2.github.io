<!DOCTYPE html><html lang=zh-CN><head><meta charset=UTF-8><meta name=viewport content="width=device-width, initial-scale=1, maximum-scale=2"><meta name=theme-color content=#222><meta name=generator content="Hexo 4.2.0"><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon-next.png><link rel=icon type=image/png sizes=32x32 href=/images/favicon-32x32-next.png><link rel=icon type=image/png sizes=16x16 href=/images/favicon-16x16-next.png><link rel=mask-icon href=/images/logo.svg color=#222><meta name=msvalidate.01 content=true><link rel=stylesheet href=/css/main.css><link rel=stylesheet href="//fonts.lug.ustc.edu.cn/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel=stylesheet href=/lib/font-awesome/css/all.min.css><link rel=stylesheet href=//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css><script id=hexo-configurations>
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"pdxblog.top","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"b2t":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":{"enable":true,"onlypost":false,"loadingImg":null},"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script><meta name=description content=Python><meta property=og:type content=article><meta property=og:title content=Python生态工具><meta property=og:url content=https://pdxblog.top/Python%E7%94%9F%E6%80%81%E5%B7%A5%E5%85%B7.html><meta property=og:site_name content=Maisyの博客><meta property=og:description content=Python><meta property=og:locale content=zh_CN><meta property=og:image content="https://img-blog.csdnimg.cn/20200427203400246.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTYzNjcwMg==,size_16,color_FFFFFF,t_70"><meta property=og:image content="https://img-blog.csdnimg.cn/20200427203426132.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTYzNjcwMg==,size_16,color_FFFFFF,t_70"><meta property=og:image content="https://img-blog.csdnimg.cn/20200427203444853.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTYzNjcwMg==,size_16,color_FFFFFF,t_70"><meta property=og:image content="https://img-blog.csdnimg.cn/20200427203507236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTYzNjcwMg==,size_16,color_FFFFFF,t_70"><meta property=article:published_time content=2020-04-26T16:00:00.000Z><meta property=article:modified_time content=2020-04-27T14:45:09.576Z><meta property=article:author content=Maisy><meta property=article:tag content=Python><meta name=twitter:card content=summary><meta name=twitter:image content="https://img-blog.csdnimg.cn/20200427203400246.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTYzNjcwMg==,size_16,color_FFFFFF,t_70"><link rel=canonical href=https://pdxblog.top/Python%E7%94%9F%E6%80%81%E5%B7%A5%E5%85%B7.html><script id=page-configurations>
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script><title>Python生态工具 | Maisyの博客</title><noscript><style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style></noscript><link rel=alternate href=/atom.xml title=Maisyの博客 type=application/atom+xml></head><body itemscope itemtype=http://schema.org/WebPage><div class="container use-motion"><div class=headband></div><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label=切换导航栏><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class=site-meta><a href="/" class=brand rel=start><span class=logo-line-before><i></i></span><h1 class=site-title>Maisyの博客</h1><span class=logo-line-after><i></i></span></a><p class=site-subtitle itemprop=description>记录生活中的点点滴滴</p></div><div class=site-nav-right><div class="toggle popup-trigger"></div></div></div><nav class=site-nav><ul id=menu class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel=section><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-top"><a href="/top/" rel=section><i class="fa fa-signal fa-fw"></i>排行榜</a></li><li class="menu-item menu-item-about"><a href="/about/" rel=section><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel=section><i class="fa fa-tags fa-fw"></i>标签<span class=badge>5</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel=section><i class="fa fa-th fa-fw"></i>分类<span class=badge>5</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel=section><i class="fa fa-archive fa-fw"></i>归档<span class=badge>54</span></a></li></ul></nav></div></header><div class=back-to-top><i class="fa fa-arrow-up"></i> <span>0%</span></div><main class=main><div class=main-inner><div class=content-wrap><div class="content post posts-expand"><article itemscope itemtype=http://schema.org/Article class=post-block lang=zh-CN><link itemprop=mainEntityOfPage href=https://pdxblog.top/Python%E7%94%9F%E6%80%81%E5%B7%A5%E5%85%B7.html><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content=/images/author.jpg><meta itemprop=name content=Maisy><meta itemprop=description content=人的一生就是一个储蓄的过程，在奋斗的时候储存了希望；在耕耘的时候储存了一粒种子；在旅行的时候储存了风景；在微笑的时候储存了快乐。聪明的人善于储蓄，在漫长而短暂的人生旅途中，学会储蓄每一个闪光的瞬间，然后用它们酿成一杯美好的回忆，在四季的变幻与交替之间，散发浓香，珍藏一生></span> <span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content=Maisyの博客></span><header class=post-header><h1 class=post-title itemprop="name headline">Python生态工具</h1><div class=post-meta><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i></span> <span class=post-meta-item-text>发表于</span><time title="创建时间：2020-04-27 00:00:00 / 修改时间：22:45:09" itemprop="dateCreated datePublished" datetime=2020-04-27T00:00:00+08:00>2020-04-27</time></span> <span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder"></i></span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing><a href="/categories/Python/" itemprop=url rel=index><span itemprop=name>Python</span></a></span></span> <span class=post-meta-item title=热度 id=busuanzi_container_page_pv style="display: none;"><span class=post-meta-item-icon><i class="fa fa-eye"></i></span> <span class=post-meta-item-text>热度：</span> <span id=busuanzi_value_page_pv></span></span> <span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-comment"></i></span> <span class=post-meta-item-text>Valine：</span> <a title=valine href=/Python%E7%94%9F%E6%80%81%E5%B7%A5%E5%85%B7.html#valine-comments itemprop=discussionUrl><span class="post-comments-count valine-comment-count" data-xid=/Python%E7%94%9F%E6%80%81%E5%B7%A5%E5%85%B7.html itemprop=commentCount></span></a></span><br><span class=post-meta-item title=本文字数><span class=post-meta-item-icon><i class="far fa-file-word"></i></span> <span class=post-meta-item-text>本文字数：</span> <span>29k</span></span> <span class=post-meta-item title=阅读时长><span class=post-meta-item-icon><i class="far fa-clock"></i></span> <span class=post-meta-item-text>阅读时长 &asymp;</span> <span>26 分钟</span></span><div class=post-description>Python</div></div></header><div class=post-body itemprop=articleBody><h2 id=Python生态工具><a class=header-anchor href=#Python生态工具>¶</a>Python生态工具</h2><h3 id=一、Python内置小工具><a class=header-anchor href=#一、Python内置小工具>¶</a>一、Python内置小工具</h3><h4 id=1-1、-1秒钟启动一个下载服务器><a class=header-anchor href=#1-1、-1秒钟启动一个下载服务器>¶</a>1.1、 1秒钟启动一个下载服务器</h4><p>在实际工作中，时常会有这样的一个需求：将文件传给其他同事。将文件传给同事本身并不是一个很繁 琐的工作，现在的聊天工具一般都支持文件传输。但是，如果需要传送的文件较多，操作起来就会比较 麻烦。此外，如果文件在远程的服务器上，则需要先将远程服务器的文件下载到本地，然后再通过聊天 工具传给同事。再或者，你并不是特别清楚要传哪几个文件给同事，所以，你们需要进行交流，而交流 的时间成本是比较高的，会降低办事效率。</p><p>此时，如果你知道Python内置了一个下载服务器就能够显著提升效率了。例如，你的同事要让你传的文 件位于某一个目录下，那么，你可以进入这个目录，然后执行下面的命令启动一个下载服务器：</p><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line>python -m SimpleHTTPServer</span><br></pre></td></tr></table></figure><p>在Python 3中，由于对系统库进行了重新整理，因此，使用方式会有不同：</p><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line>python -m http.server</span><br></pre></td></tr></table></figure><p>执行上面的命令就会在当前目录下启动一个文件下载服务器，默认打开8000端口。完成以后，只需要将 IP和端口告诉同事，让同事自己去操作即可，非常方便高效。</p><p>使用浏览器访问Python启动的下载服务器，可以看到一个类似于FTP下载的界面，这个时候单击文件下 载即可。通过这种方式传输文件，可以降低大家的沟通成本，提高文件传输的效率。</p><p>上面使用的Python语句，从工作原理来说，仅仅是启动了一个Python内置的Web服务器。如果当前目 录下存在一个名为index.html的文件，则默认显示该文件的内容。如果当前目录下不存在这样一个文 件，则默认显示当前目录下的文件列表，也就是大家看到的下载服务器。</p><h4 id=1-2、字符串转换为JSON><a class=header-anchor href=#1-2、字符串转换为JSON>¶</a>1.2、字符串转换为JSON</h4><p>JSON是一种轻量级的数据交换格式，易于人类阅读和编写，同时也易于机器解析和生成。由于JSON的 诸多优点，已被广泛使用在各个系统中。JSON使用越广泛，需要将JSON字符串转换为JSON对象的需求 就越频繁。</p><p>例如，在工作过程中，我们的系统会调用底层服务的API。底层服务的API一般都是以JSON的格式返 回，为了便于问题追踪，我们会将API返回的JSON转换为字符串记录到日志文件中。当需要分析问题 时，就需要将日志文件中的JSON字符串拿出来进行分析。这个时候，需要将一个JSON字符串转换为 JSON对象，以提高日志的可读性。</p><p>这个需求十分常见，以至于使用搜索引擎搜索&quot;JSON&quot;，处于搜索结果的第一项便是“在线JSON格式化工 具”。除了打开浏览器，使用在线JSON格式化工具以外，我们也可以使用命令行终端的Python解释器来 解析JSON串，如下所示</p><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre></td><td class=code><pre><span class=line>[root@oracle ~]<span class=comment># echo '&#123;"address": &#123;"province": "zhejiang", "city": "hangzhou"&#125;, "name": "lmx", "sex": "male"&#125;' | python -m json.tool </span></span><br><span class=line>&#123;</span><br><span class=line>   <span class=string>"address"</span>: </span><br><span class=line>        <span class=string>"city"</span>: <span class=string>"hangzhou"</span>,</span><br><span class=line>       <span class=string>"province"</span>: <span class=string>"zhejiang</span></span><br><span class=line><span class=string>   &#125;,</span></span><br><span class=line><span class=string>   "</span>name<span class=string>": "</span>lmx<span class=string>"</span></span><br><span class=line><span class=string>   "</span>sex<span class=string>": "</span>male<span class=string>"</span></span><br><span class=line><span class=string>&#125;</span></span><br></pre></td></tr></table></figure><p>使用命令行解释器解析JSON串非常方便，而且，为了便于阅读，该工具还会自动将转换的结果进行对 齐和格式化。如下所示：</p><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre></td><td class=code><pre><span class=line>[root@oracle ~]<span class=comment># echo '&#123;"address": &#123;"province": "zhejiang", "city":</span></span><br><span class=line><span class=string>"hangzhou"</span>&#125;, <span class=string>"name"</span>: <span class=string>"lmx"</span>, <span class=string>"sex"</span>: <span class=string>"male"</span>&#125;<span class=string>' | python -m json.tool</span></span><br><span class=line><span class=string>&#123;</span></span><br><span class=line><span class=string>	"address": &#123;</span></span><br><span class=line><span class=string>		"city": "hangzhou",</span></span><br><span class=line><span class=string>		"province": "zhejiang"</span></span><br><span class=line><span class=string>	&#125;,</span></span><br><span class=line><span class=string>	"name": "lmx",</span></span><br><span class=line><span class=string>	"sex": "male"</span></span><br><span class=line><span class=string>&#125;</span></span><br></pre></td></tr></table></figure><h4 id=1-3、检查第三方库是否正常安装><a class=header-anchor href=#1-3、检查第三方库是否正常安装>¶</a>1.3、检查第三方库是否正常安装</h4><p>安装完Python的第三方库以后，如何确认这个库已经正确安装了呢？答案很简单，只需要尝试进行 import导入即可。如果导入没有任何错误，则认为安装成功；如果导入失败，则认为安装失败。</p><figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre></td><td class=code><pre><span class=line>[root@oracle ~]<span class=comment># python</span></span><br><span class=line>Python <span class=number>2.7</span><span class=number>.5</span> (default, Oct <span class=number>30</span> <span class=number>2018</span>, <span class=number>23</span>:<span class=number>45</span>:<span class=number>53</span>)</span><br><span class=line>[GCC <span class=number>4.8</span><span class=number>.5</span> <span class=number>20150623</span> (Red Hat <span class=number>4.8</span><span class=number>.5</span><span class=number>-36</span>)] on linux2</span><br><span class=line>Type <span class=string>"help"</span>, <span class=string>"copyright"</span>, <span class=string>"credits"</span> <span class=keyword>or</span> <span class=string>"license"</span> <span class=keyword>for</span> more information.</span><br><span class=line>&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>验证Python的第三方库是否安装成功，本身也是一件很简单的事情，但是，如果我们使用脚本对大批量 的服务器进行自动部署，又应该如何验证第三方库安装成功了呢？肯定不能登录每一台服务器进行验 证。这个时候，我们可以使用Python解释器的-c参数快速地执行import语句，如下所示：</p><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre></td><td class=code><pre><span class=line>[root@oracle ~]<span class=comment># python -c "import paramiko"</span></span><br><span class=line>Traceback (most recent call last):</span><br><span class=line>File <span class=string>"&lt;string&gt;"</span>, line 1, <span class=keyword>in</span> &lt;module&gt;</span><br><span class=line>ImportError: No module named paramiko</span><br></pre></td></tr></table></figure><h3 id=二、pip高级用法><a class=header-anchor href=#二、pip高级用法>¶</a>二、pip高级用法</h3><p>为了便于用户安装和管理第三方库和软件，越来越多的编程语言拥有自己的包管理工具，如nodejs的 npm，ruby的gem。Python也不例外，现在Python生态主流的包管理工具是pip</p><h4 id=2-1、pip介绍><a class=header-anchor href=#2-1、pip介绍>¶</a>2.1、pip介绍</h4><p>pip是一个用来安装和管理Python包的工具，是easy_install的替代品，如果读者使用的是Python 2.7.9+或Python 3.4+版本的Python，则已经内置了pip，无须安装直接使用即可。如果系统中没有安装 pip，也可以手动安装</p><h4 id=2-2、python3安装pip><a class=header-anchor href=#2-2、python3安装pip>¶</a>2.2、python3安装pip</h4><blockquote><p><strong>方法1：python33安装完成后默认已经带有pip3</strong></p></blockquote><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre></td><td class=code><pre><span class=line>[root@oracle bin]<span class=comment># pip3 -V</span></span><br><span class=line>pip 19.2.3 from /usr/<span class=built_in>local</span>/python38/lib/python3.8/site-packages/pip (python</span><br><span class=line>3.8)</span><br><span class=line>[root@oracle bin]<span class=comment># pwd</span></span><br><span class=line>/usr/<span class=built_in>local</span>/python38/bin</span><br></pre></td></tr></table></figure><p>你可以用以下命令,创建软链接</p><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line>ln -s /usr/<span class=built_in>local</span>/python38/bin/pip3 /usr/bin/pip3</span><br></pre></td></tr></table></figure><blockquote><p><strong>方法2：使用以下方法重新安装pip插件</strong></p></blockquote><p>下载get-pip.py脚本</p><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line>wget https://bootstrap.pypa.io/3.2/get-pip.py</span><br></pre></td></tr></table></figure><p>运行脚本</p><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line>python3 get-pip.py</span><br></pre></td></tr></table></figure><p>python3创建pip3索引</p><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line>ln -s /usr/python3.6.1/bin/pip /usr/bin/pip3</span><br></pre></td></tr></table></figure><p>测试是否安装成功</p><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line>pip3 install requests</span><br></pre></td></tr></table></figure><p>pip之所以能够成为最流行的包管理工具，并不是因为它被Python官方作为默认的包管理器，而是因为 它自身的诸多优点。pip的优点有：</p><figure class="highlight tex"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre></td><td class=code><pre><span class=line>pip提供了丰富的功能，其竞争对手easy_install则只支持安装，没有提供卸载和显示已安装列表的功</span><br><span class=line>能；</span><br><span class=line>pip能够很好地支持虚拟环境；</span><br><span class=line>pip可以通过requirements.txt集中管理依赖；</span><br><span class=line>pip能够处理二进制格式(.whl)；</span><br><span class=line>pip是先下载后安装，如果安装失败，也会清理干净，不会留下一个中间状态。</span><br></pre></td></tr></table></figure><p><a href=http://xn--pypi-z94fx2cpii0ty2bsy4aoqgoxuqkav67c75bq19aje7az32h.python.org target=_blank rel=noopener>如果用户没有将软件打包上传到pypi.python.org</a>，则无法使用pip进行安装。对于这种情况，Python生 态也有标准的做法，例如，我们尝试从源码安装paramiko。需要注意的是，我们也可以通过pip安装 paramiko的，这里只是为了演示Python生态中源码安装：</p><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre></td><td class=code><pre><span class=line>$ git <span class=built_in>clone</span> https://github.com/paramiko/paramiko.git</span><br><span class=line>$ <span class=built_in>cd</span> paramiko</span><br><span class=line>$ python setup.py install</span><br></pre></td></tr></table></figure><h4 id=2-3、给pip3重命名><a class=header-anchor href=#2-3、给pip3重命名>¶</a>2.3、给pip3重命名</h4><p>切换至家目录，通过.bashrc添加别名</p><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre></td><td class=code><pre><span class=line>[root@oracle bin]<span class=comment># cd ~</span></span><br><span class=line>[root@localhost ~]<span class=comment># vim .bashrc</span></span><br><span class=line><span class=built_in>alias</span> pip=pip3</span><br><span class=line>[root@localhost ~]<span class=comment># source .bashrc</span></span><br><span class=line>[root@localhost ~]<span class=comment># pip -V</span></span><br><span class=line>pip 19.2.3 from /usr/<span class=built_in>local</span>/python38/lib/python3.8/site-packages/pip (python</span><br><span class=line>3.8)</span><br></pre></td></tr></table></figure><h4 id=2-4、pip3常用命令><a class=header-anchor href=#2-4、pip3常用命令>¶</a>2.4、pip3常用命令</h4><table><thead><tr><th>子命令</th><th>解释说明</th></tr></thead><tbody><tr><td>install</td><td>安装软件包</td></tr><tr><td>download</td><td>下载软件包</td></tr><tr><td>uninstall</td><td>卸载安装包</td></tr><tr><td>freeze</td><td>按照requirements格式输出安装包，可以到其他服务器上执行pip install -r requirements.txt直接安装软件</td></tr><tr><td>list</td><td>列出当前系统中的安装包</td></tr><tr><td>show</td><td>查看安装包的信息，包括版本、依赖、许可证、作者、主页等信息</td></tr><tr><td>check</td><td>检查安装包依赖是否完整</td></tr><tr><td>search</td><td>查找安装包</td></tr><tr><td>wheel</td><td>打包软件到wheel格式</td></tr><tr><td>hash</td><td>计算安装包的hash值</td></tr><tr><td>completion</td><td>生成命令补全配置</td></tr><tr><td>help</td><td>获取pip和子命令的帮助信息</td></tr></tbody></table><h4 id=2-5、加速pip安装的技巧><a class=header-anchor href=#2-5、加速pip安装的技巧>¶</a>2.5、加速pip安装的技巧</h4><p>如果大家使用Python的时间比较长的话，会发现Python安装的一个问题，即pypi.python.org不是特别 稳定，有时候会很慢，甚至处于完全不可用的状态。这个问题有什么好办法可以解决呢？根据笔者的经 验，至少有两种不同的方法。</p><h5 id=1、使用豆瓣或阿里云的源加速软件安装><a class=header-anchor href=#1、使用豆瓣或阿里云的源加速软件安装>¶</a>1、使用豆瓣或阿里云的源加速软件安装</h5><p>访问pypi.python.org不稳定的主要原因是因为网络不稳定，如果我们从网络稳定的服务器下载安装 包，问题就迎刃而解了。我们国内目前有多个pypi镜像，推荐使用豆瓣的镜像源或阿里的镜像源。如果 要使用第三方的源，只需要在安装时，通过pip命令的-i选项指定镜像源即可。如下所示：</p><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line>pip install -i https://pypi.douban.com/simple/ flask</span><br></pre></td></tr></table></figure><p>每次都要指定镜像源的地址比较麻烦，我们也可以修改pip的配置文件，将镜像源写入配置文件中。对 于Linux系统来说，需要创建～/.pip/pip.conf文件，然后在文件中保存如下内容：</p><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre></td><td class=code><pre><span class=line>[root@localhost ~]<span class=comment># mkdir .pip</span></span><br><span class=line>[root@localhost ~]<span class=comment># cd .pip</span></span><br><span class=line>[root@localhost .pip]<span class=comment># touch pip.conf</span></span><br><span class=line>[root@localhost .pip]<span class=comment># vim pip.conf</span></span><br><span class=line>[global]</span><br><span class=line>index-url = https://pypi.douban.com/simple/</span><br></pre></td></tr></table></figure><h5 id=2、将软件下载到本地部署><a class=header-anchor href=#2、将软件下载到本地部署>¶</a>2、将软件下载到本地部署</h5><p>如果需要对大批量的服务器安装软件包，并且安装包比较多或者比较大，则可以考虑将软件包下载到本 地，然后从本地安装。这对于使用脚本部署大量的服务器非常有用，此外，对于服务器无法连接外网的 情况，也可以使用这种方法。如下所示：</p><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre></td><td class=code><pre><span class=line><span class=comment># 下载到本地</span></span><br><span class=line>pip install --download=<span class=string>'pwd'</span> -r requirements.txt</span><br><span class=line></span><br><span class=line><span class=comment># 本地安装</span></span><br><span class=line>pip install --no-index -f file://<span class=string>'pwd'</span> -r requirements.txt</span><br></pre></td></tr></table></figure><p>使用这种方式，只需要下载一次，就可以多处安装，不用担心网络不稳定的问题。并且，pip能够自动 处理软件依赖问题。例如，我们通过这种方式下载Flask到当前目录下，则Flask的依赖click、 itsdangerous、Jinja2、MarkupSafe和Werkzeug也会被下载到本地，如下所示：</p><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre></td><td class=code><pre><span class=line>pip install --download=<span class=string>'pwd'</span> flask</span><br><span class=line></span><br><span class=line>$ ls</span><br><span class=line>click-6.7-py2.py3-none-any.whl itsdangerous-0.24.tar.gz</span><br><span class=line>MarkupSafe-0.23.tar.gz Flask-0.12-py2.py3-none-any.whl</span><br><span class=line>Jinja2-2.9.5-py2.py3-none-any.whl Werkzeug-0.11.15-py2.py3-none-any.whl</span><br></pre></td></tr></table></figure><h3 id=三、Python变成辅助工具><a class=header-anchor href=#三、Python变成辅助工具>¶</a>三、Python变成辅助工具</h3><p>因为Python是一门动态类型语言，所以，Python程序不需要编译和链接就可以直接运行。Python程序 运行时是从上至下逐行执行，因此Python工程师可以进行交互式的编程，从而快速验证代码的运行结果 是否符合预期。同时，Python工程师也可以通过交互式编程的方式学习Python编程。也正是因为 Python交互式编程的诸多优点，所以，Python交互式编程使用非常广泛。</p><h4 id=3-1、Python交互式编程><a class=header-anchor href=#3-1、Python交互式编程>¶</a>3.1、Python交互式编程</h4><p>要使用Python的交互式编程，最简单的方式是使用标准的Python Shell。在命令行直接输入python命 令便可进入Python Shell，如下所示：</p><figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre></td><td class=code><pre><span class=line>[root@localhost ~]<span class=comment># python</span></span><br><span class=line>Python <span class=number>3.8</span><span class=number>.1</span> (default, Jan <span class=number>14</span> <span class=number>2020</span>, <span class=number>12</span>:<span class=number>20</span>:<span class=number>36</span>)</span><br><span class=line>[GCC <span class=number>4.8</span><span class=number>.5</span> <span class=number>20150623</span> (Red Hat <span class=number>4.8</span><span class=number>.5</span><span class=number>-39</span>)] on linux</span><br><span class=line>Type <span class=string>"help"</span>, <span class=string>"copyright"</span>, <span class=string>"credits"</span> <span class=keyword>or</span> <span class=string>"license"</span> <span class=keyword>for</span> more information.</span><br><span class=line><span class=meta>&gt;&gt;&gt; </span>a=<span class=number>3</span></span><br><span class=line><span class=meta>&gt;&gt;&gt; </span>b=<span class=number>4</span></span><br><span class=line><span class=meta>&gt;&gt;&gt; </span>a+b</span><br><span class=line><span class=number>7</span></span><br></pre></td></tr></table></figure><p>虽然标准的Python Shell也支持交互式编程，但是，它有很多不足，包括：</p><figure class="highlight tex"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre></td><td class=code><pre><span class=line>没有语法高亮；</span><br><span class=line>不支持Tab自动补全；</span><br><span class=line>没有自动缩进功能；</span><br><span class=line>不能保存历史记录；</span><br><span class=line>不能很好地与操作系统交互；</span><br><span class=line>无法导入外部文件中的程序。</span><br></pre></td></tr></table></figure><p>虽然Python自带的交互式编程满足了功能性需求，但是在易用性上仍有诸多不足。IPython是增强型的 Python Shell，不但解决了上面提到的各种问题，而且提供了非常丰富的组件，可以方便地进行交互式 编程和数据分析。IPython功能丰富，不可避免地导致软件变得庞大复杂，因此，IPython 4.0对 IPython进行了拆分，分离成IPython Shell和jupyter两个组件，这两个组件现在需要分别安装。 按照行业惯例，IPython代指IPython Shell，是一个类似于Python Shell的交互式解释器；jupyter代指 IPython Notebook，是一个带图形界面的应用程序。接下来我们分别介绍IPython和jupyter的使用。</p><h4 id=3-2、使用IPython交互编程><a class=header-anchor href=#3-2、使用IPython交互编程>¶</a>3.2、使用IPython交互编程</h4><p>IPython是一个第三方工具，因此，在使用之前需要先安装。可以直接使用操作系统的包管理工具或pip 进行安装。以下是在centos7上的安装方式：</p><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre></td><td class=code><pre><span class=line>[root@localhost ~]<span class=comment># pip install ipython</span></span><br><span class=line>Looking <span class=keyword>in</span> indexes: https://pypi.douban.com/simple/</span><br><span class=line>Collecting ipython</span><br><span class=line>	Downloading</span><br><span class=line>https://pypi.doubanio.com/packages/1c/f3/c8be38ee117d02508bb8b9158eb41ca416</span><br><span class=line>f442a6e8e3b3159c2f2d14ed79/ipython-7.11.1-py3-none-any.whl (777kB)</span><br><span class=line>	|████████████████████████████████| 778kB 934kB/s</span><br><span class=line></span><br><span class=line>……省略部分输出信息</span><br><span class=line></span><br><span class=line>Installing collected packages: six, ipython-genutils, decorator, traitlets,</span><br><span class=line>ptyprocess, pexpect, pickleshare, wcwidth, prompt-toolkit, pygments,</span><br><span class=line>backcall, parso, jedi, ipython</span><br><span class=line>	Running setup.py install <span class=keyword>for</span> backcall ... <span class=keyword>done</span></span><br><span class=line>Successfully installed backcall-0.1.0 decorator-4.4.1 ipython-7.11.1</span><br><span class=line>ipython-genutils-0.2.0 jedi-0.15.2 parso-0.5.2 pexpect-4.7.0 pickleshare0.7.5 prompt-toolkit-3.0.2 ptyprocess-0.6.0 pygments-2.5.2 six-1.13.0</span><br><span class=line>traitlets-4.3.3 wcwidth-0.1.8</span><br></pre></td></tr></table></figure><p>安装完成以后，在命令行终端输入ipython就进入了IPython交互式编程界面：</p><figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre></td><td class=code><pre><span class=line>[root@localhost ~]<span class=comment># ipython</span></span><br><span class=line>Python <span class=number>3.8</span><span class=number>.1</span> (default, Jan <span class=number>14</span> <span class=number>2020</span>, <span class=number>12</span>:<span class=number>20</span>:<span class=number>36</span>)</span><br><span class=line>Type <span class=string>'copyright'</span>, <span class=string>'credits'</span> <span class=keyword>or</span> <span class=string>'license'</span> <span class=keyword>for</span> more information</span><br><span class=line>IPython <span class=number>7.11</span><span class=number>.1</span> -- An enhanced Interactive Python. Type <span class=string>'?'</span> <span class=keyword>for</span> help.</span><br><span class=line></span><br><span class=line>In [<span class=number>1</span>]: sum=<span class=number>0</span></span><br><span class=line></span><br><span class=line>In [<span class=number>2</span>]: <span class=keyword>for</span> i <span class=keyword>in</span> range(<span class=number>5</span>):</span><br><span class=line>	...: sum+=i</span><br><span class=line>	...: print(sum)</span><br><span class=line><span class=number>10</span></span><br><span class=line></span><br><span class=line>In [<span class=number>3</span>]: <span class=keyword>import</span> os</span><br><span class=line></span><br><span class=line>In [<span class=number>4</span>]: os.getlogin()</span><br><span class=line></span><br><span class=line>Out[<span class=number>4</span>]: <span class=string>'root'</span></span><br><span class=line></span><br><span class=line>In [<span class=number>5</span>]:</span><br></pre></td></tr></table></figure><p>与标准的Python Shell一样，IPython的行显示了所使用的Python解释器版本以及当前的时间。第二行 是获取版权信息的方式，接着给出了IPython的版本。后是简短的使用说明，包括特征介绍、简短的 使用手册和如何获取帮助信息。表2-2给出了IPython提供的使用说明。 接下来我们将从五个不同的维度介绍IPython的使用，分别是：</p><blockquote><p>①更好的编辑器；</p><p>②更方便地获取帮助信息；</p><p>③IPython提供的magic函数；</p><p>④IPython的保存历史功能；</p><p>⑤IPython与操作系统交</p></blockquote><h5 id=（1）更好的编辑器><a class=header-anchor href=#（1）更好的编辑器>¶</a>（1）更好的编辑器</h5><p>IPython非常强大，有各种高级功能。其中，有用也直观的便是作为交互式编程工具的编辑器功 能。简单来说，IPython相对于标准的Python Shell是一个更好的交互式编程的编辑器，因为它具有：</p><figure class="highlight tex"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre></td><td class=code><pre><span class=line>语法高亮； </span><br><span class=line>自动缩进； </span><br><span class=line>Tab补全； </span><br><span class=line>快速获取帮助信息； </span><br><span class=line>搜索历史； </span><br><span class=line>执行shell命令</span><br></pre></td></tr></table></figure><p>如果只是描述IPython的特征，相信读者并没有完全的概念。这个时候可以坐在计算机旁，打开IPython 随便敲几行Python代码和标准的Python Shell进行比较，就能够直观感受到IPython的优点。</p><p>IPython与标准Python Shell的大区别在于，IPython会对命令提示符的每一行进行编号，编号以后能 够提高交互式编程的可读性。更重要的是，我们可以通过IPython提供的特殊函数对编号以后的代码进 行操作。此外，IPython支持语法高亮和自动缩进，相对于标准的Python Shell，是一个更好的编辑 器。如果在编写代码的过错中出现了错误需要删除时，标准的Python Shell无法进行很好的处理，只能 重新进行输入，而IPython则不存在这样的问题。</p><p>tab补全是一个特别有用的功能，IPython支持tab补全，而标准的Python Shell不支持。大家可以想象 一下，一个工程师近正在学习Python，他知道一个库里面有他想要的函数，但是，他并不能非常准确 地说出这个函数的名称。这个时候，如果没有tab补全，就只能一边打开Python官方的参考手册，一边 学习编程。有了tab补全以后，即使他对函数名称不是特别熟悉也没有关系，可以先通过tab补全列出当 前命名空间下的函数列表，然后根据函数名称选择自己需要的函数。IPython的补全功能非常强大，不 但可以补全用户的变量名、标准库的函数，在导入包时也可以进行补全。</p><p>这一小节，我们一直在强调IPython比标准的Python Shell更好用，拥有更多高级功能。如果读者接触 Python的时间不长，也许不能理解为什么需要使用交互式编程。交互式编程在当前会话退出以后就结束 了，并不满足计算机程序一次编写多次运行的特点。但是，在我们的日常工作中还是会经常用到交互式编程。</p><p>交互式编程不但可以快速验证代码执行结果，还可以帮助我们学习Python编程。Python工程师在编写 代码时，通常会使用编辑器和Python Shell组合的方式来完成程序的编写，例如，将代码从编辑器复制 到Python Shell以验证代码的正确性，然后将验证过的代码从Python Shell复制到编辑器中。</p><h5 id=（2）使用IPython来解析MySQL的备份日志><a class=header-anchor href=#（2）使用IPython来解析MySQL的备份日志>¶</a>（2）使用IPython来解析MySQL的备份日志</h5><p>为了便于读者理解交互式编程的好处，我们这里演示一个使用Python交互式编程的例子。在这个例子 中，我们使用IPython来解析MySQL的备份日志。</p><p>一个典型的MySQL物理备份日志如下所示：</p><figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre></td><td class=code><pre><span class=line>170221 01:07:48 Executing UNLOCK TABLES</span><br><span class=line>170221 01:07:48 All tables unlocked</span><br><span class=line>Starting slave SQL thread</span><br><span class=line>170221 01:07:48 [00] Streaming ib_buffer_pool to &lt;STDOUT&gt;</span><br><span class=line>170221 01:07:48 [00] ...done</span><br><span class=line>170221 01:07:48 Backup created in directory '/home/lmx/log/backup'</span><br><span class=line>MySQL binlog position: filename 'mysql-bin.000003', position '507946128',</span><br><span class=line>GTID of the last change '5a81ea97-daf1-11e6-94c1-fa163ee35df3:1-3409440'</span><br><span class=line>MySQL slave binlog position: master host '10.173.33.35', filename 'mysqlbin.000002', position '524993060'</span><br><span class=line>170221 01:07:48 [00] Streaming backup-my.cnf</span><br><span class=line>170221 01:07:48 [00] ...done</span><br><span class=line>170221 01:07:48 [00] Streaming xtrabackup_info</span><br><span class=line>170221 01:07:48 [00] ...done</span><br><span class=line>xtrabackup: Transaction log of lsn (3387315364) to (3451223966) was copied.</span><br><span class=line>170221 01:07:48 completed OK!</span><br></pre></td></tr></table></figure><p>即使读者对MySQL不了解也没有关系，我们现在的需求是解析下面这一行日志，并获取日志中的host、 filename和position的值。虽然在日志中position的值包含在一对单引号内，但是，我们希望解析以后 position的值是一个整数。</p><figure class="highlight tex"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line>MySQL slave binlog position: master host '10.173.33.35', filename 'mysqlbin.000002', position '524993060'</span><br></pre></td></tr></table></figure><p>在这个例子中，主要就是对字符串进行处理，并提取相应的值。这个问题当然不难，但是，如果不借助 交互式编程工具，需要工程师一次在代码中编写正确也不简单。如果工程师不知道交互式编程工具，就 只能在编辑器里面编写代码，然后运行。如果有错误再修改，直到获取正确的取值，整个过程将会非常 耗时。如果项目庞大，调试起来也会比较困难。这个时候就可以借助Python的交互式编程工具，先验证 代码的正确性，然后将验证过的代码从交互式编程工具复制到编辑器中。如下所示：</p><figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br></pre></td><td class=code><pre><span class=line>[root@localhost ~]<span class=comment># ipython</span></span><br><span class=line>Python <span class=number>3.8</span><span class=number>.1</span> (default, Jan <span class=number>14</span> <span class=number>2020</span>, <span class=number>12</span>:<span class=number>20</span>:<span class=number>36</span>)</span><br><span class=line>Type <span class=string>'copyright'</span>, <span class=string>'credits'</span> <span class=keyword>or</span> <span class=string>'license'</span> <span class=keyword>for</span> more information</span><br><span class=line>IPython <span class=number>7.11</span><span class=number>.1</span> -- An enhanced Interactive Python. Type <span class=string>'?'</span> <span class=keyword>for</span> help.</span><br><span class=line>In [<span class=number>1</span>]: line=<span class=string>"MySQL slave binlog position: master host '10.173.33.35',</span></span><br><span class=line><span class=string>filename 'mysql-bin.000002', position '524993060'"</span></span><br><span class=line>In [<span class=number>2</span>]: line.split(<span class=string>"'"</span>)</span><br><span class=line>Out[<span class=number>2</span>]:</span><br><span class=line>[<span class=string>'MySQL slave binlog position: master host '</span>,</span><br><span class=line><span class=string>'10.173.33.35'</span>,</span><br><span class=line><span class=string>', filename '</span>,</span><br><span class=line><span class=string>'mysql-bin.000002'</span>,</span><br><span class=line><span class=string>', position '</span>,</span><br><span class=line><span class=string>'524993060'</span>,</span><br><span class=line><span class=string>''</span>]</span><br><span class=line>In [<span class=number>3</span>]: host=line.split(<span class=string>"'"</span>)[<span class=number>1</span>]</span><br><span class=line>In [<span class=number>4</span>]: filename=line.split(<span class=string>"'"</span>)[<span class=number>3</span>]</span><br><span class=line>In [<span class=number>5</span>]: position=line.split(<span class=string>"'"</span>)[<span class=number>5</span>]</span><br><span class=line>In [<span class=number>6</span>]: print(host,filename,position)</span><br><span class=line><span class=number>10.173</span><span class=number>.33</span><span class=number>.35</span> mysql-bin<span class=number>.000002</span> <span class=number>524993060</span></span><br><span class=line>In [<span class=number>7</span>]: type(position)</span><br><span class=line>Out[<span class=number>7</span>]: str</span><br><span class=line>In [<span class=number>8</span>]: position=int(position)</span><br><span class=line>In [<span class=number>9</span>]: print(host,filename,position)</span><br><span class=line><span class=number>10.173</span><span class=number>.33</span><span class=number>.35</span> mysql-bin<span class=number>.000002</span> <span class=number>524993060</span></span><br></pre></td></tr></table></figure><p>为了节省文章篇幅，我们没有进行错误的尝试，而是直接通过单引号来分解字符串。由于我们使用了交 互式编程，可以很方便地看到字符串分解以后的中间结果。正是有了这个中间结果，我们才知道，字符 串分解成列表以后，下标1对应的字符串是host的值，下标3对应的字符串是filename的值，下标5对应 的字符串是position的值。我们还可以通过交互式编程发现position是一个字符串。由于我们要求 position是一个整数，因此，需要在代码中将position强制转换为一个整数。</p><p>如果读者自己尝试从这一行字符串中获取有效的值，很可能一开始会尝试使用逗号或空格来分解字符 串。这两种方法都无法一次取出host、filename和position的值。如下所示：</p><figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre></td><td class=code><pre><span class=line>In [<span class=number>10</span>]: line.split(<span class=string>','</span>)</span><br><span class=line>Out[<span class=number>10</span>]:</span><br><span class=line>[<span class=string>"MySQL slave binlog position: master host '10.173.33.35'"</span>,</span><br><span class=line><span class=string>" filename 'mysql-bin.000002'"</span>,</span><br><span class=line><span class=string>" position '524993060'"</span>]</span><br><span class=line></span><br><span class=line>In [<span class=number>11</span>]: line.split(<span class=string>' '</span>)</span><br><span class=line>Out[<span class=number>11</span>]:</span><br><span class=line>[<span class=string>'MySQL'</span>,</span><br><span class=line><span class=string>'slave'</span>,</span><br><span class=line><span class=string>'binlog'</span>,</span><br><span class=line><span class=string>'position:'</span>,</span><br><span class=line><span class=string>'master'</span>,</span><br><span class=line><span class=string>'host'</span>,</span><br><span class=line><span class=string>"'10.173.33.35',"</span>,</span><br><span class=line><span class=string>'filename'</span>,</span><br><span class=line><span class=string>"'mysql-bin.000002',"</span>,</span><br><span class=line><span class=string>'position'</span>,</span><br><span class=line><span class=string>"'524993060'"</span>]</span><br></pre></td></tr></table></figure><p>使用交互式编程，我们可以快速尝试不同的方案，先验证自己的想法是否正确，然后将代码拷贝到编辑 器中，组成我们的Python程序文件。通过这种方式，能够有效降低代码出错的概率，减少调试的时间， 从而提高工作效率。</p><h5 id=（3）更好地获取帮助信息><a class=header-anchor href=#（3）更好地获取帮助信息>¶</a>（3）更好地获取帮助信息</h5><p>Python工程师不但可以通过交互式编程快速验证代码执行结果，还可以通过交互式编程的方式学习 Python编程。之所以说Python工程师可以通过交互式编程学习编程，是因为使用IPython能够方便地获 取到相应的帮助信息。如命名空间下的每个对象以及其定义和使用说明。虽然标准的Python Shell也可 以通过help函数获取到对象的帮助信息，但是，IPython提供了更加灵活的方式获取命名空间下的对象 列表，以及更加全面的帮助信息。</p><p>我们知道，在标准库的os模块下的path子模块中有很多操作文件、目录和路径的函数，也有很多 以&quot;is&quot;开始的判断类函数。这些判断类函数的作用非常明确，用以判断给定的对象是否为一个文件或一 个目录。我们可以使用通配符的方式获取该模块下的所有判断类函数，如下所示：</p><figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre></td><td class=code><pre><span class=line>In [<span class=number>10</span>]: <span class=keyword>import</span> os</span><br><span class=line>In [11]: ?os.path.is*</span><br><span class=line>os.path.isabs</span><br><span class=line>os.path.isdir</span><br><span class=line>os.path.isfile</span><br><span class=line>os.path.islink</span><br><span class=line>os.path.ismount</span><br></pre></td></tr></table></figure><p>获取当前命名空间下的所有对象，除了使用通配符的方式以外，也可以使用前面介绍的tab补全方式。 tab补全的方式更加实用一些，就如同IPython提供的获取帮助信息的方式比标准的Python Shell获取帮 助信息更实用一样。在IPython中，可以通过标准的help函数获取对象的帮助信息，也可以使用“？”和 “？？”获取对象的帮助信息，如下所示：</p><figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br></pre></td><td class=code><pre><span class=line>In [<span class=number>12</span>]: <span class=keyword>import</span> json</span><br><span class=line>In [<span class=number>13</span>]: <span class=keyword>import</span> os</span><br><span class=line>In [14]: os.path.isfile?</span><br><span class=line>Signature: os.path.isfile(path)</span><br><span class=line>Docstring: Test whether a path <span class=keyword>is</span> a regular file</span><br><span class=line>File: ~/.pyenv/versions/<span class=number>3.8</span><span class=number>.1</span>/lib/python3<span class=number>.8</span>/genericpath.py</span><br><span class=line>Type: function</span><br><span class=line></span><br><span class=line>In [15]: json.dump?</span><br><span class=line></span><br><span class=line>Signature:</span><br><span class=line>json.dump(</span><br><span class=line>obj,</span><br><span class=line>fp,</span><br><span class=line>*,</span><br><span class=line>skipkeys=<span class=literal>False</span>,</span><br><span class=line>ensure_ascii=<span class=literal>True</span>,</span><br><span class=line>check_circular=<span class=literal>True</span>,</span><br><span class=line>allow_nan=<span class=literal>True</span>,</span><br><span class=line>cls=<span class=literal>None</span>,</span><br><span class=line>indent=<span class=literal>None</span>,</span><br><span class=line>separators=<span class=literal>None</span>,</span><br><span class=line>default=<span class=literal>None</span>,</span><br><span class=line>sort_keys=<span class=literal>False</span>,</span><br><span class=line>**kw,</span><br><span class=line>)</span><br><span class=line>Docstring:</span><br><span class=line>Serialize ``obj`` <span class=keyword>as</span> a JSON formatted stream to ``fp`` (a</span><br><span class=line>``.write()``-supporting file-like object).</span><br><span class=line></span><br><span class=line>If ``skipkeys`` <span class=keyword>is</span> true then ``dict`` keys that are <span class=keyword>not</span> basic types</span><br><span class=line>(``str``, ``int``, ``float``, ``bool``, ``<span class=literal>None</span>``) will be skipped</span><br><span class=line>instead of raising a ``TypeError``.</span><br></pre></td></tr></table></figure><p>当我们输入对象名称，再输入一个问号以后按回车键，就会显示相应的帮助信息。如果帮助信息比较 长，则会以分页的方式显示帮助信息。如果因为帮助信息太多而进入了分页页面，可以通过“q”键退出， 退出以后可以继续进行编程。</p><p>例如，json这个标准库下有一个dump函数和一个dumps函数，Python初学者总是容易混淆。这个时 候，如果能够充分利用IPython，就可以方便地获取到帮助信息，使用时不容易犯错。下面就是一个典 型的Python工程师使用json模块的方式，先构造了一个字典，希望将字典转换成json字符串。因为不知 道应该使用json.dump函数还是json.dumps函数，所以，在交互式编程中通过“json.dump?”语句获取dump函数的帮助信息。获取完json.dump函数的帮助信息以后，按“q”键退出，退出以后继续进行编 程。如下所示：</p><figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre></td><td class=code><pre><span class=line>In [<span class=number>18</span>]: <span class=keyword>import</span> json</span><br><span class=line>In [<span class=number>19</span>]: d=dict(a=<span class=number>1</span>,b=<span class=number>2</span>,c=<span class=number>3</span>)</span><br><span class=line>In [20]: json.dump?</span><br><span class=line>In [<span class=number>21</span>]: json.dumps(d)</span><br><span class=line>Out[<span class=number>21</span>]: <span class=string>'&#123;"a": 1, "b": 2, "c": 3&#125;'</span></span><br></pre></td></tr></table></figure><p>在IPython中，除了使用一个问号获取帮助信息以外，也可以使用两个问号获取帮助信息。两个问号获 取到的帮助信息更加全面，甚至会包含函数的实现源码。</p><p>除了使用问号的方式获取对象的帮助信息以外，IPython还提供了另外一种方式获取对象的信息，可以 分别获取对象的定义、文档和文件等。如下所示：</p><figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br></pre></td><td class=code><pre><span class=line>In [<span class=number>22</span>]: <span class=keyword>import</span> json</span><br><span class=line>In [<span class=number>23</span>]: %pdef json</span><br><span class=line>Object <span class=keyword>is</span> <span class=keyword>not</span> callable.</span><br><span class=line>In [<span class=number>24</span>]: %pdef json.dump</span><br><span class=line>json.dump(</span><br><span class=line>obj,</span><br><span class=line>fp,</span><br><span class=line>*,</span><br><span class=line>skipkeys=<span class=literal>False</span>,</span><br><span class=line>ensure_ascii=<span class=literal>True</span>,</span><br><span class=line>check_circular=<span class=literal>True</span>,</span><br><span class=line>allow_nan=<span class=literal>True</span>,</span><br><span class=line>cls=<span class=literal>None</span>,</span><br><span class=line>indent=<span class=literal>None</span>,</span><br><span class=line>separators=<span class=literal>None</span>,</span><br><span class=line>default=<span class=literal>None</span>,</span><br><span class=line>sort_keys=<span class=literal>False</span>,</span><br><span class=line>**kw,</span><br><span class=line>)</span><br><span class=line>In [<span class=number>25</span>]: %pfile json.dump</span><br><span class=line>In [<span class=number>26</span>]: %pdoc json.dump</span><br><span class=line>In [<span class=number>27</span>]: %pinfo json</span><br></pre></td></tr></table></figure><h5 id=（4）magic函数><a class=header-anchor href=#（4）magic函数>¶</a>（4）magic函数</h5><p>IPython提供了很多功能强大的函数，如前面已经提到的%pfile、%pdoc、%pinfo等。为了区分 IPython提供的函数和用户的输入，所有IPython提供的函数都以“%”开头。以“%”开头的这类功能强大的 函数，在IPython中称为magic函数。magic函数主要是为IPython提供增强的功能、与操作系统交互、 操纵用户的输入和输出以及对IPython进行配置。</p><p>IPython会将任何第一个字母为“%”的行，视为对magic函数的特殊调用。因此，所有的magic函数都是 以“%”开头。在IPython中，有两种不同的方法可以获取magic函数列表，分别是通过“%”获取所有的 magic函数和通过“%lsmagic”获取所有的magic函数。</p><p>下面是一个用lsmagic函数获取magic函数列表的例子：</p><figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br></pre></td><td class=code><pre><span class=line>In [<span class=number>28</span>]: %lsmagic</span><br><span class=line>Out[<span class=number>28</span>]:</span><br><span class=line>Available line magics:</span><br><span class=line>%alias %alias_magic %autoawait %autocall %autoindent %automagic</span><br><span class=line>%bookmark %cat %cd %clear %colors %conda %config %cp %cpaste</span><br><span class=line>%debug %dhist %dirs %doctest_mode %ed %edit %env %gui %hist</span><br><span class=line>%history %killbgscripts %ldir %less %lf %lk %ll %load %load_ext</span><br><span class=line>%loadpy %logoff %logon %logstart %logstate %logstop %ls %lsmagic</span><br><span class=line>%lx %macro %magic %man %matplotlib %mkdir %more %mv %notebook</span><br><span class=line>%page %paste %pastebin %pdb %pdef %pdoc %pfile %pinfo %pinfo2 %pip</span><br><span class=line>%popd %pprint %precision %prun %psearch %psource %pushd %pwd %pycat</span><br><span class=line>%pylab %quickref %recall %rehashx %reload_ext %rep %rerun %reset</span><br><span class=line>%reset_selective %rm %rmdir %run %save %sc %set_env %store %sx</span><br><span class=line>%system %tb %time %timeit %unalias %unload_ext %who %who_ls %whos</span><br><span class=line>%xdel %xmode</span><br><span class=line></span><br><span class=line>Available cell magics:</span><br><span class=line>%%! %%HTML %%SVG %%bash %%capture %%debug %%file %%html %%javascript</span><br><span class=line>%%js %%latex %%markdown %%perl %%prun %%pypy %%python %%python2</span><br><span class=line>%%python3 %%ruby %%script %%sh %%svg %%sx %%system %%time %%timeit</span><br><span class=line>%%writefile</span><br><span class=line></span><br><span class=line>Automagic <span class=keyword>is</span> ON, % prefix IS NOT needed <span class=keyword>for</span> line magics.</span><br></pre></td></tr></table></figure><p>可以看到，IPython提供了很多magic函数。并且，随着IPython的功能越来越多，magic函数还会不断 增加。那么，有没有一种好的方法能够快速了解magic函数的用法呢？前面介绍的通过问号获取对象帮 助信息的方法对magic函数也适用。因此，只要输入一个magic函数，后面再输入一个问号，回车以后 就能够看到这个magic函数的帮助信息。如下所示：</p><figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre></td><td class=code><pre><span class=line>In [29]: %save?</span><br><span class=line>Docstring:</span><br><span class=line>Save a set of lines <span class=keyword>or</span> a macro to a given filename.</span><br><span class=line></span><br><span class=line>Usage:</span><br><span class=line>	%save [options] filename n1-n2 n3-n4 ... n5 .. n6 ...</span><br><span class=line></span><br><span class=line>Options:</span><br><span class=line>     </span><br><span class=line>	-r: use <span class=string>'raw'</span> input. By default, the <span class=string>'processed'</span> history <span class=keyword>is</span> 	used,so that magics are loaded <span class=keyword>in</span> their transformed version 	to validPython. If this option <span class=keyword>is</span> given, the raw input <span class=keyword>as</span> 		typed <span class=keyword>as</span> thecommand line <span class=keyword>is</span> used instead.</span><br><span class=line></span><br><span class=line>	-f: force overwrite. If file exists, %save will prompt <span class=keyword>for</span> 		overwriteunless -f <span class=keyword>is</span> given.</span><br><span class=line></span><br><span class=line>	-a: append to the file instead of overwriting it.</span><br><span class=line>:</span><br></pre></td></tr></table></figure><p>IPython的官方文档将magic函数分为三类，分别是：</p><figure class="highlight tex"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre></td><td class=code><pre><span class=line>1）操作代码的magic函数，如<span class=comment>%run、%edit、%save、%macro、%recall；</span></span><br><span class=line>2）控制IPython的magic函数，如<span class=comment>%colors、%xmode、%autoindent、%automagic；</span></span><br><span class=line>3）其他magic函数，如<span class=comment>%reset、%timeit、%%writefile、%load、%paste。</span></span><br></pre></td></tr></table></figure><p>为了演示magic函数的使用，我们来看一个实际的例子。假设你是一名DBA，并且非常喜欢Python这门 编程语言，会经常使用Python管理MySQL。因此，你经常需要使用Python连接MySQL执行SQL语句 （Python连接MySQL的知识将在11章介绍）。使用Python执行SQL语句，对于普通的查询语句，返回 的结果将是一个二维的元组。但是，如果执行的是一些管理类的SQL语句或者监控类的SQL语句， Python驱动将会以怎样的方式返回MySQL的查询结果呢？</p><p>例如，需要执行下面的SQL语句，并获取返回结果：</p><figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>show</span> <span class=keyword>slave</span> <span class=keyword>status</span>；</span><br><span class=line><span class=keyword>show</span> <span class=keyword>master</span> <span class=keyword>status</span>；</span><br><span class=line><span class=keyword>show</span> <span class=keyword>variables</span> <span class=keyword>like</span> <span class=string>'%innodb%buffer%'</span>；</span><br><span class=line><span class=keyword>show</span> <span class=keyword>status</span> <span class=keyword>like</span> <span class=string>'%select%'</span>；</span><br><span class=line><span class=keyword>set</span> <span class=keyword>global</span> innodb_buffer_pool_dump_pct = <span class=number>30</span>；</span><br><span class=line><span class=keyword>GRANT</span> <span class=keyword>ALL</span> <span class=keyword>PRIVILEGES</span> <span class=keyword>ON</span> . <span class=keyword>TO</span> [<span class=string>'lmx'</span>@<span class=string>'localhost'</span>](mailto:<span class=string>'lmx'</span>@<span class=string>'localhost'</span>)</span><br><span class=line><span class=keyword>WITH</span> <span class=keyword>GRANT</span> <span class=keyword>OPTION</span>。</span><br></pre></td></tr></table></figure><p>为了得到Python执行上面SQL语句的结果，需要在Python中连接MySQL并进行认证。认证完成以后执 行SQL语句获取输出。由于你经常需要验证SQL语句，因此，使用Python连接MySQL并认证这些代码需 要反复输入。为了节省输入时间，我们可以将Python连接MySQL并认证的逻辑保存到外部文件中，在 需要的时候通过%load这个magic函数将外部代码导入到IPython中执行即可。例如，我们在一个名为 connect.py的外部文件中保存了连接MySQL的代码，在Ipython中使用%load导入外部Python文件：</p><figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre></td><td class=code><pre><span class=line>In [<span class=number>30</span>]: %load connect.py</span><br><span class=line>     </span><br><span class=line>In [<span class=number>31</span>]: <span class=keyword>import</span> MySQLdb <span class=keyword>as</span> db</span><br><span class=line>conn = db.connect(host=<span class=string>"localhost"</span>, db=<span class=string>"test"</span>, user=<span class=string>'lmx'</span>,</span><br><span class=line>passwd=<span class=string>'my_passwd'</span>, unix_socket=<span class=string>'/tmp/mysql.sock'</span>)</span><br><span class=line>cur = conn.cursor()</span><br><span class=line>sql = <span class=string>"select 1"</span></span><br><span class=line>cur.execute(sql)</span><br><span class=line>rows = cur.fetchall()</span><br><span class=line><span class=keyword>print</span> rows</span><br><span class=line>((<span class=number>1L</span>,),)</span><br></pre></td></tr></table></figure><p>使用%load命令导入外部的Python文件并执行以后，可以继续使用已经建立的MySQL连接执行SQL语 句。这个例子主要用以演示magic函数的用法，IPython提供了大量的magic函数，每一个magic函数的 具体用法都可以通过问号表达式获取相应的帮助文档。</p><h5 id=（5）保存历史><a class=header-anchor href=#（5）保存历史>¶</a>（5）保存历史</h5><p>保存编码历史这方面，IPython相比标准的Python Shell有了质的提升。用户可以非常灵活地操作 IPython的输入历史和输出历史。下面我们简单看几个例子：</p><blockquote><p>_i, _ii, _iii 分别保存了最近的三次输入； _, , _ 分别保存了最近的三次输出； 可以像Bash一样，通 过ctrl+p, ctrl+n查找输入； 可以像Bash一样，使用ctrl+r进行反向查找； IPython的输入历史在 当前会话退出以后会进行持久化，下一次进入IPython时，依然可以查找前一次会话的输入历史； %edit IPython可以通过%edit编辑历史输入并重新执行； %save IPython可以通过%save将 IPython中的代码保存到程序文件中； %rerun IPython可以指定代码行数重新运行；</p></blockquote><figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre></td><td class=code><pre><span class=line>In [<span class=number>32</span>]: %rerun <span class=number>21</span></span><br><span class=line>=== Executing: ===</span><br><span class=line>json.dumps(d)</span><br><span class=line>=== Output: ===</span><br><span class=line>Out[<span class=number>32</span>]: <span class=string>'&#123;"a": 1, "b": 2, "c": 3&#125;'</span></span><br></pre></td></tr></table></figure><h5 id=（6）与操作系统交互><a class=header-anchor href=#（6）与操作系统交互>¶</a>（6）与操作系统交互</h5><p>IPython比标准的Python Shell好用的另一个理由是，它能够更好地与操作系统进行交互。在使用 Python进行交互式编程时，不用退出Python Shell就可以执行Linux命令。magic函数里的%cd和%pwd 作用相当于Linux下的cd命令和pwd命令。此外，在IPython中，可以通过“!cmd”的形式执行任何Linux 命令。如下所示：</p><figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre></td><td class=code><pre><span class=line>In [<span class=number>33</span>]: %ls</span><br><span class=line>anaconda-ks.cfg initial-setup-ks.cfg Python<span class=number>-3.8</span><span class=number>.1</span>/ Python<span class=number>-3.8</span><span class=number>.1</span>.tgz</span><br><span class=line>In [<span class=number>34</span>]: %pwd</span><br><span class=line>Out[<span class=number>34</span>]: <span class=string>'/root'</span></span><br><span class=line>In [<span class=number>35</span>]: ! wc -l /tmp/storage.log</span><br><span class=line><span class=number>0</span> /tmp/storage.log</span><br></pre></td></tr></table></figure><p>也可以通过赋值的方式捕获命令的输出：</p><figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre></td><td class=code><pre><span class=line>In [<span class=number>36</span>]: data=!df</span><br><span class=line>In [<span class=number>37</span>]: data</span><br><span class=line>Out[<span class=number>37</span>]:</span><br><span class=line>[<span class=string>'文件系统 			   1K-块    	  已用      可用       已用%      挂载点'</span>,</span><br><span class=line><span class=string>'/dev/mapper/centos-root 17811456 		6060988  11750468   35%  	/'</span>,</span><br><span class=line><span class=string>'devtmpfs 			480872               0  480872     0%    	/dev'</span>,</span><br><span class=line><span class=string>'tmpfs 				497948               0  497948     0% 		/dev/shm'</span>,</span><br><span class=line><span class=string>'tmpfs                   497948            8696  489252     2% 		/run'</span>,</span><br><span class=line><span class=string>'tmpfs                   497948               0  497948     0% 	     /sys/fs/cgroup'</span>,</span><br><span class=line><span class=string>'/dev/sda1               1038336         169504  868832     17% 		/boot'</span>,</span><br><span class=line><span class=string>'tmpfs                   99592               64  99528      1% 	     /run/user/1000'</span>,</span><br><span class=line><span class=string>'tmpfs                   99592                0  99592      0% 		/run/user/0'</span>]</span><br><span class=line>In [<span class=number>38</span>]: data[<span class=number>1</span>].split()[<span class=number>4</span>]</span><br><span class=line>Out[<span class=number>38</span>]: <span class=string>'35%'</span></span><br></pre></td></tr></table></figure><p>在Python生态中，除了IPython这个增强的Python Shell以外，还有bython和ptpython这两个不错的 Python Shell。后面这两个工具都有自己的特色，但是都没有IPython使用广泛。而且，由于IPython使 用最为广泛，很多开源项目（如流行的爬虫框架Scrapy）对IPython进行了集成，所以，建议读者学习 IPython。</p><h4 id=3-3、-jupyter的使用><a class=header-anchor href=#3-3、-jupyter的使用>¶</a>3.3、 jupyter的使用</h4><h5 id=（1）、jupyter介绍><a class=header-anchor href=#（1）、jupyter介绍>¶</a>（1）、jupyter介绍</h5><p>jupyter就是以前的IPython Notebook，是一种新兴的交互式数据分析与记录工具。它通过浏览器访问 本地或者远端的IPython进程，并利用浏览器的图形界面，增强IPython的可视化输出。jupyter定义了 一种全新的文件格式，文件的后缀名是ipynb。ipynb文件包含了代码，用以说明每一步的计算和输出。 也就是说，ipynb文件完整记录了计算过程中的所有相关信息，并且，能够支持图片、视频和公式等副 文本格式，是科学计算、数据分析和编程教学的优秀工具。</p><p>正是由于jupyter丰富的可视化输出，其广泛应用于以下场景：</p><figure class="highlight tex"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre></td><td class=code><pre><span class=line>编程教学；</span><br><span class=line>数据分析；</span><br><span class=line>科学计算；</span><br><span class=line>幻灯片演示。</span><br></pre></td></tr></table></figure><h5 id=（2）、-jupyter-notebook的使用><a class=header-anchor href=#（2）、-jupyter-notebook的使用>¶</a>（2）、 jupyter notebook的使用</h5><p>IPython Shell与jupyter分离以后，jupyter需要额外进行安装。直接使用pip安装即可：</p><figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre></td><td class=code><pre><span class=line>[root@localhost ~]# pip install jupyter</span><br><span class=line>Looking in indexes: https://pypi.douban.com/simple/</span><br><span class=line>Collecting jupyter</span><br><span class=line>Downloading</span><br><span class=line>https://pypi.doubanio.com/packages/83/df/0f5dd132200728a86190397e1ea87cd762</span><br><span class=line>44e42d39ec5e88efd25b2abd7e/jupyter-1.0.0-py2.py3-none-any.whl</span><br><span class=line>……省略部分信息</span><br><span class=line>Successfully installed MarkupSafe-1.1.1 Send2Trash-1.5.0 attrs-19.3.0</span><br><span class=line>bleach-3.1.0 defusedxml-0.6.0 entrypoints-0.3 ipykernel-5.1.3 ipywidgets7.5.1 jinja2-2.10.3 jsonschema-3.2.0 jupyter-1.0.0 jupyter-client-5.3.4</span><br><span class=line>jupyter-console-6.0.0 jupyter-core-4.6.1 mistune-0.8.4 nbconvert-5.6.1</span><br><span class=line>nbformat-5.0.3 notebook-6.0.2 pandocfilters-1.4.2 prometheus-client-0.7.1</span><br><span class=line>prompt-toolkit-2.0.10 pyrsistent-0.15.7 python-dateutil-2.8.1 pyzmq-18.1.1</span><br><span class=line>qtconsole-4.6.0 terminado-0.8.3 testpath-0.4.4 tornado-6.0.3 webencodings0.5.1 widgetsnbextension-3.5.1</span><br></pre></td></tr></table></figure><p>由于我们是在Linux下安装jupyter，如果我们的Linux没有图形界面，可以通过设置–no-browser和设 置–ip=0.0.0.0进行外部访问，如果不指定–ip参数，默认IP是localhost，也就是只有本地才能访问。如 下所示：</p><figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre></td><td class=code><pre><span class=line>[root@localhost ~]# jupyter notebook --no-browser --ip=0.0.0.0 --allow-root</span><br><span class=line>[I 13:06:33.656 NotebookApp] 启动notebooks 在本地路径: /root</span><br><span class=line>[I 13:06:33.657 NotebookApp] 本程序运行在: http://localhost:8888/?</span><br><span class=line>token=33fdb8256c7c1d13a23b8189ea0f4e7b7f434f14cc07ea5e</span><br><span class=line>[I 13:06:33.657 NotebookApp] or http://127.0.0.1:8888/?</span><br><span class=line>token=33fdb8256c7c1d13a23b8189ea0f4e7b7f434f14cc07ea5e</span><br><span class=line>[I 13:06:33.657 NotebookApp] 使用control-c停止此服务器并关闭所有内核(两次跳过确认).</span><br><span class=line>[C 13:06:33.727 NotebookApp]</span><br><span class=line></span><br><span class=line>	To access the notebook, open this file in a browser:</span><br><span class=line>		file:///root/.local/share/jupyter/runtime/nbserver-3998-open.html</span><br><span class=line>	Or copy and paste one of these URLs:</span><br><span class=line>		http://localhost:8888/?</span><br><span class=line>token=33fdb8256c7c1d13a23b8189ea0f4e7b7f434f14cc07ea5e</span><br><span class=line>	or http://127.0.0.1:8888/?</span><br><span class=line>token=33fdb8256c7c1d13a23b8189ea0f4e7b7f434f14cc07ea5e</span><br></pre></td></tr></table></figure><p>从jupyter notebook的输出结果可以看到，jupyter notebook命令给出了一个URL，我们只需将该URL 拷贝至浏览器中，然后将0.0.0.0替换为Linux服务器的IP即可。</p><blockquote><p>在Windows下可以使用远程连接工具xmanager来操作</p></blockquote><p>通过浏览器访问jupyter给我们的URL，就可以登录到jupyter的主界面。这个界面会显示当前目录下的 所有文件<br><img data-src="https://img-blog.csdnimg.cn/20200427203400246.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTYzNjcwMg==,size_16,color_FFFFFF,t_70" alt=在这里插入图片描述></p><p>登录jupyter的主界面后，我们如果要创建一个文件，只需要单击“新建”，选择你希望启动的Notebook 类型即可。我们选择Python 3。选择Python 3以后，浏览器会打开一个新的页面。在这个新的页面中， 可以看到一个空的Notebook界面。</p><p>jupyter界面由以下部分组成：</p><figure class="highlight tex"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre></td><td class=code><pre><span class=line>标题栏</span><br><span class=line>菜单栏</span><br><span class=line>快捷键</span><br><span class=line>编辑区</span><br></pre></td></tr></table></figure><p>在菜单栏中有一个“帮助”选项，读者可以通过该选项得到jupyter的使用说明。jupyter本身是图形界面的 应用，使用比较简单，因此，本教程不会花很多篇幅来介绍jupyter的使用。<br><img data-src="https://img-blog.csdnimg.cn/20200427203426132.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTYzNjcwMg==,size_16,color_FFFFFF,t_70" alt=在这里插入图片描述></p><p>在jupyter的编辑区中默认有一个输入框。输入框在jupyter中称为cell。我们可以通过菜单栏的“cell”选项 控制cell的格式、执行cell的代码。与此同时，我们也可以通过快捷键控制cell，如ctrl+enter快捷键用以 执行cell中的代码，shift+enter快捷键用以执行当前cell中的代码，并且在当前cell下方创建一个新的 cell。<br><img data-src="https://img-blog.csdnimg.cn/20200427203444853.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTYzNjcwMg==,size_16,color_FFFFFF,t_70" alt=在这里插入图片描述></p><p>jupyter之所以能够进行编程教学和幻灯片演示，是因为它可以支持富文本格式和markdown格式。我们 只需修改cell的类型为“Markdown”，就可以在cell中使用markdown语句进行输入了。我们也可以在 jupyter中画图。为了在jupyter中画图，我们需要先安装matplotlib。如下所示：</p><figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre></td><td class=code><pre><span class=line>[root@localhost ~]# pip install matplotlib</span><br><span class=line>Looking in indexes: https://pypi.douban.com/simple/</span><br><span class=line>Collecting matplotlib</span><br><span class=line>Downloading</span><br><span class=line>https://pypi.doubanio.com/packages/53/6c/7b400d45f0ecd6703b2779a7dfda657857</span><br><span class=line>9a353748e1b43d8353cb7f5b7f/matplotlib-3.1.2-cp38-cp38-manylinux1_x86_64.whl</span><br><span class=line>(13.1MB)</span><br><span class=line>|████████████████████████████████| 13.1MB 1.8MB/s</span><br><span class=line>……省略部分信息</span><br><span class=line>Installing collected packages: kiwisolver, numpy, pyparsing, cycler,</span><br><span class=line>matplotlib</span><br><span class=line>Successfully installed cycler-0.10.0 kiwisolver-1.1.0 matplotlib-3.1.2</span><br><span class=line>numpy-1.18.1 pyparsing-2.4.6</span><br></pre></td></tr></table></figure><p>安装matplotlib以后就可以在jupyter中画图了，下面给出了一个jupyter使用的例子。</p><figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>import</span> matplotlib.pyplot <span class=keyword>as</span> plt</span><br><span class=line><span class=keyword>import</span> numpy</span><br><span class=line>x = numpy.arange(<span class=number>11</span>)</span><br><span class=line>y = x**<span class=number>2</span></span><br><span class=line>plt.plot(x, y)</span><br></pre></td></tr></table></figure><p>运行结果如下图：<br><img data-src="https://img-blog.csdnimg.cn/20200427203507236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTYzNjcwMg==,size_16,color_FFFFFF,t_70" alt=在这里插入图片描述></p><h3 id=四、Python工作环境管理><a class=header-anchor href=#四、Python工作环境管理>¶</a>四、Python工作环境管理</h3><p>Python 2和Python 3之间存在着较大的差异，并且，由于各种原因导致了Python 2和Python 3的长期 共存。在实际工作过程中，我们可能会同时用到Python 2和Python 3，因此，需要经常在Python 2和 Python 3之间进行来回切换。此外，如果你是喜欢尝鲜的人，那么，你很有可能在Python新版本出来 的时候立即下载Python的版本，试验Python的特性。</p><p>在Python世界里，除了需要对Python的版本进行管理以外，还需要对不同的软件包进行管理。大部分 情况下，对于开源的库我们使用***版本即可。但是，有时候可能需要对相同的Python版本，在不同的 项目中使用不同版本的软件包。</p><p>在这一节里，我们将介绍两个工具，即pyenv和virtualenv。前者用于管理不同的Python版本，后者用 于管理不同的工作环境。有了这两个工具，Python相关的版本问题将不再是问题。</p><h4 id=4-1、使用pyenv管理不同的Python版本><a class=header-anchor href=#4-1、使用pyenv管理不同的Python版本>¶</a>4.1、使用pyenv管理不同的Python版本</h4><p>安装不同的Python版本并不是一件容易的事情，在不同的Python版本之间来回切换更加困难，而且， 多版本并存非常容易互相干扰。因此，我们需要一个名为pyenv的工具。pyenv是一个Python版本管理 工具，它能够进行全局的Python版本切换，也可以为单个项目提供对应的Python版本。使用pyenv以 后，可以在服务器上安装多个不同的Python版本，也可以安装不同的Python实现。不同Python版本之 间的切换也非常简单。接下来我们就一起看一下pyenv的安装和使用。</p><h5 id=1、-pyenv的安装><a class=header-anchor href=#1、-pyenv的安装>¶</a>1、.pyenv的安装</h5><p>我们直接从GitHub下载项目到本地，然后，分别执行以下命令进行安装即可</p><figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre></td><td class=code><pre><span class=line>[root@localhost .pip]# yum -y install git</span><br><span class=line>[root@localhost .pip]# git clone https://github.com/yyuu/pyenv.git ～/.pyenv</span><br><span class=line></span><br><span class=line>正克隆到 '～/.pyenv'...</span><br><span class=line>remote: Enumerating objects: 8, done.</span><br><span class=line>remote: Counting objects: 100% (8/8), done.</span><br><span class=line>remote: Compressing objects: 100% (8/8), done.</span><br><span class=line>remote: Total 17600 (delta 2), reused 2 (delta 0), pack-reused 17592</span><br><span class=line>接收对象中: 100% (17600/17600), 3.44 MiB | 601.00 KiB/s, done.</span><br><span class=line>处理 delta 中: 100% (11954/11954), done.</span><br><span class=line></span><br><span class=line>[root@localhost .pip]# echo 'export PYENV_ROOT="$HOME/.pyenv"' &gt;&gt;</span><br><span class=line>～/.bash_profile</span><br><span class=line>[root@localhost .pip]# echo 'export PATH="$PYENV_ROOT/bin:$PATH"' &gt;&gt;</span><br><span class=line>～/.bash_profile</span><br><span class=line>[root@localhost .pip]# echo 'eval "$(pyenv init -)"' &gt;&gt;～/.bash_profile</span><br></pre></td></tr></table></figure><p>安装完成以后需要重新载入配置文件，或者退出以后重新登录，以使～/.bash_profile中的配置生效。 笔者一般选择使用source命令重新载入配置文件，如下所示：</p><figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line>[root@localhost .pip]# source ~/.bash_profile</span><br></pre></td></tr></table></figure><p>至此，pyenv就安装完成了，我们可以通过下面的命令验证pyenv是否正确安装并获取pyenv的帮助信 息：</p><figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br></pre></td><td class=code><pre><span class=line>[root@localhost ~]# pyenv --help</span><br><span class=line>Usage: pyenv &lt;command&gt; [&lt;args&gt;]</span><br><span class=line></span><br><span class=line>Some useful pyenv commands are:</span><br><span class=line>	commands 	List all available pyenv commands</span><br><span class=line>	commands 	List all available pyenv commands</span><br><span class=line>	exec 	Run an executable with the selected Python version</span><br><span class=line>	global 	Set or show the global Python version</span><br><span class=line>	help 	Display help for a command</span><br><span class=line>	hooks 	List hook scripts for a given pyenv command</span><br><span class=line>	init 	Configure the shell environment for pyenv</span><br><span class=line>	install 	Install a Python version using python-build</span><br><span class=line>	local 	Set or show the local application-specific Python version</span><br><span class=line>	prefix 	Display prefix for a Python version</span><br><span class=line>	rehash 	Rehash pyenv shims (run this after installing executables)</span><br><span class=line>	root 	Display the root directory where versions and shims are kept</span><br><span class=line>	shell 	Set or show the shell-specific Python version</span><br><span class=line>	shims 	List existing pyenv shims</span><br><span class=line>	uninstall 	Uninstall a specific Python version</span><br><span class=line>	version 	Show the current Python version and its origin</span><br><span class=line>	--version 	Display the version of pyenv</span><br><span class=line>	version-file 	Detect the file that sets the current pyenv version</span><br><span class=line>	version-name 	Show the current Python version</span><br><span class=line>	version-origin 	Explain how the current Python version is set</span><br><span class=line>	versions 	List all Python versions available to pyenv</span><br><span class=line>	whence 	List all Python versions that contain the given executable</span><br><span class=line>	which 	Display the full path to an executable</span><br><span class=line></span><br><span class=line>See `pyenv help &lt;command&gt;' for information on a specific command.</span><br><span class=line>For full documentation, see: https://github.com/pyenv/pyenv#readme</span><br></pre></td></tr></table></figure><h5 id=2、pyenv的使用><a class=header-anchor href=#2、pyenv的使用>¶</a>2、pyenv的使用</h5><p>我们通过pyenv的install命令，可以查看pyenv当前支持哪些Python版本，如下所示</p><figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre></td><td class=code><pre><span class=line>[root@localhost ~]# pyenv install --list</span><br><span class=line>Available versions:</span><br><span class=line>2.1.3</span><br><span class=line>……省略部分信息</span><br><span class=line>3.8.0</span><br><span class=line>3.8-dev</span><br><span class=line>3.8.1</span><br><span class=line>3.9-dev</span><br><span class=line>……省略部分信息</span><br><span class=line>anaconda3-2018.12</span><br><span class=line>anaconda3-2019.03</span><br><span class=line>anaconda3-2019.07</span><br><span class=line>anaconda3-2019.10</span><br><span class=line>……省略部分信息</span><br></pre></td></tr></table></figure><p>由于pyenv可以安装的Python版本列表非常长，所以，这里进行了省略。读者可以在自己电脑上安装 pyenv，然后执行pyenv install --list命令进行查看。可以看到，pyenv不但可以安装不同的Python版 本，而且还可以安装不同的Python实现，也可以安装***版本的Python用以学习。</p><p>查看当前系统中包含的Python版本：</p><figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre></td><td class=code><pre><span class=line>[root@localhost ~]# pyenv versions</span><br><span class=line>* system (set by /root/.pyenv/version)</span><br></pre></td></tr></table></figure><p>使用pyenv安装不同的Python版本：</p><figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre></td><td class=code><pre><span class=line>pyenv install -v 3.6.0</span><br><span class=line>pyenv install -v 2.7.13</span><br></pre></td></tr></table></figure><p>再次查看当前系统中包含的Python版本：</p><figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre></td><td class=code><pre><span class=line>[root@localhost ~]# pyenv versions</span><br><span class=line>* system (set by /root/.pyenv/version)</span><br><span class=line>2.7.13</span><br><span class=line>3.8.1</span><br></pre></td></tr></table></figure><p>由于我们安装了2个Python版本，加上我们系统自身的Python，当前系统中存在3个不同的Python版 本。其中，输出结果前面的“*”表示当前正在使用的版本。我们也可以通过pyenv global选择不同的 Python版本，如下所示：</p><figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre></td><td class=code><pre><span class=line>[root@localhost ~]# pyenv global 3.8.1</span><br><span class=line>[root@localhost ~]# pyenv versions</span><br><span class=line>system</span><br><span class=line>2.7.13</span><br><span class=line>* 3.8.1 (set by /root/.pyenv/version)</span><br><span class=line>[root@localhost ~]# python</span><br><span class=line>Python 3.8.1 (default, Jan 14 2020, 12:20:36)</span><br><span class=line>[GCC 4.8.5 20150623 (Red Hat 4.8.5-39)] on linux</span><br><span class=line>Type "help", "copyright", "credits" or "license" for more information.</span><br><span class=line><span class=meta>&gt;</span><span class=bash>&gt;&gt; <span class=built_in>exit</span>()</span></span><br><span class=line>[root@localhost ~]# pyenv global 2.7.13</span><br><span class=line>[root@localhost ~]# python</span><br><span class=line>Python 2.7.13 (default, Jan 14 2020, 12:27:38)</span><br><span class=line>[GCC 4.8.5 20150623 (Red Hat 4.8.5-39)] on linux2</span><br><span class=line>Type "help", "copyright", "credits" or "license" for more information.</span><br><span class=line><span class=meta>&gt;</span><span class=bash>&gt;&gt;</span></span><br></pre></td></tr></table></figure><p>使用pyenv以后，可以快速切换Python的版本。切换Python版本以后，与版本相关的依赖也会一起切 换。因此，我们不用担心不同的版本在系统中是否会相互干扰。例如，切换Python版本以后，相应的 pip也会跟着切换，所以不用担心自己使用的pip版本和Python版本不匹配的问题，如下所示：</p><figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre></td><td class=code><pre><span class=line>[root@localhost ~]# pyenv global 3.8.1</span><br><span class=line>[root@localhost ~]# pip --version</span><br><span class=line>pip 19.2.3 from /root/.pyenv/versions/3.8.1/lib/python3.8/site-packages/pip</span><br><span class=line>(python 3.8)</span><br></pre></td></tr></table></figure><p>如果想要删除Python版本，使用uninstall命令即可。如下所示：</p><figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line>pyenv uninstall 2.7.10</span><br></pre></td></tr></table></figure><h4 id=4-2、-使用virtualenv管理不同的项目><a class=header-anchor href=#4-2、-使用virtualenv管理不同的项目>¶</a>4.2、 使用virtualenv管理不同的项目</h4><p>virtualenv本身是一个独立的项目，用以隔离不同项目的工作环境。例如，用户lmx希望在项目A中使用 Flask 0.8这个版本，与此同时，又想在项目B中使用Flask 0.9这个版本。如果我们全局安装Flask，必然 无法满足用户的需求。这个时候，我们就可以使用virtualenv。</p><p>读者需要注意pyenv和virtualenv的区别。pyenv用以管理不同的Python版本，例如，你的系统工作时 使用Python 2.7.13，学习时使用Python 3.6.0。virtualenv用以隔离项目的工作环境，例如，项目A和 项目B都是使用Python 2.7.13，但是，项目A需要使用Flask 0.8版本，项目B需要使用Flask 0.9版本。我 们只要组合pyenv和virtualenv这两个工具，就能够构造Python和第三方库的任意版本组合，拥有很好 的灵活性，也避免了项目之间的相互干扰。</p><p>virtualenv本身是一个独立的工具，用户可以不使用pyenv而单独使用virtualenv。但是，如果你使用了 pyenv，就需要安装pyenv-virtualenv插件，而不是通过virtualenv软件使用virtualenv的功能。</p><h5 id=1、pyenv-virtualenv的安装><a class=header-anchor href=#1、pyenv-virtualenv的安装>¶</a>1、pyenv-virtualenv的安装</h5><p>安装和使用pyenv-virtualenv插件如下所示：</p><figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre></td><td class=code><pre><span class=line>[root@localhost ~]# git clone https://github.com/yyuu/pyenv-virtualenv.git</span><br><span class=line><span class=meta>$</span><span class=bash>(pyenv root)/plugins/pyenv-virtualenv</span></span><br><span class=line>正克隆到 '/root/.pyenv/plugins/pyenv-virtualenv'...</span><br><span class=line>remote: Enumerating objects: 2064, done.</span><br><span class=line>remote: Total 2064 (delta 0), reused 0 (delta 0), pack-reused 2064</span><br><span class=line>接收对象中: 100% (2064/2064), 580.31 KiB | 264.00 KiB/s, done.</span><br><span class=line>处理 delta 中: 100% (1413/1413), done.</span><br><span class=line>[root@localhost ~]# echo 'eval "$(pyenv virtualenv-init -)"'</span><br><span class=line><span class=meta>&gt;</span><span class=bash>&gt;~/.bash_profile</span></span><br></pre></td></tr></table></figure><p>与安装pyenv类似，安装完成以后需要重新载入配置文件，或者退出用户再登录，以使得配置文件生 效：</p><figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre></td><td class=code><pre><span class=line>[root@localhost ~]# source ~/.bash_profile</span><br><span class=line>[root@localhost ~]# pyenv help virtualenv</span><br><span class=line>Usage: pyenv virtualenv [-f|--force] [VIRTUALENV_OPTIONS] [version]</span><br><span class=line>&lt;virtualenv-name&gt;</span><br><span class=line>		pyenv virtualenv --version</span><br><span class=line>		pyenv virtualenv --help</span><br><span class=line>     -f/--force 	Install even if the version appears to be installed</span><br><span class=line>already</span><br></pre></td></tr></table></figure><h5 id=2、pyenv-virtualenv的使用><a class=header-anchor href=#2、pyenv-virtualenv的使用>¶</a>2、pyenv-virtualenv的使用</h5><p>有了pyenv-virtualenv以后，我们可以为同一个Python解释器，创建多个不同的工作环境。例如，我们 新建两个工作环境：</p><figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre></td><td class=code><pre><span class=line>[root@localhost ~]# pyenv virtualenv 3.8.1 first_project</span><br><span class=line>[root@localhost ~]# pyenv virtualenv 3.8.1 second_project</span><br></pre></td></tr></table></figure><p>可以使用virtualenvs子命令查看工作环境：</p><figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre></td><td class=code><pre><span class=line>[root@localhost ~]# pyenv virtualenvs</span><br><span class=line>	3.8.1/envs/first_project (created from /root/.pyenv/versions/3.8.1)</span><br><span class=line>	3.8.1/envs/second_project (created from 	/root/.pyenv/versions/3.8.1)</span><br><span class=line>	first_project (created from /root/.pyenv/versions/3.8.1)</span><br><span class=line>	second_project (created from /root/.pyenv/versions/3.8.1)</span><br></pre></td></tr></table></figure><p>创建完工作环境以后，可以通过activate和deactivate子命令进入或退出一个工作环境。进入工作环境 以后，左边的提示符会显示你当前所在的工作环境，以免因为环境太多导致操作错误。</p><figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre></td><td class=code><pre><span class=line>[root@localhost ~]# pyenv activate first_project</span><br><span class=line>pyenv-virtualenv: prompt changing will be removed from future release.</span><br><span class=line>configure `export PYENV_VIRTUALENV_DISABLE_PROMPT=1' to simulate the</span><br><span class=line>behavior.</span><br><span class=line>(first_project) [root@localhost ~]# pip install flask==1.1.1</span><br><span class=line>Looking in indexes: https://pypi.douban.com/simple/</span><br><span class=line>Collecting flask</span><br><span class=line>	Downloading</span><br><span class=line>https://pypi.doubanio.com/packages/9b/93/628509b8d5dc749656a9641f4caf13540e</span><br><span class=line>2cdec85276964ff8f43bbb1d3b/Flask-1.1.1-py2.py3-none-any.whl (94kB)</span><br><span class=line>	|████████████████████████████████| 102kB 4.7MB/s</span><br><span class=line>……省略部分信息</span><br><span class=line>Successfully installed Jinja2-2.10.3 MarkupSafe-1.1.1 Werkzeug-0.16.0</span><br><span class=line>click-7.0 flask-1.1.1 itsdangerous-1.1.0</span><br><span class=line>(first_project) [root@localhost ~]# pyenv deactivate</span><br></pre></td></tr></table></figure><p>接下来，我们看一下在不同的工作环境安装不同的Flask版本：</p><figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre></td><td class=code><pre><span class=line>[root@localhost ~]# pyenv activate first_project</span><br><span class=line>(first_project) [root@localhost ~]# pip install flask==1.1.1</span><br><span class=line>(first_project) [root@localhost ~]# pyenv deactivate</span><br><span class=line></span><br><span class=line>(second_project) [root@localhost ~]# pip install flask==0.10.1</span><br></pre></td></tr></table></figure><p>如果想要删除虚拟环境，则使用：</p><figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line>(first_project) [root@localhost ~]# pyenv virtualenv-delete first_project</span><br></pre></td></tr></table></figure><p>使用pyenv和python-virtualenv插件，我们就能够自由地在不同的版本之间进行切换，相比管理Python 版本，不但节省了时间，也避免了工作过程中的相互干扰。</p></div><div><ul class=post-copyright><li class=post-copyright-author><strong>本文作者：</strong>Maisy</li><li class=post-copyright-link><strong>本文链接：</strong> <a href=https://pdxblog.top/Python%E7%94%9F%E6%80%81%E5%B7%A5%E5%85%B7.html title=Python生态工具>https://pdxblog.top/Python生态工具.html</a></li><li class=post-copyright-license><strong>版权声明：</strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel=noopener target=_blank><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class=post-footer><div class=post-tags><a href="/tags/Python/" rel=tag># Python</a></div><div class=post-nav><div class=post-nav-item><a href=/Python%E5%87%BD%E6%95%B0.html rel=prev title=Python函数><i class="fa fa-chevron-left"></i> Python函数</a></div><div class=post-nav-item><a href=/Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E5%AD%97%E5%85%B8.html rel=next title=Python数据类型之字典>Python数据类型之字典 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class=comments id=valine-comments></div><script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class=sidebar><div class=sidebar-inner><ul class="sidebar-nav motion-element"><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class=nav><li class="nav-item nav-level-2"><a class=nav-link href=#Python生态工具><span class=nav-number>1.</span> <span class=nav-text>¶Python生态工具</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#一、Python内置小工具><span class=nav-number>1.1.</span> <span class=nav-text>¶一、Python内置小工具</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#1-1、-1秒钟启动一个下载服务器><span class=nav-number>1.1.1.</span> <span class=nav-text>¶1.1、 1秒钟启动一个下载服务器</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#1-2、字符串转换为JSON><span class=nav-number>1.1.2.</span> <span class=nav-text>¶1.2、字符串转换为JSON</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#1-3、检查第三方库是否正常安装><span class=nav-number>1.1.3.</span> <span class=nav-text>¶1.3、检查第三方库是否正常安装</span></a></li></ol></li><li class="nav-item nav-level-3"><a class=nav-link href=#二、pip高级用法><span class=nav-number>1.2.</span> <span class=nav-text>¶二、pip高级用法</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#2-1、pip介绍><span class=nav-number>1.2.1.</span> <span class=nav-text>¶2.1、pip介绍</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#2-2、python3安装pip><span class=nav-number>1.2.2.</span> <span class=nav-text>¶2.2、python3安装pip</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#2-3、给pip3重命名><span class=nav-number>1.2.3.</span> <span class=nav-text>¶2.3、给pip3重命名</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#2-4、pip3常用命令><span class=nav-number>1.2.4.</span> <span class=nav-text>¶2.4、pip3常用命令</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#2-5、加速pip安装的技巧><span class=nav-number>1.2.5.</span> <span class=nav-text>¶2.5、加速pip安装的技巧</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#1、使用豆瓣或阿里云的源加速软件安装><span class=nav-number>1.2.5.1.</span> <span class=nav-text>¶1、使用豆瓣或阿里云的源加速软件安装</span></a></li><li class="nav-item nav-level-5"><a class=nav-link href=#2、将软件下载到本地部署><span class=nav-number>1.2.5.2.</span> <span class=nav-text>¶2、将软件下载到本地部署</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class=nav-link href=#三、Python变成辅助工具><span class=nav-number>1.3.</span> <span class=nav-text>¶三、Python变成辅助工具</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#3-1、Python交互式编程><span class=nav-number>1.3.1.</span> <span class=nav-text>¶3.1、Python交互式编程</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#3-2、使用IPython交互编程><span class=nav-number>1.3.2.</span> <span class=nav-text>¶3.2、使用IPython交互编程</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#（1）更好的编辑器><span class=nav-number>1.3.2.1.</span> <span class=nav-text>¶（1）更好的编辑器</span></a></li><li class="nav-item nav-level-5"><a class=nav-link href=#（2）使用IPython来解析MySQL的备份日志><span class=nav-number>1.3.2.2.</span> <span class=nav-text>¶（2）使用IPython来解析MySQL的备份日志</span></a></li><li class="nav-item nav-level-5"><a class=nav-link href=#（3）更好地获取帮助信息><span class=nav-number>1.3.2.3.</span> <span class=nav-text>¶（3）更好地获取帮助信息</span></a></li><li class="nav-item nav-level-5"><a class=nav-link href=#（4）magic函数><span class=nav-number>1.3.2.4.</span> <span class=nav-text>¶（4）magic函数</span></a></li><li class="nav-item nav-level-5"><a class=nav-link href=#（5）保存历史><span class=nav-number>1.3.2.5.</span> <span class=nav-text>¶（5）保存历史</span></a></li><li class="nav-item nav-level-5"><a class=nav-link href=#（6）与操作系统交互><span class=nav-number>1.3.2.6.</span> <span class=nav-text>¶（6）与操作系统交互</span></a></li></ol></li><li class="nav-item nav-level-4"><a class=nav-link href=#3-3、-jupyter的使用><span class=nav-number>1.3.3.</span> <span class=nav-text>¶3.3、 jupyter的使用</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#（1）、jupyter介绍><span class=nav-number>1.3.3.1.</span> <span class=nav-text>¶（1）、jupyter介绍</span></a></li><li class="nav-item nav-level-5"><a class=nav-link href=#（2）、-jupyter-notebook的使用><span class=nav-number>1.3.3.2.</span> <span class=nav-text>¶（2）、 jupyter notebook的使用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class=nav-link href=#四、Python工作环境管理><span class=nav-number>1.4.</span> <span class=nav-text>¶四、Python工作环境管理</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#4-1、使用pyenv管理不同的Python版本><span class=nav-number>1.4.1.</span> <span class=nav-text>¶4.1、使用pyenv管理不同的Python版本</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#1、-pyenv的安装><span class=nav-number>1.4.1.1.</span> <span class=nav-text>¶1、.pyenv的安装</span></a></li><li class="nav-item nav-level-5"><a class=nav-link href=#2、pyenv的使用><span class=nav-number>1.4.1.2.</span> <span class=nav-text>¶2、pyenv的使用</span></a></li></ol></li><li class="nav-item nav-level-4"><a class=nav-link href=#4-2、-使用virtualenv管理不同的项目><span class=nav-number>1.4.2.</span> <span class=nav-text>¶4.2、 使用virtualenv管理不同的项目</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#1、pyenv-virtualenv的安装><span class=nav-number>1.4.2.1.</span> <span class=nav-text>¶1、pyenv-virtualenv的安装</span></a></li><li class="nav-item nav-level-5"><a class=nav-link href=#2、pyenv-virtualenv的使用><span class=nav-number>1.4.2.2.</span> <span class=nav-text>¶2、pyenv-virtualenv的使用</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=Maisy src=/images/author.jpg><p class=site-author-name itemprop=name>Maisy</p><div class=site-description itemprop=description>人的一生就是一个储蓄的过程，在奋斗的时候储存了希望；在耕耘的时候储存了一粒种子；在旅行的时候储存了风景；在微笑的时候储存了快乐。聪明的人善于储蓄，在漫长而短暂的人生旅途中，学会储蓄每一个闪光的瞬间，然后用它们酿成一杯美好的回忆，在四季的变幻与交替之间，散发浓香，珍藏一生</div></div><div class="site-state-wrap motion-element"><nav class=site-state><div class="site-state-item site-state-posts"><a href="/archives/"><span class=site-state-item-count>54</span> <span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class=site-state-item-count>5</span> <span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class=site-state-item-count>5</span> <span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class=links-of-author-item><a href=https://github.com/Gilbert2/Gilbert2.github.io title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Gilbert2&#x2F;Gilbert2.github.io" rel=noopener target=_blank><i class="fab fa-github fa-fw"></i>GitHub</a></span> <span class=links-of-author-item><a href=https://blog.csdn.net/weixin_45636702 title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_45636702" rel=noopener target=_blank><i class="fab fa-crosshairs fa-fw"></i>CSDN</a></span></div><div class="cc-license motion-element" itemprop=license><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class=cc-opacity rel=noopener target=_blank><img src=/images/cc-by-nc-sa.svg alt="Creative Commons"></a></div></div></div></aside><div id=sidebar-dimmer></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy; 2019 – <span itemprop=copyrightYear>2020</span> <span class=with-love><i class="fa fa-heart"></i></span> <span class=author itemprop=copyrightHolder>Maisy</span> <span class=post-meta-divider>|</span> <span class=post-meta-item-icon><i class="fa fa-chart-area"></i></span> <span class=post-meta-item-text>站点总字数：</span> <span title=站点总字数>328k</span> <span class=post-meta-divider>|</span> <span class=post-meta-item-icon><i class="fa fa-coffee"></i></span> <span class=post-meta-item-text>站点阅读时长 &asymp;</span> <span title=站点阅读时长>4:58</span></div><div class=powered-by>由 <a href="https://hexo.io/" class=theme-link rel=noopener target=_blank>Hexo</a> & <a href="https://muse.theme-next.org/" class=theme-link rel=noopener target=_blank>NexT.Muse</a> 强力驱动</div><script async src=//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js></script><div class=busuanzi-count><script async src=https://cdn.busuanzi.ibruce.info/cdn/busuanzi/2.3/busuanzi.pure.mini.j></script><span class=post-meta-item id=busuanzi_container_site_uv style="display: none;"><span class=post-meta-item-icon><i class="fa fa-user"></i></span> <span class=site-uv title=总访客量><span id=busuanzi_value_site_uv></span></span></span> <span class=post-meta-divider>|</span> <span class=post-meta-item id=busuanzi_container_site_pv style="display: none;"><span class=post-meta-item-icon><i class="fa fa-eye"></i></span> <span class=site-pv title=总访问量><span id=busuanzi_value_site_pv></span></span></span></div></div></footer></div><script src=/lib/anime.min.js></script><script src=//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js></script><script src=//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js></script><script src=//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js></script><script src=/lib/velocity/velocity.min.js></script><script src=/lib/velocity/velocity.ui.min.js></script><script src=/js/utils.js></script><script src=/js/motion.js></script><script src=/js/schemes/muse.js></script><script src=/js/next-boot.js></script><script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script><script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('https://cdn.jsdelivr.net/npm/valine@1.3.9/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'yK6nF3Ng27WevBtHAbTkt8Jv-gzGzoHsz',
      appKey     : 'DXAxzx0igQL9KzyblmtXnVkh',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script></body></html>